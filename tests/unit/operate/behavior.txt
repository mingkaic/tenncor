// FUNCTIONAL BIND
A000 - abs ebinds to "abs". it returns the absolute value of input
A001 - neg ebinds to "neg". it returns the negative value of input
A002 - logical not ebinds to "logic_not". it applies the ! operator to input
A003 - sin ebinds to "sin". it applies the std::sin operator to input
A004 - cos ebinds to "cos". it applies the std::cos operator to input
A005 - tan ebinds to "tan". it applies the std::tan operator to input
A006 - exp ebinds to "exp". it applies the std::exp operator to input
A007 - log ebinds to "log". it applies the std::log operator to input
A008 - sqrt ebinds to "sqrt". it applies the std::sqrt operator to input
A009 - round ebinds to "round". it applies the std::round operator to input

A010 - pow ebinds to "pow". it takes 2 inputs returns input1 to the power of input2
A011 - add ebinds to "add". it takes 2 inputs returns the sum
A012 - sub ebinds to "sub". it takes 2 inputs returns the difference
A013 - mul ebinds to "mul". it takes 2 inputs returns the product
A014 - div ebinds to "div". it takes 2 inputs returns the quotient
A015 - eq ebinds to "eq". it takes 2 inputs and applies the == operator to inputs
A016 - neq ebinds to "neq". it takes 2 inputs and applies the != operator to inputs
A017 - lt ebinds to "lt". it takes 2 inputs and applies the < operator to inputs
A018 - gt ebinds to "gt". it takes 2 inputs and applies the > operator to inputs
A019 - rand_uniform ebinds to "rand_uniform". 
		it takes 2 inputs and returns the uniform_..._distribution(input1, input2)
A020 - rand_binom ebinds to "rand_binom". 
		it takes 2 inputs and returns the binomial_distribution(input1, input2)
		throws bad_function_call if type is double or float
A021 - rand_normal ebinds to "rand_normal". 
		it takes 2 inputs and returns the normal_distribution(input1, input2)
		throws bad_function_call if type is integer
A022 - matmul ebinds to "matmul". it takes 2 inputs and 
		returns matrix multiplication of the first 2 dimensions of inputs

A023 - argmax abinds to "argmax". it returns the index of the max value
A024 - max abinds to "max". it returns the max value
A025 - sum abinds to "sum". it returns the sum of the inputs

// OPERATION OPTIMIZATION
B000 - multiple constant containing the same values will use the same instance
B001 - multiple operations on the same array of arguments will use the same instance

// GRAPH SERIALIZATION
C000 - graph serialization creates the same graph structure (without constraints on node id)
C001 - serialized nodes saves the labels
C002 - serialized constant saves the data
C003 - serialized placeholder saves the allowed shape
C004 - serialized variable saves the data_ep_, the data source, and the allowed shape
C005 - serialized functor saves the opcode, deserialization constructs the same type of operation
C006 - data serialization and deserialization persists the data in variables




// ELEMENTARY BEHAVIORS
A000 - any operation accepting nullptr as any operand returns nullptr
A001 - any operation on constants applies operation at build-time and return the resulting constant
A002 - both unary and binary elementary operations output shape is the same as input shape
A003 - binary elementary operations with 2 nodal input having different shapes throw error during evaluation
A004 - addition accepting 0 as a scalar or node constant returns the non-zero node,
		adding constants with a scalar returns a constant sum of constants and scalar
A005 - subtraction accepting 0 as a scalar or node constant
		returns first node if 0 is subtrahend (operand 2)
		return negative of first node if 0 is minuend (operand 1)
		subtracting constants with a scalar returns a constant difference between constants and scalar
A006 - multiplication accepting 0 as scalar or node constant returns 0 constant
A007 - multiplication accepting 1 as scalar or node constant return non-one node
		multiplying constants with a scalar returns a constant product of constants and scalar
A008 - division accepting 0 as s scalar or node constant
		returns 0 constant if 0 is dividend (operand 1)
		throws error if 0 is divisor (operand 2)
A009 - division accepting 1 as a scalar or node constant returns non-one, if 1 is divisor (operand 2)
		dividing constants with a scalar returns a constant quotient of constants and scalar
(UNTESTED) A010 - powers of accepting 0 as the scalar exponent returns a 1 constant, powers of accepting 1 as the input node
A011 - a inode is equal (using operator ==) to a primitive value if it is scalar shape ({1})
		and its value is equivalent to the primitive value
		same applies for not equal (!=),
		equality and inequality fails assertion if input node has bad status
A012 - binary elementary operations on varptrs of n_elem=1 the output shape is the non-one elem
(UNTESTED) A013 - F_axial_J considers the J argument as lacking the specified dimension that the non-J argument has
		perform F operation for all values along slices along the dimension.
		For example: A<3, 4, 5, 6> operates with B<3, 5, 6> with dimension 1 being missing for B
		for all valid <x, z, w>, output[x, 0..3, z, w] = F(A[x, 0..3, z, w], B[x, z, w])
(UNTESTED) A014 - F_axial_J fails for shapes that do not match while accommodating for the missing shape.
		For example: A<3, 4, 5, 6> fails with B<2, 4, 5> since shapes don't match
		even if B has dimension 4 of 6
(UNTESTED) binomial_sample...

// TRANSFORM BEHAVIORS
B000 - any operation accepting nullptr as any operand returns nullptr
B001 - transpose accepts tensors of 1-D and 2-D, output tensor is always 2-D,
		with 1-D shapes interpreted as shape <dim1, 1>
B002 - fit pads data with zeros for elements not found in the initial shape,
		and truncates elements not in the new shape
B003 - extend duplicates data across a dimension (index) a number of times specified by input multiplier
B004 - extend with multiplier 0 returns constant 0, multiplier 1 returns input node
B005 - compress aggregates elements along a specific dimension
B006 - compress aggregates all elements if the dimension value is unspecified
(UNTESTED) B007 - reduce_X works exactly as advertised for specified and unspecified dimensions
B008 - arg_compress obtains of the index of an element found by some search parameter of specific dimension if dimension value > -1
		otherwise obtain the coordinate of the element
B009 - arg_compress will throw when dimension is greater than or equal to rank
B010 - arg_compress without a specified dimension returns the sequential (flattened) index of found element
(UNTESTED) B011 - arg_X works exactly as advertised for specified and unspecified dimensions
B012 - flip mirrors the values along the specified dimension, the shape is not changed
(UNTESTED) B013 - cross_corr performs cross correlation given a filter and 2 specified dimension
(UNTESTED) B014 - conv2d cross correlates input with a flipped filter, test with asymmetric filters

// MATMUL BEHAVIORS
C000 - matmul with nullptr arguments returns nullptr
C001 - matmul matrix multiplies the first 2 dimensions of tensors
		shapes must match by according to the following (<m, n, a, b, c, ...>, <k, m, a, b, c, ...>)
		where m is shape value of index 0, and 1 for first and second argument respectively (note: column is index 0)
		any shape value following the first two must be identical
		(probabilistically verified by Freivald's algorithm) (N-dimensional Matmul UNTESTED and UNIMPLEMENTED)
C002 - matrix multiplying incompatible shapes throws logic_error during evaluation
C003 - matmul(a, b) appends a jacobian operator to it's observers (and super-observers)
		the jacobian operator is defined as: a' * matmul(k, b^T) + b' * matmul(a^T, k) where k is the graph root
C004 - matrix of shapes with dimension value greater than Q (Q=100) is calculated by strassen
		matmul shape X, Y (X=?, Y=?) takes at most N seconds

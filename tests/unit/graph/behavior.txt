// REACTIVE BEHAVIOR
A000 - copying subjects do not copy over audiences
		moving subjects move over audiences and audiences have their dependencies reattached to new subject
		subjects without audience will return false if it has no observers
A001 - subjects notify all observers
		if UNSUBSCRIBE is called, then observer will suicide via death_on_broken
		if UPDATE is called, then observer will update via
		public update with subject being its input
A002 - destroying a subject will destroy their observers via UNSUBSCRIBE update,
		and via death_on_broken
A003 - attaching observer to subject at index means notifying the
		observer's protected update is triggered with calling subject and the index specified
		attaching does nothing to update observer's dependency (not tested)
A004 - detaching observer with index mean the above behavior will not hold for the specific index
		detaching observer without index will prevent above behavior from holding
		for any specific index to observer
		detaching does nothing to update observer's dependency (not tested)
A005 - constructing observer with dependencies should automatically attach
		constructed observer to designated subjects
A006 - copying/moving observers copy/move over dependencies
A007 - add_dependency with observer attaches observer to subject with index = dependencies_.size()
		additionally, push subject back to dependencies
A008 - remove_dependency with observer detaches observer from subject at specified index
		dependency at index is set to nullptr. trim all nullptrs from end of dependencies
		removing out of index throws exception
A009 - replace_dependency at index detaches the last subject at index, attaches new subject at index
A010 - destroying an observer will detach the observer from its subjects via a detach call

// NODE BEHAVIOR
B000 - on creation, a node is registered in the graph
		on deletion, a node is no longer in the graph
B001 - cloning inode creates another node of the same label, but different uid,
		moving prevents coping over uid
B002 - a uid is unique for every instance of node
B003 - label is a non-unique string assigned during construction,
		name is the concatenation of uid and label

// CONSTANT BEHAVIOR
C000 - scalar constructor initializes data as a scalar of the same value
		vector initializes tensor in vector form according to input data 
		with specified input shape. vector initialization clipped or repeated to fit shape
		multiple scalar constant containing the same value will use the same instance
C001 - clone and move are deleted, clone and move return nullptr
C002 - get_leaves adds returns a set containing itself
C003 - get tensors exposes to scalar/vector specified at construction
		exposing constant is the same as exposed tensor
C004 - derive returns nullptr
C005 - self destructs when it loses all its subscribers

// VARIABLE BEHAVIOR
D000 - tensor has no data on construction, but it has specified input shape
D001 - clone and move operates on member data source and data. copy and move are deep
		copy and move assign calls notify with UPDATE message
D002 - get_leaves adds returns a set containing itself
D003 - get_tensor returns owned tensor, before initialization, this tensor has no data
D004 - derive returns 1 scalar node if input leaf is this,
		otherwise return nullptr
D005 - initialization fails if the allowed shape is not defined 
		and data is not previously initialized
		variable initialization with shape fails if shape is not compatible
		with the allowed_shape if not previously initialized or the alloced_shape
D006 - assign deep copies input inode's tensor its own tensor 
		if input tensor is shape compatible with variable tensor
		notifies if notify parameter is true
		assigning variable to itself doesn't do anything and returns false

// PLACEHOLDER BEHAVIOR
E000 - tensor is has no data on construction, but it has specified input shape
E001 - clone and move operates on member data. data copy and move are deep
		copy and move assign calls notify with UPDATE message
E002 - get_leaves adds returns a set containing itself
E003 - get_tensor returns owned tensor, before assign, this tensor has no data
E004 - derive returns nullptr
E005 - assigning vector initializes tensor with input data vector.
		it guesses best fit shape for input data size if tensor has no data,
		failure to guess shape or if the tensor has data and 
		vector size will not fit allocated shape, throw logic error
		assignment notifies with UPDATE message
E006 - assigning tensor write input tensor content to owned tensor
		assignment fails if tensor is instance of owned tensor or input tensor
		is not shape compatible with owned tensor
		successful assignment notifies with UPDATE message

// FUNCTOR BEHAVIOR
F000 - copying functor deep copies over forward and backward functions, data source and tensor data
		copy and move assign calls notify with UPDATE message
F001 - get_name is the name of the node in <> braces followed by
		its dependencies' labels separated by commas in () brackets.
		example: <local_name>(dep1, dep2, dep3)
F002 - get_leaves is the super set of its argument get_leaves
F003 - get_tensor returns owned tensor, before update, get_data() returns nullptr
		gets tensor once all arguments have data
F004 - derive returns 1 scalar node if wrt is this,
		otherwise applies input derivative function

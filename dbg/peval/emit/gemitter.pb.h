// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dbg/peval/emit/gemitter.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_dbg_2fpeval_2femit_2fgemitter_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_dbg_2fpeval_2femit_2fgemitter_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "internal/onnx/onnx.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_dbg_2fpeval_2femit_2fgemitter_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_dbg_2fpeval_2femit_2fgemitter_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_dbg_2fpeval_2femit_2fgemitter_2eproto;
namespace gemitter {
class CreateModelRequest;
class CreateModelRequestDefaultTypeInternal;
extern CreateModelRequestDefaultTypeInternal _CreateModelRequest_default_instance_;
class CreateModelResponse;
class CreateModelResponseDefaultTypeInternal;
extern CreateModelResponseDefaultTypeInternal _CreateModelResponse_default_instance_;
class DeleteModelRequest;
class DeleteModelRequestDefaultTypeInternal;
extern DeleteModelRequestDefaultTypeInternal _DeleteModelRequest_default_instance_;
class DeleteModelResponse;
class DeleteModelResponseDefaultTypeInternal;
extern DeleteModelResponseDefaultTypeInternal _DeleteModelResponse_default_instance_;
class Empty;
class EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class ModelPayload;
class ModelPayloadDefaultTypeInternal;
extern ModelPayloadDefaultTypeInternal _ModelPayload_default_instance_;
class NodePayload;
class NodePayloadDefaultTypeInternal;
extern NodePayloadDefaultTypeInternal _NodePayload_default_instance_;
class UpdateNodeDataRequest;
class UpdateNodeDataRequestDefaultTypeInternal;
extern UpdateNodeDataRequestDefaultTypeInternal _UpdateNodeDataRequest_default_instance_;
class UpdateNodeDataResponse;
class UpdateNodeDataResponseDefaultTypeInternal;
extern UpdateNodeDataResponseDefaultTypeInternal _UpdateNodeDataResponse_default_instance_;
}  // namespace gemitter
PROTOBUF_NAMESPACE_OPEN
template<> ::gemitter::CreateModelRequest* Arena::CreateMaybeMessage<::gemitter::CreateModelRequest>(Arena*);
template<> ::gemitter::CreateModelResponse* Arena::CreateMaybeMessage<::gemitter::CreateModelResponse>(Arena*);
template<> ::gemitter::DeleteModelRequest* Arena::CreateMaybeMessage<::gemitter::DeleteModelRequest>(Arena*);
template<> ::gemitter::DeleteModelResponse* Arena::CreateMaybeMessage<::gemitter::DeleteModelResponse>(Arena*);
template<> ::gemitter::Empty* Arena::CreateMaybeMessage<::gemitter::Empty>(Arena*);
template<> ::gemitter::ModelPayload* Arena::CreateMaybeMessage<::gemitter::ModelPayload>(Arena*);
template<> ::gemitter::NodePayload* Arena::CreateMaybeMessage<::gemitter::NodePayload>(Arena*);
template<> ::gemitter::UpdateNodeDataRequest* Arena::CreateMaybeMessage<::gemitter::UpdateNodeDataRequest>(Arena*);
template<> ::gemitter::UpdateNodeDataResponse* Arena::CreateMaybeMessage<::gemitter::UpdateNodeDataResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace gemitter {

enum Status : int {
  OK = 0,
  BAD_INPUT = 1,
  INTERNAL_ERR = 2,
  UNKNOWN = 3,
  Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Status_IsValid(int value);
constexpr Status Status_MIN = OK;
constexpr Status Status_MAX = UNKNOWN;
constexpr int Status_ARRAYSIZE = Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Status_descriptor();
template<typename T>
inline const std::string& Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Status_descriptor(), enum_t_value);
}
inline bool Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Status>(
    Status_descriptor(), name, value);
}
// ===================================================================

class ModelPayload PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gemitter.ModelPayload) */ {
 public:
  inline ModelPayload() : ModelPayload(nullptr) {}
  virtual ~ModelPayload();

  ModelPayload(const ModelPayload& from);
  ModelPayload(ModelPayload&& from) noexcept
    : ModelPayload() {
    *this = ::std::move(from);
  }

  inline ModelPayload& operator=(const ModelPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelPayload& operator=(ModelPayload&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelPayload& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModelPayload* internal_default_instance() {
    return reinterpret_cast<const ModelPayload*>(
               &_ModelPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ModelPayload& a, ModelPayload& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelPayload* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelPayload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelPayload* New() const final {
    return CreateMaybeMessage<ModelPayload>(nullptr);
  }

  ModelPayload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelPayload>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelPayload& from);
  void MergeFrom(const ModelPayload& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelPayload* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gemitter.ModelPayload";
  }
  protected:
  explicit ModelPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_dbg_2fpeval_2femit_2fgemitter_2eproto);
    return ::descriptor_table_dbg_2fpeval_2femit_2fgemitter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelIdFieldNumber = 1,
    kModelFieldNumber = 2,
  };
  // string model_id = 1;
  void clear_model_id();
  const std::string& model_id() const;
  void set_model_id(const std::string& value);
  void set_model_id(std::string&& value);
  void set_model_id(const char* value);
  void set_model_id(const char* value, size_t size);
  std::string* mutable_model_id();
  std::string* release_model_id();
  void set_allocated_model_id(std::string* model_id);
  private:
  const std::string& _internal_model_id() const;
  void _internal_set_model_id(const std::string& value);
  std::string* _internal_mutable_model_id();
  public:

  // .onnx.ModelProto model = 2;
  bool has_model() const;
  private:
  bool _internal_has_model() const;
  public:
  void clear_model();
  const ::onnx::ModelProto& model() const;
  ::onnx::ModelProto* release_model();
  ::onnx::ModelProto* mutable_model();
  void set_allocated_model(::onnx::ModelProto* model);
  private:
  const ::onnx::ModelProto& _internal_model() const;
  ::onnx::ModelProto* _internal_mutable_model();
  public:
  void unsafe_arena_set_allocated_model(
      ::onnx::ModelProto* model);
  ::onnx::ModelProto* unsafe_arena_release_model();

  // @@protoc_insertion_point(class_scope:gemitter.ModelPayload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_id_;
  ::onnx::ModelProto* model_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dbg_2fpeval_2femit_2fgemitter_2eproto;
};
// -------------------------------------------------------------------

class NodePayload PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gemitter.NodePayload) */ {
 public:
  inline NodePayload() : NodePayload(nullptr) {}
  virtual ~NodePayload();

  NodePayload(const NodePayload& from);
  NodePayload(NodePayload&& from) noexcept
    : NodePayload() {
    *this = ::std::move(from);
  }

  inline NodePayload& operator=(const NodePayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodePayload& operator=(NodePayload&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodePayload& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodePayload* internal_default_instance() {
    return reinterpret_cast<const NodePayload*>(
               &_NodePayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(NodePayload& a, NodePayload& b) {
    a.Swap(&b);
  }
  inline void Swap(NodePayload* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodePayload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodePayload* New() const final {
    return CreateMaybeMessage<NodePayload>(nullptr);
  }

  NodePayload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodePayload>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodePayload& from);
  void MergeFrom(const NodePayload& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodePayload* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gemitter.NodePayload";
  }
  protected:
  explicit NodePayload(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_dbg_2fpeval_2femit_2fgemitter_2eproto);
    return ::descriptor_table_dbg_2fpeval_2femit_2fgemitter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kModelIdFieldNumber = 1,
    kNodeIdFieldNumber = 2,
  };
  // repeated float data = 3;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  float _internal_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_data() const;
  void _internal_add_data(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_data();
  public:
  float data(int index) const;
  void set_data(int index, float value);
  void add_data(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_data();

  // string model_id = 1;
  void clear_model_id();
  const std::string& model_id() const;
  void set_model_id(const std::string& value);
  void set_model_id(std::string&& value);
  void set_model_id(const char* value);
  void set_model_id(const char* value, size_t size);
  std::string* mutable_model_id();
  std::string* release_model_id();
  void set_allocated_model_id(std::string* model_id);
  private:
  const std::string& _internal_model_id() const;
  void _internal_set_model_id(const std::string& value);
  std::string* _internal_mutable_model_id();
  public:

  // string node_id = 2;
  void clear_node_id();
  const std::string& node_id() const;
  void set_node_id(const std::string& value);
  void set_node_id(std::string&& value);
  void set_node_id(const char* value);
  void set_node_id(const char* value, size_t size);
  std::string* mutable_node_id();
  std::string* release_node_id();
  void set_allocated_node_id(std::string* node_id);
  private:
  const std::string& _internal_node_id() const;
  void _internal_set_node_id(const std::string& value);
  std::string* _internal_mutable_node_id();
  public:

  // @@protoc_insertion_point(class_scope:gemitter.NodePayload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > data_;
  mutable std::atomic<int> _data_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dbg_2fpeval_2femit_2fgemitter_2eproto;
};
// -------------------------------------------------------------------

class Empty PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gemitter.Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}
  virtual ~Empty();

  Empty(const Empty& from);
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Empty& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }
  inline void Swap(Empty* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Empty* New() const final {
    return CreateMaybeMessage<Empty>(nullptr);
  }

  Empty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Empty& from);
  void MergeFrom(const Empty& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Empty* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gemitter.Empty";
  }
  protected:
  explicit Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_dbg_2fpeval_2femit_2fgemitter_2eproto);
    return ::descriptor_table_dbg_2fpeval_2femit_2fgemitter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:gemitter.Empty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dbg_2fpeval_2femit_2fgemitter_2eproto;
};
// -------------------------------------------------------------------

class CreateModelRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gemitter.CreateModelRequest) */ {
 public:
  inline CreateModelRequest() : CreateModelRequest(nullptr) {}
  virtual ~CreateModelRequest();

  CreateModelRequest(const CreateModelRequest& from);
  CreateModelRequest(CreateModelRequest&& from) noexcept
    : CreateModelRequest() {
    *this = ::std::move(from);
  }

  inline CreateModelRequest& operator=(const CreateModelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateModelRequest& operator=(CreateModelRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateModelRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateModelRequest* internal_default_instance() {
    return reinterpret_cast<const CreateModelRequest*>(
               &_CreateModelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CreateModelRequest& a, CreateModelRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateModelRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateModelRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateModelRequest* New() const final {
    return CreateMaybeMessage<CreateModelRequest>(nullptr);
  }

  CreateModelRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateModelRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateModelRequest& from);
  void MergeFrom(const CreateModelRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateModelRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gemitter.CreateModelRequest";
  }
  protected:
  explicit CreateModelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_dbg_2fpeval_2femit_2fgemitter_2eproto);
    return ::descriptor_table_dbg_2fpeval_2femit_2fgemitter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 1,
  };
  // .gemitter.ModelPayload payload = 1;
  bool has_payload() const;
  private:
  bool _internal_has_payload() const;
  public:
  void clear_payload();
  const ::gemitter::ModelPayload& payload() const;
  ::gemitter::ModelPayload* release_payload();
  ::gemitter::ModelPayload* mutable_payload();
  void set_allocated_payload(::gemitter::ModelPayload* payload);
  private:
  const ::gemitter::ModelPayload& _internal_payload() const;
  ::gemitter::ModelPayload* _internal_mutable_payload();
  public:
  void unsafe_arena_set_allocated_payload(
      ::gemitter::ModelPayload* payload);
  ::gemitter::ModelPayload* unsafe_arena_release_payload();

  // @@protoc_insertion_point(class_scope:gemitter.CreateModelRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::gemitter::ModelPayload* payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dbg_2fpeval_2femit_2fgemitter_2eproto;
};
// -------------------------------------------------------------------

class CreateModelResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gemitter.CreateModelResponse) */ {
 public:
  inline CreateModelResponse() : CreateModelResponse(nullptr) {}
  virtual ~CreateModelResponse();

  CreateModelResponse(const CreateModelResponse& from);
  CreateModelResponse(CreateModelResponse&& from) noexcept
    : CreateModelResponse() {
    *this = ::std::move(from);
  }

  inline CreateModelResponse& operator=(const CreateModelResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateModelResponse& operator=(CreateModelResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateModelResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateModelResponse* internal_default_instance() {
    return reinterpret_cast<const CreateModelResponse*>(
               &_CreateModelResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CreateModelResponse& a, CreateModelResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateModelResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateModelResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateModelResponse* New() const final {
    return CreateMaybeMessage<CreateModelResponse>(nullptr);
  }

  CreateModelResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateModelResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateModelResponse& from);
  void MergeFrom(const CreateModelResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateModelResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gemitter.CreateModelResponse";
  }
  protected:
  explicit CreateModelResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_dbg_2fpeval_2femit_2fgemitter_2eproto);
    return ::descriptor_table_dbg_2fpeval_2femit_2fgemitter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .gemitter.Status status = 1;
  void clear_status();
  ::gemitter::Status status() const;
  void set_status(::gemitter::Status value);
  private:
  ::gemitter::Status _internal_status() const;
  void _internal_set_status(::gemitter::Status value);
  public:

  // @@protoc_insertion_point(class_scope:gemitter.CreateModelResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dbg_2fpeval_2femit_2fgemitter_2eproto;
};
// -------------------------------------------------------------------

class UpdateNodeDataRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gemitter.UpdateNodeDataRequest) */ {
 public:
  inline UpdateNodeDataRequest() : UpdateNodeDataRequest(nullptr) {}
  virtual ~UpdateNodeDataRequest();

  UpdateNodeDataRequest(const UpdateNodeDataRequest& from);
  UpdateNodeDataRequest(UpdateNodeDataRequest&& from) noexcept
    : UpdateNodeDataRequest() {
    *this = ::std::move(from);
  }

  inline UpdateNodeDataRequest& operator=(const UpdateNodeDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateNodeDataRequest& operator=(UpdateNodeDataRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdateNodeDataRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateNodeDataRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateNodeDataRequest*>(
               &_UpdateNodeDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UpdateNodeDataRequest& a, UpdateNodeDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateNodeDataRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateNodeDataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateNodeDataRequest* New() const final {
    return CreateMaybeMessage<UpdateNodeDataRequest>(nullptr);
  }

  UpdateNodeDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateNodeDataRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdateNodeDataRequest& from);
  void MergeFrom(const UpdateNodeDataRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateNodeDataRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gemitter.UpdateNodeDataRequest";
  }
  protected:
  explicit UpdateNodeDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_dbg_2fpeval_2femit_2fgemitter_2eproto);
    return ::descriptor_table_dbg_2fpeval_2femit_2fgemitter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 1,
  };
  // .gemitter.NodePayload payload = 1;
  bool has_payload() const;
  private:
  bool _internal_has_payload() const;
  public:
  void clear_payload();
  const ::gemitter::NodePayload& payload() const;
  ::gemitter::NodePayload* release_payload();
  ::gemitter::NodePayload* mutable_payload();
  void set_allocated_payload(::gemitter::NodePayload* payload);
  private:
  const ::gemitter::NodePayload& _internal_payload() const;
  ::gemitter::NodePayload* _internal_mutable_payload();
  public:
  void unsafe_arena_set_allocated_payload(
      ::gemitter::NodePayload* payload);
  ::gemitter::NodePayload* unsafe_arena_release_payload();

  // @@protoc_insertion_point(class_scope:gemitter.UpdateNodeDataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::gemitter::NodePayload* payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dbg_2fpeval_2femit_2fgemitter_2eproto;
};
// -------------------------------------------------------------------

class UpdateNodeDataResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gemitter.UpdateNodeDataResponse) */ {
 public:
  inline UpdateNodeDataResponse() : UpdateNodeDataResponse(nullptr) {}
  virtual ~UpdateNodeDataResponse();

  UpdateNodeDataResponse(const UpdateNodeDataResponse& from);
  UpdateNodeDataResponse(UpdateNodeDataResponse&& from) noexcept
    : UpdateNodeDataResponse() {
    *this = ::std::move(from);
  }

  inline UpdateNodeDataResponse& operator=(const UpdateNodeDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateNodeDataResponse& operator=(UpdateNodeDataResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdateNodeDataResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateNodeDataResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateNodeDataResponse*>(
               &_UpdateNodeDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UpdateNodeDataResponse& a, UpdateNodeDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateNodeDataResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateNodeDataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateNodeDataResponse* New() const final {
    return CreateMaybeMessage<UpdateNodeDataResponse>(nullptr);
  }

  UpdateNodeDataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateNodeDataResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdateNodeDataResponse& from);
  void MergeFrom(const UpdateNodeDataResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateNodeDataResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gemitter.UpdateNodeDataResponse";
  }
  protected:
  explicit UpdateNodeDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_dbg_2fpeval_2femit_2fgemitter_2eproto);
    return ::descriptor_table_dbg_2fpeval_2femit_2fgemitter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .gemitter.Status status = 1;
  void clear_status();
  ::gemitter::Status status() const;
  void set_status(::gemitter::Status value);
  private:
  ::gemitter::Status _internal_status() const;
  void _internal_set_status(::gemitter::Status value);
  public:

  // @@protoc_insertion_point(class_scope:gemitter.UpdateNodeDataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dbg_2fpeval_2femit_2fgemitter_2eproto;
};
// -------------------------------------------------------------------

class DeleteModelRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gemitter.DeleteModelRequest) */ {
 public:
  inline DeleteModelRequest() : DeleteModelRequest(nullptr) {}
  virtual ~DeleteModelRequest();

  DeleteModelRequest(const DeleteModelRequest& from);
  DeleteModelRequest(DeleteModelRequest&& from) noexcept
    : DeleteModelRequest() {
    *this = ::std::move(from);
  }

  inline DeleteModelRequest& operator=(const DeleteModelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteModelRequest& operator=(DeleteModelRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeleteModelRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteModelRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteModelRequest*>(
               &_DeleteModelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DeleteModelRequest& a, DeleteModelRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteModelRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteModelRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteModelRequest* New() const final {
    return CreateMaybeMessage<DeleteModelRequest>(nullptr);
  }

  DeleteModelRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteModelRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeleteModelRequest& from);
  void MergeFrom(const DeleteModelRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteModelRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gemitter.DeleteModelRequest";
  }
  protected:
  explicit DeleteModelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_dbg_2fpeval_2femit_2fgemitter_2eproto);
    return ::descriptor_table_dbg_2fpeval_2femit_2fgemitter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelIdFieldNumber = 1,
  };
  // string model_id = 1;
  void clear_model_id();
  const std::string& model_id() const;
  void set_model_id(const std::string& value);
  void set_model_id(std::string&& value);
  void set_model_id(const char* value);
  void set_model_id(const char* value, size_t size);
  std::string* mutable_model_id();
  std::string* release_model_id();
  void set_allocated_model_id(std::string* model_id);
  private:
  const std::string& _internal_model_id() const;
  void _internal_set_model_id(const std::string& value);
  std::string* _internal_mutable_model_id();
  public:

  // @@protoc_insertion_point(class_scope:gemitter.DeleteModelRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dbg_2fpeval_2femit_2fgemitter_2eproto;
};
// -------------------------------------------------------------------

class DeleteModelResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gemitter.DeleteModelResponse) */ {
 public:
  inline DeleteModelResponse() : DeleteModelResponse(nullptr) {}
  virtual ~DeleteModelResponse();

  DeleteModelResponse(const DeleteModelResponse& from);
  DeleteModelResponse(DeleteModelResponse&& from) noexcept
    : DeleteModelResponse() {
    *this = ::std::move(from);
  }

  inline DeleteModelResponse& operator=(const DeleteModelResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteModelResponse& operator=(DeleteModelResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeleteModelResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteModelResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteModelResponse*>(
               &_DeleteModelResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DeleteModelResponse& a, DeleteModelResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteModelResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteModelResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteModelResponse* New() const final {
    return CreateMaybeMessage<DeleteModelResponse>(nullptr);
  }

  DeleteModelResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteModelResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeleteModelResponse& from);
  void MergeFrom(const DeleteModelResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteModelResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gemitter.DeleteModelResponse";
  }
  protected:
  explicit DeleteModelResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_dbg_2fpeval_2femit_2fgemitter_2eproto);
    return ::descriptor_table_dbg_2fpeval_2femit_2fgemitter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .gemitter.Status status = 1;
  void clear_status();
  ::gemitter::Status status() const;
  void set_status(::gemitter::Status value);
  private:
  ::gemitter::Status _internal_status() const;
  void _internal_set_status(::gemitter::Status value);
  public:

  // @@protoc_insertion_point(class_scope:gemitter.DeleteModelResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dbg_2fpeval_2femit_2fgemitter_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ModelPayload

// string model_id = 1;
inline void ModelPayload::clear_model_id() {
  model_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ModelPayload::model_id() const {
  // @@protoc_insertion_point(field_get:gemitter.ModelPayload.model_id)
  return _internal_model_id();
}
inline void ModelPayload::set_model_id(const std::string& value) {
  _internal_set_model_id(value);
  // @@protoc_insertion_point(field_set:gemitter.ModelPayload.model_id)
}
inline std::string* ModelPayload::mutable_model_id() {
  // @@protoc_insertion_point(field_mutable:gemitter.ModelPayload.model_id)
  return _internal_mutable_model_id();
}
inline const std::string& ModelPayload::_internal_model_id() const {
  return model_id_.Get();
}
inline void ModelPayload::_internal_set_model_id(const std::string& value) {
  
  model_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ModelPayload::set_model_id(std::string&& value) {
  
  model_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:gemitter.ModelPayload.model_id)
}
inline void ModelPayload::set_model_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  model_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:gemitter.ModelPayload.model_id)
}
inline void ModelPayload::set_model_id(const char* value,
    size_t size) {
  
  model_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:gemitter.ModelPayload.model_id)
}
inline std::string* ModelPayload::_internal_mutable_model_id() {
  
  return model_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ModelPayload::release_model_id() {
  // @@protoc_insertion_point(field_release:gemitter.ModelPayload.model_id)
  return model_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ModelPayload::set_allocated_model_id(std::string* model_id) {
  if (model_id != nullptr) {
    
  } else {
    
  }
  model_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:gemitter.ModelPayload.model_id)
}

// .onnx.ModelProto model = 2;
inline bool ModelPayload::_internal_has_model() const {
  return this != internal_default_instance() && model_ != nullptr;
}
inline bool ModelPayload::has_model() const {
  return _internal_has_model();
}
inline const ::onnx::ModelProto& ModelPayload::_internal_model() const {
  const ::onnx::ModelProto* p = model_;
  return p != nullptr ? *p : *reinterpret_cast<const ::onnx::ModelProto*>(
      &::onnx::_ModelProto_default_instance_);
}
inline const ::onnx::ModelProto& ModelPayload::model() const {
  // @@protoc_insertion_point(field_get:gemitter.ModelPayload.model)
  return _internal_model();
}
inline void ModelPayload::unsafe_arena_set_allocated_model(
    ::onnx::ModelProto* model) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(model_);
  }
  model_ = model;
  if (model) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gemitter.ModelPayload.model)
}
inline ::onnx::ModelProto* ModelPayload::release_model() {
  
  ::onnx::ModelProto* temp = model_;
  model_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::onnx::ModelProto* ModelPayload::unsafe_arena_release_model() {
  // @@protoc_insertion_point(field_release:gemitter.ModelPayload.model)
  
  ::onnx::ModelProto* temp = model_;
  model_ = nullptr;
  return temp;
}
inline ::onnx::ModelProto* ModelPayload::_internal_mutable_model() {
  
  if (model_ == nullptr) {
    auto* p = CreateMaybeMessage<::onnx::ModelProto>(GetArena());
    model_ = p;
  }
  return model_;
}
inline ::onnx::ModelProto* ModelPayload::mutable_model() {
  // @@protoc_insertion_point(field_mutable:gemitter.ModelPayload.model)
  return _internal_mutable_model();
}
inline void ModelPayload::set_allocated_model(::onnx::ModelProto* model) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(model_);
  }
  if (model) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(model)->GetArena();
    if (message_arena != submessage_arena) {
      model = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model, submessage_arena);
    }
    
  } else {
    
  }
  model_ = model;
  // @@protoc_insertion_point(field_set_allocated:gemitter.ModelPayload.model)
}

// -------------------------------------------------------------------

// NodePayload

// string model_id = 1;
inline void NodePayload::clear_model_id() {
  model_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& NodePayload::model_id() const {
  // @@protoc_insertion_point(field_get:gemitter.NodePayload.model_id)
  return _internal_model_id();
}
inline void NodePayload::set_model_id(const std::string& value) {
  _internal_set_model_id(value);
  // @@protoc_insertion_point(field_set:gemitter.NodePayload.model_id)
}
inline std::string* NodePayload::mutable_model_id() {
  // @@protoc_insertion_point(field_mutable:gemitter.NodePayload.model_id)
  return _internal_mutable_model_id();
}
inline const std::string& NodePayload::_internal_model_id() const {
  return model_id_.Get();
}
inline void NodePayload::_internal_set_model_id(const std::string& value) {
  
  model_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NodePayload::set_model_id(std::string&& value) {
  
  model_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:gemitter.NodePayload.model_id)
}
inline void NodePayload::set_model_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  model_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:gemitter.NodePayload.model_id)
}
inline void NodePayload::set_model_id(const char* value,
    size_t size) {
  
  model_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:gemitter.NodePayload.model_id)
}
inline std::string* NodePayload::_internal_mutable_model_id() {
  
  return model_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NodePayload::release_model_id() {
  // @@protoc_insertion_point(field_release:gemitter.NodePayload.model_id)
  return model_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodePayload::set_allocated_model_id(std::string* model_id) {
  if (model_id != nullptr) {
    
  } else {
    
  }
  model_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:gemitter.NodePayload.model_id)
}

// string node_id = 2;
inline void NodePayload::clear_node_id() {
  node_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& NodePayload::node_id() const {
  // @@protoc_insertion_point(field_get:gemitter.NodePayload.node_id)
  return _internal_node_id();
}
inline void NodePayload::set_node_id(const std::string& value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:gemitter.NodePayload.node_id)
}
inline std::string* NodePayload::mutable_node_id() {
  // @@protoc_insertion_point(field_mutable:gemitter.NodePayload.node_id)
  return _internal_mutable_node_id();
}
inline const std::string& NodePayload::_internal_node_id() const {
  return node_id_.Get();
}
inline void NodePayload::_internal_set_node_id(const std::string& value) {
  
  node_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NodePayload::set_node_id(std::string&& value) {
  
  node_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:gemitter.NodePayload.node_id)
}
inline void NodePayload::set_node_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  node_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:gemitter.NodePayload.node_id)
}
inline void NodePayload::set_node_id(const char* value,
    size_t size) {
  
  node_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:gemitter.NodePayload.node_id)
}
inline std::string* NodePayload::_internal_mutable_node_id() {
  
  return node_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NodePayload::release_node_id() {
  // @@protoc_insertion_point(field_release:gemitter.NodePayload.node_id)
  return node_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodePayload::set_allocated_node_id(std::string* node_id) {
  if (node_id != nullptr) {
    
  } else {
    
  }
  node_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:gemitter.NodePayload.node_id)
}

// repeated float data = 3;
inline int NodePayload::_internal_data_size() const {
  return data_.size();
}
inline int NodePayload::data_size() const {
  return _internal_data_size();
}
inline void NodePayload::clear_data() {
  data_.Clear();
}
inline float NodePayload::_internal_data(int index) const {
  return data_.Get(index);
}
inline float NodePayload::data(int index) const {
  // @@protoc_insertion_point(field_get:gemitter.NodePayload.data)
  return _internal_data(index);
}
inline void NodePayload::set_data(int index, float value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:gemitter.NodePayload.data)
}
inline void NodePayload::_internal_add_data(float value) {
  data_.Add(value);
}
inline void NodePayload::add_data(float value) {
  _internal_add_data(value);
  // @@protoc_insertion_point(field_add:gemitter.NodePayload.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
NodePayload::_internal_data() const {
  return data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
NodePayload::data() const {
  // @@protoc_insertion_point(field_list:gemitter.NodePayload.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
NodePayload::_internal_mutable_data() {
  return &data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
NodePayload::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:gemitter.NodePayload.data)
  return _internal_mutable_data();
}

// -------------------------------------------------------------------

// Empty

// -------------------------------------------------------------------

// CreateModelRequest

// .gemitter.ModelPayload payload = 1;
inline bool CreateModelRequest::_internal_has_payload() const {
  return this != internal_default_instance() && payload_ != nullptr;
}
inline bool CreateModelRequest::has_payload() const {
  return _internal_has_payload();
}
inline void CreateModelRequest::clear_payload() {
  if (GetArena() == nullptr && payload_ != nullptr) {
    delete payload_;
  }
  payload_ = nullptr;
}
inline const ::gemitter::ModelPayload& CreateModelRequest::_internal_payload() const {
  const ::gemitter::ModelPayload* p = payload_;
  return p != nullptr ? *p : *reinterpret_cast<const ::gemitter::ModelPayload*>(
      &::gemitter::_ModelPayload_default_instance_);
}
inline const ::gemitter::ModelPayload& CreateModelRequest::payload() const {
  // @@protoc_insertion_point(field_get:gemitter.CreateModelRequest.payload)
  return _internal_payload();
}
inline void CreateModelRequest::unsafe_arena_set_allocated_payload(
    ::gemitter::ModelPayload* payload) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payload_);
  }
  payload_ = payload;
  if (payload) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gemitter.CreateModelRequest.payload)
}
inline ::gemitter::ModelPayload* CreateModelRequest::release_payload() {
  
  ::gemitter::ModelPayload* temp = payload_;
  payload_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::gemitter::ModelPayload* CreateModelRequest::unsafe_arena_release_payload() {
  // @@protoc_insertion_point(field_release:gemitter.CreateModelRequest.payload)
  
  ::gemitter::ModelPayload* temp = payload_;
  payload_ = nullptr;
  return temp;
}
inline ::gemitter::ModelPayload* CreateModelRequest::_internal_mutable_payload() {
  
  if (payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::gemitter::ModelPayload>(GetArena());
    payload_ = p;
  }
  return payload_;
}
inline ::gemitter::ModelPayload* CreateModelRequest::mutable_payload() {
  // @@protoc_insertion_point(field_mutable:gemitter.CreateModelRequest.payload)
  return _internal_mutable_payload();
}
inline void CreateModelRequest::set_allocated_payload(::gemitter::ModelPayload* payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete payload_;
  }
  if (payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(payload);
    if (message_arena != submessage_arena) {
      payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload, submessage_arena);
    }
    
  } else {
    
  }
  payload_ = payload;
  // @@protoc_insertion_point(field_set_allocated:gemitter.CreateModelRequest.payload)
}

// -------------------------------------------------------------------

// CreateModelResponse

// .gemitter.Status status = 1;
inline void CreateModelResponse::clear_status() {
  status_ = 0;
}
inline ::gemitter::Status CreateModelResponse::_internal_status() const {
  return static_cast< ::gemitter::Status >(status_);
}
inline ::gemitter::Status CreateModelResponse::status() const {
  // @@protoc_insertion_point(field_get:gemitter.CreateModelResponse.status)
  return _internal_status();
}
inline void CreateModelResponse::_internal_set_status(::gemitter::Status value) {
  
  status_ = value;
}
inline void CreateModelResponse::set_status(::gemitter::Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:gemitter.CreateModelResponse.status)
}

// string message = 2;
inline void CreateModelResponse::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& CreateModelResponse::message() const {
  // @@protoc_insertion_point(field_get:gemitter.CreateModelResponse.message)
  return _internal_message();
}
inline void CreateModelResponse::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:gemitter.CreateModelResponse.message)
}
inline std::string* CreateModelResponse::mutable_message() {
  // @@protoc_insertion_point(field_mutable:gemitter.CreateModelResponse.message)
  return _internal_mutable_message();
}
inline const std::string& CreateModelResponse::_internal_message() const {
  return message_.Get();
}
inline void CreateModelResponse::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CreateModelResponse::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:gemitter.CreateModelResponse.message)
}
inline void CreateModelResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:gemitter.CreateModelResponse.message)
}
inline void CreateModelResponse::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:gemitter.CreateModelResponse.message)
}
inline std::string* CreateModelResponse::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CreateModelResponse::release_message() {
  // @@protoc_insertion_point(field_release:gemitter.CreateModelResponse.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CreateModelResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:gemitter.CreateModelResponse.message)
}

// -------------------------------------------------------------------

// UpdateNodeDataRequest

// .gemitter.NodePayload payload = 1;
inline bool UpdateNodeDataRequest::_internal_has_payload() const {
  return this != internal_default_instance() && payload_ != nullptr;
}
inline bool UpdateNodeDataRequest::has_payload() const {
  return _internal_has_payload();
}
inline void UpdateNodeDataRequest::clear_payload() {
  if (GetArena() == nullptr && payload_ != nullptr) {
    delete payload_;
  }
  payload_ = nullptr;
}
inline const ::gemitter::NodePayload& UpdateNodeDataRequest::_internal_payload() const {
  const ::gemitter::NodePayload* p = payload_;
  return p != nullptr ? *p : *reinterpret_cast<const ::gemitter::NodePayload*>(
      &::gemitter::_NodePayload_default_instance_);
}
inline const ::gemitter::NodePayload& UpdateNodeDataRequest::payload() const {
  // @@protoc_insertion_point(field_get:gemitter.UpdateNodeDataRequest.payload)
  return _internal_payload();
}
inline void UpdateNodeDataRequest::unsafe_arena_set_allocated_payload(
    ::gemitter::NodePayload* payload) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payload_);
  }
  payload_ = payload;
  if (payload) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gemitter.UpdateNodeDataRequest.payload)
}
inline ::gemitter::NodePayload* UpdateNodeDataRequest::release_payload() {
  
  ::gemitter::NodePayload* temp = payload_;
  payload_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::gemitter::NodePayload* UpdateNodeDataRequest::unsafe_arena_release_payload() {
  // @@protoc_insertion_point(field_release:gemitter.UpdateNodeDataRequest.payload)
  
  ::gemitter::NodePayload* temp = payload_;
  payload_ = nullptr;
  return temp;
}
inline ::gemitter::NodePayload* UpdateNodeDataRequest::_internal_mutable_payload() {
  
  if (payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::gemitter::NodePayload>(GetArena());
    payload_ = p;
  }
  return payload_;
}
inline ::gemitter::NodePayload* UpdateNodeDataRequest::mutable_payload() {
  // @@protoc_insertion_point(field_mutable:gemitter.UpdateNodeDataRequest.payload)
  return _internal_mutable_payload();
}
inline void UpdateNodeDataRequest::set_allocated_payload(::gemitter::NodePayload* payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete payload_;
  }
  if (payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(payload);
    if (message_arena != submessage_arena) {
      payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload, submessage_arena);
    }
    
  } else {
    
  }
  payload_ = payload;
  // @@protoc_insertion_point(field_set_allocated:gemitter.UpdateNodeDataRequest.payload)
}

// -------------------------------------------------------------------

// UpdateNodeDataResponse

// .gemitter.Status status = 1;
inline void UpdateNodeDataResponse::clear_status() {
  status_ = 0;
}
inline ::gemitter::Status UpdateNodeDataResponse::_internal_status() const {
  return static_cast< ::gemitter::Status >(status_);
}
inline ::gemitter::Status UpdateNodeDataResponse::status() const {
  // @@protoc_insertion_point(field_get:gemitter.UpdateNodeDataResponse.status)
  return _internal_status();
}
inline void UpdateNodeDataResponse::_internal_set_status(::gemitter::Status value) {
  
  status_ = value;
}
inline void UpdateNodeDataResponse::set_status(::gemitter::Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:gemitter.UpdateNodeDataResponse.status)
}

// string message = 2;
inline void UpdateNodeDataResponse::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& UpdateNodeDataResponse::message() const {
  // @@protoc_insertion_point(field_get:gemitter.UpdateNodeDataResponse.message)
  return _internal_message();
}
inline void UpdateNodeDataResponse::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:gemitter.UpdateNodeDataResponse.message)
}
inline std::string* UpdateNodeDataResponse::mutable_message() {
  // @@protoc_insertion_point(field_mutable:gemitter.UpdateNodeDataResponse.message)
  return _internal_mutable_message();
}
inline const std::string& UpdateNodeDataResponse::_internal_message() const {
  return message_.Get();
}
inline void UpdateNodeDataResponse::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UpdateNodeDataResponse::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:gemitter.UpdateNodeDataResponse.message)
}
inline void UpdateNodeDataResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:gemitter.UpdateNodeDataResponse.message)
}
inline void UpdateNodeDataResponse::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:gemitter.UpdateNodeDataResponse.message)
}
inline std::string* UpdateNodeDataResponse::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UpdateNodeDataResponse::release_message() {
  // @@protoc_insertion_point(field_release:gemitter.UpdateNodeDataResponse.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UpdateNodeDataResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:gemitter.UpdateNodeDataResponse.message)
}

// -------------------------------------------------------------------

// DeleteModelRequest

// string model_id = 1;
inline void DeleteModelRequest::clear_model_id() {
  model_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& DeleteModelRequest::model_id() const {
  // @@protoc_insertion_point(field_get:gemitter.DeleteModelRequest.model_id)
  return _internal_model_id();
}
inline void DeleteModelRequest::set_model_id(const std::string& value) {
  _internal_set_model_id(value);
  // @@protoc_insertion_point(field_set:gemitter.DeleteModelRequest.model_id)
}
inline std::string* DeleteModelRequest::mutable_model_id() {
  // @@protoc_insertion_point(field_mutable:gemitter.DeleteModelRequest.model_id)
  return _internal_mutable_model_id();
}
inline const std::string& DeleteModelRequest::_internal_model_id() const {
  return model_id_.Get();
}
inline void DeleteModelRequest::_internal_set_model_id(const std::string& value) {
  
  model_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DeleteModelRequest::set_model_id(std::string&& value) {
  
  model_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:gemitter.DeleteModelRequest.model_id)
}
inline void DeleteModelRequest::set_model_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  model_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:gemitter.DeleteModelRequest.model_id)
}
inline void DeleteModelRequest::set_model_id(const char* value,
    size_t size) {
  
  model_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:gemitter.DeleteModelRequest.model_id)
}
inline std::string* DeleteModelRequest::_internal_mutable_model_id() {
  
  return model_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DeleteModelRequest::release_model_id() {
  // @@protoc_insertion_point(field_release:gemitter.DeleteModelRequest.model_id)
  return model_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DeleteModelRequest::set_allocated_model_id(std::string* model_id) {
  if (model_id != nullptr) {
    
  } else {
    
  }
  model_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:gemitter.DeleteModelRequest.model_id)
}

// -------------------------------------------------------------------

// DeleteModelResponse

// .gemitter.Status status = 1;
inline void DeleteModelResponse::clear_status() {
  status_ = 0;
}
inline ::gemitter::Status DeleteModelResponse::_internal_status() const {
  return static_cast< ::gemitter::Status >(status_);
}
inline ::gemitter::Status DeleteModelResponse::status() const {
  // @@protoc_insertion_point(field_get:gemitter.DeleteModelResponse.status)
  return _internal_status();
}
inline void DeleteModelResponse::_internal_set_status(::gemitter::Status value) {
  
  status_ = value;
}
inline void DeleteModelResponse::set_status(::gemitter::Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:gemitter.DeleteModelResponse.status)
}

// string message = 2;
inline void DeleteModelResponse::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& DeleteModelResponse::message() const {
  // @@protoc_insertion_point(field_get:gemitter.DeleteModelResponse.message)
  return _internal_message();
}
inline void DeleteModelResponse::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:gemitter.DeleteModelResponse.message)
}
inline std::string* DeleteModelResponse::mutable_message() {
  // @@protoc_insertion_point(field_mutable:gemitter.DeleteModelResponse.message)
  return _internal_mutable_message();
}
inline const std::string& DeleteModelResponse::_internal_message() const {
  return message_.Get();
}
inline void DeleteModelResponse::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DeleteModelResponse::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:gemitter.DeleteModelResponse.message)
}
inline void DeleteModelResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:gemitter.DeleteModelResponse.message)
}
inline void DeleteModelResponse::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:gemitter.DeleteModelResponse.message)
}
inline std::string* DeleteModelResponse::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DeleteModelResponse::release_message() {
  // @@protoc_insertion_point(field_release:gemitter.DeleteModelResponse.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DeleteModelResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:gemitter.DeleteModelResponse.message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace gemitter

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::gemitter::Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gemitter::Status>() {
  return ::gemitter::Status_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_dbg_2fpeval_2femit_2fgemitter_2eproto

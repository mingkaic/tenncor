opcode:
  operator_path: eigen/operator.hpp
  params: eigen::EigenptrT<T>& out, const eigen::EigenEdgesT<T>& in, const marsh::Maps& attrs
  opcalls:
    ABS: out = eigen::abs(in[0].get());
    NEG: out = eigen::neg(in[0].get());
    SIN: out = eigen::sin(in[0].get());
    COS: out = eigen::cos(in[0].get());
    TAN: out = eigen::tan(in[0].get());
    EXP: out = eigen::exp(in[0].get());
    LOG: out = eigen::log(in[0].get());
    SQRT: out = eigen::sqrt(in[0].get());
    ROUND: out = eigen::round(in[0].get());
    SIGMOID: out = eigen::sigmoid(in[0].get());
    TANH: out = eigen::tanh(in[0].get());
    SQUARE: out = eigen::square(in[0].get());
    CUBE: out = eigen::cube(in[0].get());
    POW: out = eigen::pow(in[0].get(),in[1].get());
    ADD: out = eigen::add(in[0].get(),in[1].get());
    SUB: out = eigen::sub(in[0].get(),in[1].get());
    MUL: out = eigen::mul(in[0].get(),in[1].get());
    DIV: out = eigen::div(in[0].get(),in[1].get());
    MIN: out = eigen::min(in[0].get(),in[1].get());
    MAX: out = eigen::max(in[0].get(),in[1].get());
    EQ: out = eigen::eq(in[0].get(),in[1].get());
    NEQ: out = eigen::neq(in[0].get(),in[1].get());
    LT: out = eigen::lt(in[0].get(),in[1].get());
    GT: out = eigen::gt(in[0].get(),in[1].get());
    RAND_UNIF: out = eigen::rand_uniform(in[0].get(),in[1].get());
    REVERSE: out = eigen::reverse(in[0].get(),attrs);
    REDUCE_SUM: out = eigen::reduce_sum(in[0].get(),attrs);
    REDUCE_PROD: out = eigen::reduce_prod(in[0].get(),attrs);
    REDUCE_MIN: out = eigen::reduce_min(in[0].get(),attrs);
    REDUCE_MAX: out = eigen::reduce_max(in[0].get(),attrs);
    ARGMAX: out = eigen::argmax(in[0].get(),attrs);
    PERMUTE: out = eigen::permute(in[0].get(),attrs);
    EXTEND: out = eigen::extend(in[0].get(),attrs);
    RESHAPE: out = eigen::reshape(in[0].get());
    MATMUL: out = eigen::matmul(in[0].get(),in[1].get(),attrs);
    CONV: out = eigen::convolution(in[0].get(),in[1].get(),attrs);
    SLICE: out = eigen::slice(in[0].get(),attrs);
    PAD: out = eigen::pad(in[0].get(),attrs);
    STRIDE: out = eigen::stride(in[0].get(),attrs);
    SCATTER: out = eigen::scatter(in[0].get(),attrs);
    SELECT: out = eigen::select(in[0].get(),in[1].get(),in[2].get());
    CONCAT: out = eigen::concat(in[0].get(),in[1].get(),attrs);
    GROUP_CONCAT: out = eigen::group_concat(in,attrs);
    GROUP_SUM: out = eigen::group_sum(in);
    GROUP_PROD: out = eigen::group_prod(in);

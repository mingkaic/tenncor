opcode:
  includes:
    - internal/eigen/operator.hpp
    - internal/eigen/packattr.hpp
  params: eigen::EigenptrT& out, teq::Shape outshape, const teq::TensptrsT& in, const marsh::iAttributed& attrib
  per_op:
    - template: typename T
      name: FuncOpt
      args:
        - type: const marsh::Maps&
          name: attrs
        - type: const teq::TensptrsT&
          name: args
      out:
        type: bool
        val: return false;
    - name: ShapeParser
      args:
        - type: const marsh::Maps&
          name: attrs
        - type: const teq::ShapesT&
          name: shapes
      out:
        type: teq::Shape
        val: |
            //
                    if (shapes.empty())
                    {
                        global::fatal(eigen::no_argument_err);
                    }
                    teq::Shape outshape = shapes.front();
                    for (size_t i = 1, n = shapes.size(); i < n; ++i)
                    {
                        if (false == shapes[i].compatible_after(outshape, 0))
                        {
                            global::throw_errf("cannot %s with incompatible shapes %s and %s",
                                egen::name_op(OPCODE).c_str(),
                                shapes[i].to_string().c_str(),
                                outshape.to_string().c_str());
                        }
                    }
                    return outshape;
    - name: TypeParser
      args:
        - type: const marsh::Maps&
          name: attrs
        - type: const eigen::DTypesT&
          name: dtypes
      out:
        type: egen::_GENERATED_DTYPE
        val: |
            //
                    if (dtypes.empty())
                    {
                        global::fatal(eigen::no_argument_err);
                    }
                    return *std::max_element(dtypes.begin(), dtypes.end(),
                    [](egen::_GENERATED_DTYPE lhs, egen::_GENERATED_DTYPE rhs)
                    {
                        return egen::type_precision(lhs) < egen::type_precision(rhs);
                    });
  opcalls:
    IDENTITY:
      stmt: out = eigen::ref<T>(outshape, *in[0]);
      ShapeParser:
        out:
          val: |
              //
                      if (shapes.empty())
                      {
                          global::fatal(eigen::no_argument_err);
                      }
                      return shapes.front();
    ABS:
      stmt: out = eigen::abs<T>(outshape, *in[0]);
    NEG:
      stmt: out = eigen::neg<T>(outshape, *in[0]);
    SIN:
      stmt: out = eigen::sin<T>(outshape, *in[0]);
    COS:
      stmt: out = eigen::cos<T>(outshape, *in[0]);
    TAN:
      stmt: out = eigen::tan<T>(outshape, *in[0]);
    EXP:
      stmt: out = eigen::exp<T>(outshape, *in[0]);
    LOG:
      stmt: out = eigen::log<T>(outshape, *in[0]);
    SQRT:
      stmt: out = eigen::sqrt<T>(outshape, *in[0]);
    ROUND:
      stmt: out = eigen::round<T>(outshape, *in[0]);
    SIGMOID:
      stmt: out = eigen::sigmoid<T>(outshape, *in[0]);
    TANH:
      stmt: out = eigen::tanh<T>(outshape, *in[0]);
    SQUARE:
      stmt: out = eigen::square<T>(outshape, *in[0]);
    CUBE:
      stmt: out = eigen::cube<T>(outshape, *in[0]);
    RAND_UNIF:
      stmt: out = eigen::rand_uniform<T>(outshape, *in[0], *in[1]);
      idempotent: False
    REVERSE:
      stmt: out = eigen::reverse<T>(outshape, *in[0], attrib);
    REDUCE_SUM:
      stmt: out = eigen::reduce_sum<T>(outshape, *in[0], attrib);
      FuncOpt:
        out:
          val: |
              //
                  std::set<teq::RankT> ranks;
                  eigen::Packer<std::set<teq::RankT>>().unpack(ranks, attrs);
                  bool redundant = ranks.empty();
                  if (redundant)
                  {
                      global::debugf("reducing with no significant dimensions... "
                          "treating as identity: (dims=%s, shape=%s)",
                          fmts::to_string(ranks.begin(), ranks.end()).c_str(),
                          args.front()->shape().to_string().c_str());
                  }
                  return redundant;
      ShapeParser:
        out:
          val: |
              //
                      if (shapes.empty())
                      {
                          global::fatal(eigen::no_argument_err);
                      }
                      std::set<teq::RankT> ranks;
                      eigen::Packer<std::set<teq::RankT>>().unpack(ranks, attrs);
                      teq::Shape shape = shapes.front();
                      std::vector<teq::DimT> slist(shape.begin(), shape.end());
                      for (teq::RankT i : ranks)
                      {
                          slist[i] = 1;
                      }
                      return teq::Shape(slist);
    REDUCE_PROD:
      stmt: out = eigen::reduce_prod<T>(outshape, *in[0], attrib);
      FuncOpt: REDUCE_SUM
      ShapeParser: REDUCE_SUM
    REDUCE_MIN:
      stmt: out = eigen::reduce_min<T>(outshape, *in[0], attrib);
      FuncOpt: REDUCE_SUM
      ShapeParser: REDUCE_SUM
    REDUCE_MAX:
      stmt: out = eigen::reduce_max<T>(outshape, *in[0], attrib);
      FuncOpt: REDUCE_SUM
      ShapeParser: REDUCE_SUM
    ARGMAX:
      stmt: out = eigen::argmax<T>(outshape, *in[0], attrib);
      FuncOpt:
        out:
          val: |
              //
                      teq::RankT return_dim;
                      eigen::Packer<teq::RankT>().unpack(return_dim, attrs);
                      teq::Shape shape = args.front()->shape();
                      bool redundant = return_dim < teq::rank_cap && shape.at(return_dim) == 1;
                      if (redundant)
                      {
                          global::debugf("argreducing with no significant dimensions... "
                              "treating as identity: (return_dim=%d, shape=%s)",
                              (int) return_dim, shape.to_string().c_str());
                      }
                      return redundant;
      ShapeParser:
        out:
          val: |
              //
                      if (shapes.empty())
                      {
                          global::fatal(eigen::no_argument_err);
                      }
                      teq::RankT return_dim;
                      eigen::Packer<teq::RankT>().unpack(return_dim, attrs);
                      if (return_dim >= teq::rank_cap)
                      {
                          return teq::Shape();
                      }
                      teq::Shape shape = shapes.front();
                      std::vector<teq::DimT> slist(shape.begin(), shape.end());
                      slist[return_dim] = 1;
                      return teq::Shape(slist);
    PERMUTE:
      stmt: out = eigen::permute<T>(outshape, *in[0], attrib);
      FuncOpt:
        out:
          val: |
              //
                      std::vector<teq::RankT> order;
                      eigen::Packer<std::vector<teq::RankT>>().unpack(order, attrs);
                      bool redundant = order.empty() ? true : (order[0] == 0);
                      for (size_t i = 1, n = std::min(order.size(), (size_t) teq::rank_cap);
                          i < n && redundant; ++i)
                      {
                          redundant = redundant && (order[i] == (order[i-1] + 1));
                      }
                      if (redundant)
                      {
                          global::debug("permuting with same "
                              "dimensions ... treating as identity");
                      }
                      return redundant;
      ShapeParser:
        out:
          val: |
              //
                      std::vector<teq::RankT> order;
                      eigen::Packer<std::vector<teq::RankT>>().unpack(order, attrs);
                      bool visited[teq::rank_cap];
                      std::fill(visited, visited + teq::rank_cap, false);
                      for (teq::RankT i = 0, n = std::min(order.size(),
                          (size_t) teq::rank_cap); i < n; ++i)
                      {
                          if (visited[order[i]])
                          {
                              global::throw_errf("permute does not support repeated orders "
                                  "(order=%s)", fmts::to_string(order.begin(), order.end()).c_str());
                          }
                          visited[order[i]] = true;
                      }
                      for (teq::RankT i = 0; i < teq::rank_cap; ++i)
                      {
                          if (false == visited[i])
                          {
                              order.push_back(i);
                          }
                      }
                      teq::Shape shape = shapes.front();
                      std::vector<teq::DimT> slist(teq::rank_cap, 1);
                      for (teq::RankT i = 0; i < teq::rank_cap; ++i)
                      {
                          slist[i] = shape.at(order[i]);
                      }
                      return teq::Shape(slist);
    EXTEND:
      stmt: out = eigen::extend<T>(outshape, *in[0], attrib);
      FuncOpt:
        out:
          val: |
              //
                      auto bcast = eigen::unpack_extend(args.front()->shape(), attrs);
                      bool uses_dims = nullptr != attrs.get_attr(
                          eigen::Packer<std::vector<teq::DimT>>().get_key());
                      bool redundant = false == bool(bcast) || (uses_dims &&
                          (bcast->empty() || std::all_of(bcast->begin(), bcast->end(),
                          [](teq::DimT d) { return 1 == d; })));
                      if (redundant)
                      {
                          global::debug("extending with nothing... treating as identity");
                      }
                      return redundant;
      ShapeParser:
        out:
          val: |
              //
                      teq::Shape shape = shapes.front();
                      teq::DimsT bcast;
                      if (auto bopt = eigen::unpack_extend(shape, attrs))
                      {
                          bcast = *bopt;
                      }
                      if (std::any_of(bcast.begin(), bcast.end(),
                          [](teq::DimT d) { return 0 == d; }))
                      {
                          global::throw_errf("cannot extend using zero dimensions %s",
                              fmts::to_string(bcast.begin(), bcast.end()).c_str());
                      }
                      std::vector<teq::DimT> slist(shape.begin(), shape.end());
                      for (size_t i = 0, nbcasts = bcast.size(); i < nbcasts; ++i)
                      {
                          if (bcast.at(i) > 1 && shape.at(i) > 1)
                          {
                              global::throw_errf("cannot extend non-singular dimension %d of "
                                  "shape %s: bcast=%s", i, shape.to_string().c_str(),
                                  fmts::to_string(bcast.begin(), bcast.end()).c_str());
                          }
                          slist[i] *= bcast[i];
                      }
                      return teq::Shape(slist);
    RESHAPE:
      stmt: out = eigen::reshape<T>(outshape, *in[0]);
      FuncOpt:
        out:
          val: |
              //
                      teq::Shape outshape;
                      eigen::Packer<teq::Shape>().unpack(outshape, attrs);
                      bool redundant = outshape.compatible_after(args.front()->shape(), 0);
                      if (redundant)
                      {
                          global::debugf("outshape of reshape is the same shape as inshape "
                              "%s... treating as identity", outshape.to_string().c_str());
                      }
                      return redundant;
      ShapeParser:
        out:
          val: |
              //
                      if (shapes.empty())
                      {
                          global::fatal(eigen::no_argument_err);
                      }
                      teq::Shape outshape;
                      eigen::Packer<teq::Shape>().unpack(outshape, attrs);
                      if (shapes.front().n_elems() != outshape.n_elems())
                      {
                          global::throw_errf("cannot RESHAPE with shapes of different sizes "
                              "%d (shape %s) and %d (shape %s)",
                              shapes.front().n_elems(),
                              shapes.front().to_string().c_str(),
                              outshape.n_elems(),
                              outshape.to_string().c_str());
                      }
                      return outshape;
    SLICE:
      stmt: out = eigen::slice<T>(outshape, *in[0], attrib);
      FuncOpt:
        out:
          val: |
              //
                      eigen::PairVecT<teq::DimT> extents;
                      eigen::Packer<eigen::PairVecT<teq::DimT>>().unpack(extents, attrs);
                      teq::Shape shape = args.front()->shape();
                      bool redundant = true;
                      for (size_t i = 0, n = std::min(extents.size(),
                          (size_t) teq::rank_cap); i < n && redundant; ++i)
                      {
                          auto& exts = extents[i];
                          if (exts.second == 0)
                          {
                              global::fatalf("cannot create slice with 0 dimension at "
                                  "index %d (extents=%s)", i,
                                  eigen::to_string(extents).c_str());
                          }
                          redundant = redundant && exts.first == 0 &&
                              exts.second > shape.at(i);
                      }
                      if (redundant)
                      {
                          global::debugf("slice parameter covers whole tensor... "
                              "treating as identity: (extents=%s)",
                              eigen::to_string(extents).c_str());
                      }
                      return redundant;
      ShapeParser:
        out:
          val: |
              //
                      if (shapes.empty())
                      {
                          global::fatal(eigen::no_argument_err);
                      }
                      eigen::PairVecT<teq::DimT> extents;
                      eigen::Packer<eigen::PairVecT<teq::DimT>>().unpack(extents, attrs);
                      teq::Shape shape = shapes.front();
                      std::vector<teq::DimT> slist(shape.begin(), shape.end());
                      for (size_t i = 0, n = std::min(extents.size(),
                          (size_t) teq::rank_cap); i < n; ++i)
                      {
                          teq::DimT offsets = extents[i].first;
                          if (offsets < shape.at(i))
                          {
                              slist[i] = std::min(extents[i].second, (teq::DimT) (shape.at(i) - offsets));
                          }
                      }
                      return teq::Shape(slist);
    PAD:
      stmt: out = eigen::pad<T>(outshape, *in[0], attrib);
      FuncOpt:
        out:
          val: |
              //
                      eigen::PairVecT<teq::DimT> paddings;
                      eigen::Packer<eigen::PairVecT<teq::DimT>>().unpack(paddings, attrs);
                      bool redundant = std::all_of(paddings.begin(), paddings.end(),
                      [](std::pair<teq::DimT,teq::DimT> pad)
                      {
                          return pad.first == 0 && pad.second == 0;
                      });
                      if (redundant)
                      {
                          global::debugf("padding are all zero... "
                              "treating as identity: (paddings=%s)",
                              eigen::to_string(paddings).c_str());
                      }
                      return redundant;
      ShapeParser:
        out:
          val: |
              //
                      if (shapes.empty())
                      {
                          global::fatal(eigen::no_argument_err);
                      }
                      eigen::PairVecT<teq::DimT> paddings;
                      eigen::Packer<eigen::PairVecT<teq::DimT>>().unpack(paddings, attrs);
                      teq::Shape shape = shapes.front();
                      std::vector<teq::DimT> slist(shape.begin(), shape.end());
                      for (size_t i = 0, n = std::min(paddings.size(),
                          (size_t) teq::rank_cap); i < n; ++i)
                      {
                          if (slist[i] > 0)
                          {
                              slist[i] += paddings[i].first + paddings[i].second;
                          }
                      }
                      return teq::Shape(slist);
    STRIDE:
      stmt: out = eigen::stride<T>(outshape, *in[0], attrib);
      ShapeParser:
        out:
          val: |
              //
                      if (shapes.empty())
                      {
                          global::fatal(eigen::no_argument_err);
                      }
                      std::vector<teq::DimT> incrs;
                      eigen::Packer<std::vector<teq::DimT>>().unpack(incrs, attrs);

                      teq::Shape shape = shapes.front();
                      std::vector<double> coords(teq::rank_cap, 1);
                      size_t n = std::min(incrs.size(), (size_t) teq::rank_cap);
                      for (size_t i = 0; i < n; ++i)
                      {
                          coords[i] = incrs[i];
                      }
                      std::vector<teq::DimT> slist(shape.begin(), shape.end());
                      for (size_t i = 0; i < n; ++i)
                      {
                          slist[i] = std::round((double) slist[i] / incrs[i]);
                      }
                      return teq::Shape(slist);
    SCATTER:
      stmt: out = eigen::scatter<T>(outshape, *in[0], attrib);
      FuncOpt:
        out:
          val: |
              //
                      teq::Shape outshape;
                      eigen::Packer<teq::Shape>().unpack(outshape, attrs);
                      bool redundant = args.front()->shape().compatible_after(outshape, 0);
                      if (redundant)
                      {
                          global::debugf("scattering produces the same shape %s",
                              outshape.to_string().c_str());
                      }
                      return redundant;
      ShapeParser:
        out:
          val: |
              //
                      if (shapes.empty())
                      {
                          global::fatal(eigen::no_argument_err);
                      }
                      teq::Shape outshape;
                      eigen::Packer<teq::Shape>().unpack(outshape, attrs);
                      return outshape;
    POW:
      stmt: out = eigen::pow<T>(outshape, *in[0], *in[1]);
    ADD:
      stmt: out = eigen::add<T>(outshape, in);
      FuncOpt:
        out:
          val: |
              //
                      bool redundant = args.size() < 2;
                      if (redundant)
                      {
                          // assuming empty args is handled before
                          global::debug("redundantly performing nnary op on a single arg... "
                              "treating as identity");
                      }
                      return redundant;
      commutative: True
    SUB:
      stmt: out = eigen::sub<T>(outshape, *in[0], *in[1]);
    MUL:
      stmt: out = eigen::mul<T>(outshape, in);
      FuncOpt: ADD
      commutative: True
    DIV:
      stmt: out = eigen::div<T>(outshape, *in[0], *in[1]);
    MIN:
      stmt: out = eigen::min<T>(outshape, *in[0], *in[1]);
      commutative: True
    MAX:
      stmt: out = eigen::max<T>(outshape, *in[0], *in[1]);
      commutative: True
    EQ:
      stmt: out = eigen::eq<T>(outshape, *in[0], *in[1]);
      commutative: True
    NEQ:
      stmt: out = eigen::neq<T>(outshape, *in[0], *in[1]);
      commutative: True
    LT:
      stmt: out = eigen::lt<T>(outshape, *in[0], *in[1]);
    GT:
      stmt: out = eigen::gt<T>(outshape, *in[0], *in[1]);
    MATMUL:
      stmt: out = eigen::matmul<T>(outshape, *in[0], *in[1], attrib);
      ShapeParser:
        out:
          val: |
              //
                      eigen::PairVecT<teq::RankT> ranks;
                      eigen::Packer<eigen::PairVecT<teq::RankT>>().unpack(ranks, attrs);

                      // check common dimensions
                      std::array<bool,teq::rank_cap> avisit;
                      std::array<bool,teq::rank_cap> bvisit;
                      std::fill(avisit.begin(), avisit.end(), false);
                      std::fill(bvisit.begin(), bvisit.end(), false);
                      teq::Shape ashape = shapes[0];
                      teq::Shape bshape = shapes[1];
                      for (const std::pair<teq::RankT,teq::RankT>& coms : ranks)
                      {
                          if (ashape.at(coms.first) != bshape.at(coms.second))
                          {
                              global::throw_errf("invalid shapes %s and %s do not match "
                                  "common dimensions %s", ashape.to_string().c_str(),
                                  bshape.to_string().c_str(),
                                  eigen::to_string(ranks).c_str());
                          }
                          if (avisit[coms.first] || bvisit[coms.second])
                          {
                              global::throw_errf("contraction dimensions %s must be unique for "
                                  "each side", eigen::to_string(ranks).c_str());
                          }
                          avisit[coms.first] = bvisit[coms.second] = true;
                      }
                      std::vector<teq::DimT> alist = teq::narrow_shape(ashape);
                      std::vector<teq::DimT> blist = teq::narrow_shape(bshape);
                      std::vector<teq::DimT> outlist;
                      outlist.reserve(2 * ranks.size());
                      for (teq::RankT i = 0, n = blist.size(); i < n; ++i)
                      {
                          if (false == bvisit[i])
                          {
                              outlist.push_back(blist.at(i));
                          }
                      }
                      for (teq::RankT i = 0, n = alist.size(); i < n; ++i)
                      {
                          if (false == avisit[i])
                          {
                              outlist.push_back(alist.at(i));
                          }
                      }
                      return teq::Shape(outlist);
    CONV:
      stmt: out = eigen::convolution<T>(outshape, *in[0], *in[1], attrib);
      ShapeParser:
        out:
          val: |
              //
                      std::vector<teq::RankT> ranks;
                      eigen::Packer<std::vector<teq::RankT>>().unpack(ranks, attrs);

                      size_t n = std::min(ranks.size(), (size_t) teq::rank_cap);
                      teq::Shape kernelshape = shapes[1];
                      if (std::any_of(kernelshape.begin() + n, kernelshape.end(),
                          [](teq::DimT d) { return d > 1; }))
                      {
                          global::throw_errf("cannot have ambiguous ranks not specified in "
                              "kernelshape %s (ranks=%s)", kernelshape.to_string().c_str(),
                              fmts::to_string(ranks.begin(), ranks.end()).c_str());
                      }
                      teq::Shape imgshape = shapes[0];
                      std::vector<teq::DimT> slist(imgshape.begin(), imgshape.end());
                      for (size_t i = 0; i < n; ++i)
                      {
                          teq::DimT& sdim = slist[ranks[i]];
                          teq::DimT kdim = kernelshape.at(i);
                          // treat as ambiguous if either dimension is ambiguous
                          if (0 == sdim || 0 == kdim)
                          {
                              sdim = 0;
                          }
                          else
                          {
                              if (kdim > sdim)
                              {
                                  global::throw_errf("cannot convolve a kernel of shape %s against "
                                      "smaller image of shape %s",
                                      kernelshape.to_string().c_str(),
                                      imgshape.to_string().c_str());
                              }
                              sdim -= kdim - 1;
                          }
                      }
                      return teq::Shape(slist);
    SELECT:
      stmt: out = eigen::select<T>(outshape, *in[0], *in[1], *in[2]);
    CONCAT:
      stmt: out = eigen::concat<T>(outshape, in, attrib);
      FuncOpt:
        out:
          val: |
              //
                      bool redundant = args.size() == 1;
                      if (redundant)
                      {
                          global::debug("concatenating a single node... treating as identity");
                      }
                      return redundant;
      ShapeParser:
        out:
          val: |
              //
                      teq::RankT axis;
                      eigen::Packer<teq::RankT>().unpack(axis, attrs);
                      if (shapes.size() > 2)
                      {
                          if (std::any_of(shapes.begin(), shapes.end(),
                              [axis](teq::Shape shape)
                              { return shape.at(axis) != 1; }))
                          {
                              global::throw_err("cannot group concat shapes "
                                  "with dimension that is not one");
                          }
                          teq::Shape initshape = shapes.front();
                          std::vector<teq::DimT> slist(initshape.begin(), initshape.end());
                          slist[axis] = shapes.size();
                          return teq::Shape(slist);
                      }
                      teq::Shape leftshape = shapes[0];
                      teq::Shape rightshape = shapes[1];
                      std::vector<teq::DimT> slist(leftshape.begin(), leftshape.end());
                      if (slist[axis] == 0 || rightshape.at(axis) == 0)
                      {
                          slist[axis] = 0;
                      }
                      else
                      {
                          slist[axis] += rightshape.at(axis);
                      }
                      return teq::Shape(slist);
    ASSIGN:
      stmt: out = eigen::assign<T>(*in[0], *in[1]);
      TypeParser:
        out:
          val: |
              //
                      if (dtypes.empty())
                      {
                          global::fatal(eigen::no_argument_err);
                      }
                      return dtypes.front();
    ASSIGN_ADD:
      stmt: out = eigen::assign_add<T>(*in[0], *in[1]);
      TypeParser: ASSIGN
      idempotent: False
    ASSIGN_SUB:
      stmt: out = eigen::assign_sub<T>(*in[0], *in[1]);
      TypeParser: ASSIGN
      idempotent: False
    ASSIGN_MUL:
      stmt: out = eigen::assign_mul<T>(*in[0], *in[1]);
      TypeParser: ASSIGN
      idempotent: False
    ASSIGN_DIV:
      stmt: out = eigen::assign_div<T>(*in[0], *in[1]);
      TypeParser: ASSIGN
      idempotent: False
    CAST:
      stmt: out = eigen::cast<T>(*in[0]);
      FuncOpt:
        out:
          val: |
              //
                    auto argtype = (egen::_GENERATED_DTYPE)
                        args.front()->get_meta().type_code();
                    bool redundant = argtype == egen::get_type<T>();
                    if (redundant)
                    {
                        global::debugf("redundantly casting to same type %s",
                            egen::name_type(argtype).c_str());
                    }
                    return redundant;
      TypeParser:
        out:
          val: |
              //
                      if (dtypes.empty())
                      {
                          global::fatal(eigen::no_argument_err);
                      }
                      if (attrs.get_attr(eigen::Packer<egen::_GENERATED_DTYPE>::key_))
                      {
                          egen::_GENERATED_DTYPE out;
                          eigen::Packer<egen::_GENERATED_DTYPE>().unpack(out, attrs);
                          return out;
                      }
                      return dtypes.front();
      idempotent: False

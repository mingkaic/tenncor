api:
  pybind_type: float
  includes:
  - '"eteq/constant.hpp"'
  - '"eteq/variable.hpp"'
  - '"eteq/functor.hpp"'
  - '"tag/group.hpp"'
  - '"tag/prop.hpp"'
  namespaces:
    tenncor:
      - template: typename T
        name: abs
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::ABS, {arg});
      - template: typename T
        name: neg
        operator: "-"
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::NEG, {arg});
      - template: typename T
        name: sin
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::SIN, {arg});
      - template: typename T
        name: cos
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::COS, {arg});
      - template: typename T
        name: tan
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::TAN, {arg});
      - template: typename T
        name: exp
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::EXP, {arg});
      - template: typename T
        name: log
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::LOG, {arg});
      - template: typename T
        name: sqrt
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::SQRT, {arg});
      - template: typename T
        name: round
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::ROUND, {arg});
      - template: typename T
        name: sigmoid
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::SIGMOID, {arg});
      - template: typename T
        name: tanh
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::TANH, {arg});
      - template: typename T
        name: square
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::SQUARE, {arg});
      - template: typename T
        name: cube
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::CUBE, {arg});
      - template: typename T
        name: pow
        args:
        - dtype: eteq::NodeptrT<T>
          name: a
        - dtype: eteq::NodeptrT<T>
          name: b
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::POW, {a, b});
      - template: typename T
        name: pow
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::pow(arg1, eteq::make_constant_scalar<T>(scalar,arg1->shape()));
      - template: typename T
        name: pow
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::NodeptrT<T>
          name: arg1
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::pow(eteq::make_constant_scalar<T>(scalar,arg1->shape()),arg1);
      - template: typename T
        name: add
        operator: +
        args:
        - dtype: eteq::NodeptrT<T>
          name: a
        - dtype: eteq::NodeptrT<T>
          name: b
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto out = eteq::make_functor<T>(::egen::ADD, {a, b});
                  tag::get_property_reg().property_tag(out->get_tensor(), tag::commutative_tag);
                  tag::get_group_reg().group_tag(out->get_tensor(), "sum");
                  return out;
      - template: typename T
        name: add
        operator: +
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::add(arg1,eteq::make_constant_scalar<T>(scalar,arg1->shape()));
      - template: typename T
        name: add
        operator: +
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::NodeptrT<T>
          name: arg1
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::add(eteq::make_constant_scalar<T>(scalar,arg1->shape()),arg1);
      - template: typename T
        name: sub
        operator: "-"
        args:
        - dtype: eteq::NodeptrT<T>
          name: a
        - dtype: eteq::NodeptrT<T>
          name: b
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::SUB, {a, b});
      - template: typename T
        name: sub
        operator: "-"
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::sub(arg1,eteq::make_constant_scalar<T>(scalar,arg1->shape()));
      - template: typename T
        name: sub
        operator: "-"
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::NodeptrT<T>
          name: arg1
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::sub(eteq::make_constant_scalar<T>(scalar,arg1->shape()),arg1);
      - template: typename T
        name: mul
        operator: "*"
        args:
        - dtype: eteq::NodeptrT<T>
          name: a
        - dtype: eteq::NodeptrT<T>
          name: b
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto out = eteq::make_functor<T>(::egen::MUL, {a, b});
                  tag::get_property_reg().property_tag(out->get_tensor(), tag::commutative_tag);
                  tag::get_group_reg().group_tag(out->get_tensor(), "prod");
                  return out;
      - template: typename T
        name: mul
        operator: "*"
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::mul(arg1,eteq::make_constant_scalar<T>(scalar,arg1->shape()));
      - template: typename T
        name: mul
        operator: "*"
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::NodeptrT<T>
          name: arg1
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::mul(eteq::make_constant_scalar<T>(scalar,arg1->shape()),arg1);
      - template: typename T
        name: div
        operator: /
        args:
        - dtype: eteq::NodeptrT<T>
          name: a
        - dtype: eteq::NodeptrT<T>
          name: b
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::DIV, {a, b});
      - template: typename T
        name: div
        operator: /
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::div(arg1,eteq::make_constant_scalar<T>(scalar,arg1->shape()));
      - template: typename T
        name: div
        operator: /
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::NodeptrT<T>
          name: arg1
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::div(eteq::make_constant_scalar<T>(scalar,arg1->shape()),arg1);
      - template: typename T
        name: eq
        operator: ==
        args:
        - dtype: eteq::NodeptrT<T>
          name: a
        - dtype: eteq::NodeptrT<T>
          name: b
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto out = eteq::make_functor<T>(::egen::EQ, {a, b});
                  tag::get_property_reg().property_tag(out->get_tensor(), tag::commutative_tag);
                  return out;
      - template: typename T
        name: eq
        operator: ==
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::eq(arg1,eteq::make_constant_scalar<T>(scalar,arg1->shape()));
      - template: typename T
        name: eq
        operator: ==
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::NodeptrT<T>
          name: arg1
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::eq(eteq::make_constant_scalar<T>(scalar,arg1->shape()),arg1);
      - template: typename T
        name: neq
        operator: "!="
        args:
        - dtype: eteq::NodeptrT<T>
          name: a
        - dtype: eteq::NodeptrT<T>
          name: b
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto out = eteq::make_functor<T>(::egen::NEQ, {a, b});
                  tag::get_property_reg().property_tag(out->get_tensor(), tag::commutative_tag);
                  return out;
      - template: typename T
        name: neq
        operator: "!="
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::neq(arg1,eteq::make_constant_scalar<T>(scalar,arg1->shape()));
      - template: typename T
        name: neq
        operator: "!="
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::NodeptrT<T>
          name: arg1
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::neq(eteq::make_constant_scalar<T>(scalar,arg1->shape()),arg1);
      - template: typename T
        name: lt
        operator: <
        args:
        - dtype: eteq::NodeptrT<T>
          name: a
        - dtype: eteq::NodeptrT<T>
          name: b
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::LT, {a, b});
      - template: typename T
        name: lt
        operator: <
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::lt(arg1,eteq::make_constant_scalar<T>(scalar,arg1->shape()));
      - template: typename T
        name: lt
        operator: <
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::NodeptrT<T>
          name: arg1
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::lt(eteq::make_constant_scalar<T>(scalar,arg1->shape()),arg1);
      - template: typename T
        name: gt
        operator: ">"
        args:
        - dtype: eteq::NodeptrT<T>
          name: a
        - dtype: eteq::NodeptrT<T>
          name: b
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::GT, {a, b});
      - template: typename T
        name: gt
        operator: ">"
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::gt(arg1,eteq::make_constant_scalar<T>(scalar,arg1->shape()));
      - template: typename T
        name: gt
        operator: ">"
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::NodeptrT<T>
          name: arg1
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::gt(eteq::make_constant_scalar<T>(scalar,arg1->shape()),arg1);
      - template: typename T
        name: min
        args:
        - dtype: eteq::NodeptrT<T>
          name: a
        - dtype: eteq::NodeptrT<T>
          name: b
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto out = eteq::make_functor<T>(::egen::MIN, {a, b});
                  // todo: tag min with a group?
                  tag::get_property_reg().property_tag(out->get_tensor(), tag::commutative_tag);
                  return out;
      - template: typename T
        name: min
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::min(arg1,eteq::make_constant_scalar<T>(scalar,arg1->shape()));
      - template: typename T
        name: min
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::NodeptrT<T>
          name: arg1
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::min(eteq::make_constant_scalar<T>(scalar,arg1->shape()),arg1);
      - template: typename T
        name: min
        args:
        - dtype: eteq::NodesT<T>
          name: args
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  if (args.empty())
                  {
                      logs::fatal("cannot min without arguments");
                  }
                  eteq::NodeptrT<T> out = args[0];
                  for (size_t i = 1, n = args.size(); i < n; ++i)
                  {
                      out = ::tenncor::min(out, args[i]);
                  }
                  return out;
      - template: typename T
        name: max
        args:
        - dtype: eteq::NodeptrT<T>
          name: a
        - dtype: eteq::NodeptrT<T>
          name: b
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto out = eteq::make_functor<T>(::egen::MAX, {a, b});
                  // todo: tag max with a group?
                  tag::get_property_reg().property_tag(out->get_tensor(), tag::commutative_tag);
                  return out;
      - template: typename T
        name: max
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::max(arg1,eteq::make_constant_scalar<T>(scalar,arg1->shape()));
      - template: typename T
        name: max
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::NodeptrT<T>
          name: arg1
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::max(eteq::make_constant_scalar<T>(scalar,arg1->shape()),arg1);
      - template: typename T
        name: max
        args:
        - dtype: eteq::NodesT<T>
          name: args
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  if (args.empty())
                  {
                      logs::fatal("cannot max without arguments");
                  }
                  eteq::NodeptrT<T> out = args[0];
                  for (size_t i = 1, n = args.size(); i < n; ++i)
                  {
                      out = ::tenncor::max(out, args[i]);
                  }
                  return out;
      - template: typename T
        name: if_then_else
        args:
        - dtype: eteq::NodeptrT<T>
          name: condition
        - dtype: eteq::NodeptrT<T>
          name: then
        - dtype: eteq::NodeptrT<T>
          name: otherwise
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  if (then == otherwise)
                  {
                      return then;
                  }
                  return eteq::make_functor<T>(::egen::SELECT, {condition,then,otherwise});
      - template: typename T
        name: reverse
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: const std::vector<teq::RankT>&
          name: dims
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::REVERSE,{arg},dims);
      - template: typename T
        name: permute
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: const std::vector<teq::RankT>&
          name: order
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::PERMUTE,{arg},order);
      - template: typename T
        name: extend
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: const std::vector<teq::DimT>&
          name: bcast
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::EXTEND,{arg},bcast);
      - template: typename T
        name: extend
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::RankT
          name: offset
        - dtype: const std::vector<teq::DimT>&
          name: xlist
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::EXTEND,{arg},offset,xlist);
      - template: typename T
        name: concat
        args:
        - dtype: eteq::NodeptrT<T>
          name: left
        - dtype: eteq::NodeptrT<T>
          name: right
        - dtype: teq::RankT
          name: axis
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::CONCAT,{left,right},axis);
      - template: typename T
        name: concat
        args:
        - dtype: eteq::NodesT<T>
          name: args
        - dtype: teq::RankT
          name: axis
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::GROUP_CONCAT,args,axis);
      - description: Return extended arg so that output shape matches slist exactly
        template: typename T
        name: best_extend
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: const std::vector<teq::DimT>&
          name: slist
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  teq::RankT n = std::min(teq::rank_cap, (teq::RankT) slist.size());
                  teq::Shape source = arg->shape();
                  teq::RankT offset = 0;
                  while (offset < n && source.at(offset) == slist.at(offset)) {
                      ++offset;
                  }
                  if (offset == n) {
                      return arg;
                  }
                  std::vector<teq::DimT> exts;
                  exts.reserve(n - offset);
                  for (teq::RankT i = offset; i < n; ++i) {
                      teq::DimT sdim = source.at(i);
                      teq::DimT tdim = slist.at(i);
                      if (sdim != tdim) {
                          if (sdim != 1) {
                              logs::fatalf(
                                  "cannot extend shapes %s and %s at dimension %d to match",
                                  source.to_string().c_str(),
                                  fmts::to_string(slist.begin(), slist.end()).c_str(), i);
                          }
                          exts.push_back(tdim);
                      } else {
                          exts.push_back(1);
                      }
                  }
                  return ::tenncor::extend(arg, offset, exts);
      - description: Return extended arg so that output shape matches shape exactly
        template: typename T
        name: best_extend
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: const teq::Shape&
          name: shape
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::best_extend(arg, std::vector<teq::DimT>(shape.begin(), shape.end()));
      - template: typename T
        name: reshape
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::Shape
          name: shape
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::RESHAPE,{arg},shape);
      - description: sum values for dimensions specified
        template: typename T
        name: reduce_sum
        args:
        - dtype: eteq::NodeptrT<T>
          name: tens
        - dtype: std::set<teq::RankT>
          name: dims
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::REDUCE_SUM,{tens},dims);
      - description: multiply values for dimensions specified
        template: typename T
        name: reduce_prod
        args:
        - dtype: eteq::NodeptrT<T>
          name: tens
        - dtype: std::set<teq::RankT>
          name: dims
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::REDUCE_PROD,{tens},dims);
      - description: get min values of dimensions specified
        template: typename T
        name: reduce_min
        args:
        - dtype: eteq::NodeptrT<T>
          name: tens
        - dtype: std::set<teq::RankT>
          name: dims
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::REDUCE_MIN,{tens},dims);
      - description: get max values for dimensions specified
        template: typename T
        name: reduce_max
        args:
        - dtype: eteq::NodeptrT<T>
          name: tens
        - dtype: std::set<teq::RankT>
          name: dims
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::REDUCE_MAX,{tens},dims);
      - description: sum values for ndims dimensions after offset
        template: typename T
        name: reduce_sum
        args:
        - dtype: eteq::NodeptrT<T>
          name: tens
        - dtype: teq::RankT
          name: offset
          default: "0"
        - dtype: teq::RankT
          name: ndims
          default: teq::rank_cap
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::REDUCE_SUM,{tens},offset,ndims);
      - description: multiply values for ndims dimensions after offset
        template: typename T
        name: reduce_prod
        args:
        - dtype: eteq::NodeptrT<T>
          name: tens
        - dtype: teq::RankT
          name: offset
          default: "0"
        - dtype: teq::RankT
          name: ndims
          default: teq::rank_cap
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::REDUCE_PROD,{tens},offset,ndims);
      - description: min values for ndims dimensions after offset
        template: typename T
        name: reduce_min
        args:
        - dtype: eteq::NodeptrT<T>
          name: tens
        - dtype: teq::RankT
          name: offset
          default: "0"
        - dtype: teq::RankT
          name: ndims
          default: teq::rank_cap
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::REDUCE_MIN,{tens},offset,ndims);
      - description: max values for ndims dimensions after offset
        template: typename T
        name: reduce_max
        args:
        - dtype: eteq::NodeptrT<T>
          name: tens
        - dtype: teq::RankT
          name: offset
          default: "0"
        - dtype: teq::RankT
          name: ndims
          default: teq::rank_cap
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::REDUCE_MAX,{tens},offset,ndims);
      - template: typename T
        name: argmax
        args:
        - dtype: eteq::NodeptrT<T>
          name: tens
        - dtype: teq::RankT
          name: return_dim
          default: "8"
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::ARGMAX,{tens},return_dim);
      - template: typename T
        name: n_elems
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_constant_scalar<T>(arg->get_tensor()->shape().n_elems(), teq::Shape());
      - template: typename T
        name: n_dims
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::RankT
          name: rank
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_constant_scalar<T>(arg->get_tensor()->shape().at(rank), teq::Shape());
      - description: extents vector consists of pairs offset and extent for each dimension
        template: typename T
        name: slice
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: eigen::PairVecT<teq::DimT>
          name: extents
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::SLICE,{arg},extents);
      - template: typename T
        name: slice
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::DimT
          name: offset
        - dtype: teq::DimT
          name: extent
        - dtype: teq::RankT
          name: dimension
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  eigen::PairVecT<teq::DimT> extents(
                      std::max(teq::rank_cap, dimension),
                      {0,std::numeric_limits<teq::DimT>::max()});
                  extents[dimension] = {offset, extent};
                  return ::tenncor::slice(arg, extents);
      - template: typename T
        name: pad
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: eigen::PairVecT<teq::DimT>
          name: paddings
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::PAD,{arg},paddings);
      - template: typename T
        name: pad
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: std::pair<teq::DimT,teq::DimT>
          name: padding
        - dtype: teq::RankT
          name: dimension
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  eigen::PairVecT<teq::DimT> paddings(
                      std::max(teq::rank_cap, dimension), {0,0});
                  paddings[dimension] = padding;
                  return ::tenncor::pad(arg, paddings);
      - template: typename T
        name: stride
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: const std::vector<teq::DimT>&
          name: incrs
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::STRIDE,{arg},incrs);
      - description: populate input values at specific increments along its dimensions to fit specified shape (opposite of stride)
        template: typename T
        name: scatter
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: const teq::Shape&
          name: outshape
        - dtype: const std::vector<teq::DimT>&
          name: incrs
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::SCATTER,{arg},outshape,incrs);
      - description: multiple values across specify dimensions pairs before summing all products (generalization of matrix product), defaults to matrix product
        template: typename T
        name: contract
        args:
        - dtype: eteq::NodeptrT<T>
          name: a
        - dtype: eteq::NodeptrT<T>
          name: b
        - dtype: eigen::PairVecT<teq::RankT>
          name: dims
          default: eigen::PairVecT<teq::RankT>{{0, 1}}
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::MATMUL,{a, b}, dims);
      - template: typename T
        name: matmul
        args:
        - dtype: eteq::NodeptrT<T>
          name: a
        - dtype: eteq::NodeptrT<T>
          name: b
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::contract(a, b);
      - template: typename T
        name: convolution
        args:
        - dtype: eteq::NodeptrT<T>
          name: image
        - dtype: eteq::NodeptrT<T>
          name: kernel
        - dtype: const std::vector<teq::RankT>&
          name: dims
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(::egen::CONV,{image,kernel},dims);
      - template: typename T
        name: reduce_sum_1d
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::RankT
          name: dimension
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto red = ::tenncor::reduce_sum(arg, dimension, 1);

                  std::vector<teq::RankT> indices(teq::rank_cap);
                  auto bt = indices.begin();
                  auto it = bt + dimension;
                  std::iota(bt, it, 0);
                  std::iota(it, indices.end(), dimension + 1);
                  indices[teq::rank_cap - 1] = dimension;
                  return ::tenncor::permute(red, indices);
      - template: typename T
        name: reduce_prod_1d
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::RankT
          name: dimension
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto red = ::tenncor::reduce_prod(arg, dimension, 1);

                  std::vector<teq::RankT> indices(teq::rank_cap);
                  auto bt = indices.begin();
                  auto it = bt + dimension;
                  std::iota(bt, it, 0);
                  std::iota(it, indices.end(), dimension + 1);
                  indices[teq::rank_cap - 1] = dimension;
                  return ::tenncor::permute(red, indices);
      - template: typename T
        name: reduce_min_1d
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::RankT
          name: dimension
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto red = ::tenncor::reduce_min(arg, dimension, 1);

                  std::vector<teq::RankT> indices(teq::rank_cap);
                  auto bt = indices.begin();
                  auto it = bt + dimension;
                  std::iota(bt, it, 0);
                  std::iota(it, indices.end(), dimension + 1);
                  indices[teq::rank_cap - 1] = dimension;
                  return ::tenncor::permute(red, indices);
      - template: typename T
        name: reduce_max_1d
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::RankT
          name: dimension
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto red = ::tenncor::reduce_max(arg, dimension, 1);

                  std::vector<teq::RankT> indices(teq::rank_cap);
                  auto bt = indices.begin();
                  auto it = bt + dimension;
                  std::iota(bt, it, 0);
                  std::iota(it, indices.end(), dimension + 1);
                  indices[teq::rank_cap - 1] = dimension;
                  return ::tenncor::permute(red, indices);
      - template: typename T
        name: transpose
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::permute(arg, {1, 0});
      - template: typename T
        name: reduce_mean
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::div(::tenncor::reduce_sum(arg), ::tenncor::n_elems(arg));
      - template: typename T
        name: reduce_mean_1d
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::RankT
          name: dimension
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto red = ::tenncor::reduce_sum_1d(arg, dimension);
                  auto dim = eteq::make_constant_scalar<T>(arg->shape().at(dimension), red->shape());
                  return ::tenncor::div(red, dim);
      - template: typename T
        name: reduce_l2norm
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::RankT
          name: offset
          default: "0"
        - dtype: teq::RankT
          name: ndims
          default: teq::rank_cap
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::sqrt(::tenncor::reduce_sum(::tenncor::square(arg), offset, ndims));
      - template: typename T
        name: reduce_l2norm_1d
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::RankT
          name: dimension
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::sqrt(::tenncor::reduce_sum_1d(::tenncor::square(arg), dimension));
      - template: typename T
        name: clip_by_range
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: T
          name: minval
        - dtype: T
          name: maxval
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  if (minval > maxval)
                  {
                      logs::fatal("min value is below max");
                  }
                  teq::Shape shape = arg->shape();
                  auto lo = eteq::make_constant_scalar<T>(minval, shape);
                  auto hi = eteq::make_constant_scalar<T>(maxval, shape);
                  auto out = ::tenncor::max(::tenncor::min(arg, hi), lo);
                  tag::recursive_group_tag(out->get_tensor(), "clip_by_range", {
                      arg->get_tensor().get(),
                      lo->get_tensor().get(),
                      hi->get_tensor().get(),
                  });
                  return out;
      - description: clip by l2norm
        template: typename T
        name: clip_by_l2norm
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: T
          name: upper
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  // todo: allow l2norm offset and ndims to be configurable
                  if (upper == 0)
                  {
                      logs::fatal("cannot clip_by_norm with a upper limit of 0");
                  }
                  teq::Shape shape = arg->shape();
                  auto limit = eteq::make_constant_scalar<T>(upper, shape);
                  auto norm = ::tenncor::extend(::tenncor::reduce_l2norm(arg), 0,
                      std::vector<teq::DimT>(shape.begin(), shape.end()));
                  auto out = ::tenncor::if_then_else(::tenncor::lt(norm, limit),
                      arg, ::tenncor::div(::tenncor::mul(arg, limit), norm));
                  tag::recursive_group_tag(out->get_tensor(), "clip_by_l2norm", {
                      arg->get_tensor().get(),
                      limit->get_tensor().get(),
                  });
                  return out;
      - template: typename T
        name: sum
        args:
        - dtype: eteq::NodesT<T>
          name: args
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  size_t nargs = args.size();
                  switch (nargs)
                  {
                      case 0:
                          logs::fatal("cannot sum without arguments");
                      case 1:
                          return args[0];
                      case 2:
                          return ::tenncor::add(args[0], args[1]);
                      default:
                          break;
                  }
                  auto out = eteq::make_functor<T>(::egen::GROUP_SUM, args);
                  tag::get_property_reg().property_tag(out->get_tensor(), tag::commutative_tag);
                  tag::get_group_reg().group_tag(out->get_tensor(), "sum");
                  return out;
      - template: typename T
        name: prod
        args:
        - dtype: eteq::NodesT<T>
          name: args
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  size_t nargs = args.size();
                  switch (nargs)
                  {
                      case 0:
                          logs::fatal("cannot prod without arguments");
                      case 1:
                          return args[0];
                      case 2:
                          return ::tenncor::mul(args[0], args[1]);
                      default:
                          break;
                  }
                  auto out = eteq::make_functor<T>(::egen::GROUP_PROD, args);
                  tag::get_property_reg().property_tag(out->get_tensor(), tag::commutative_tag);
                  tag::get_group_reg().group_tag(out->get_tensor(), "prod");
                  return out;
      - template: typename T
        name: softmax
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::RankT
          name: offset
          default: "0"
        - dtype: teq::RankT
          name: ndims
          default: teq::rank_cap
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  if (offset + ndims > teq::rank_cap)
                  {
                      logs::fatalf("cannot perform softmax on dimensions beyond %d",
                          teq::rank_cap);
                  }
                  teq::Shape shape = arg->shape();
                  auto overflow_preventer = ::tenncor::extend(
                      ::tenncor::reduce_max(arg), 0,
                          std::vector<teq::DimT>(shape.begin(), shape.end()));
                  auto exarg = ::tenncor::exp(::tenncor::sub(arg, overflow_preventer));
                  auto it = shape.begin() + offset;
                  std::vector<teq::DimT> xlist(it, it + ndims);
                  auto out = ::tenncor::div(exarg,
                      ::tenncor::extend(::tenncor::add(
                          ::tenncor::reduce_sum(exarg, offset, ndims),
                          std::numeric_limits<T>::epsilon()),
                          offset, xlist));
                  tag::recursive_group_tag(out->get_tensor(), "softmax", {
                      arg->get_tensor().get()});
                  return out;
      - template: typename T
        name: relu
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto out = ::tenncor::max(arg, (T) 0);
                  tag::recursive_group_tag(out->get_tensor(), "relu", {
                      arg->get_tensor().get()});
                  return out;
      - template: typename T
        name: softplus
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto out = ::tenncor::log(::tenncor::add((T) 1, ::tenncor::exp(arg)));
                  tag::recursive_group_tag(out->get_tensor(), "softplus", {
                      arg->get_tensor().get()});
                  return out;
      - template: typename T
        name: sign
        args:
        - dtype: eteq::NodeptrT<T>
          name: x
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::add(::tenncor::mul((T)-2,::tenncor::lt(x,(T)0)),(T)1);
    tenncor::random:
      - template: typename T
        name: rand_unif
        args:
        - dtype: eteq::NodeptrT<T>
          name: a
        - dtype: eteq::NodeptrT<T>
          name: b
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  return eteq::make_functor<T>(::egen::RAND_UNIF, {a, b});
      - template: typename T
        name: rand_binom_one
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  const teq::Shape& shape = arg->get_tensor()->shape();
                  auto trial = ::tenncor::random::rand_unif(
                      eteq::convert_to_node(eteq::make_variable_scalar<T>((T) 0, shape)),
                      eteq::convert_to_node(eteq::make_variable_scalar<T>((T) 1, shape)));
                  return ::tenncor::lt(trial, arg);
    tenncor::nn:
      - template: typename T
        name: fully_connect
        args:
        - dtype: eteq::NodesT<T>
          name: inputs
        - dtype: eteq::NodesT<T>
          name: weights
        - dtype: eteq::NodeptrT<T>
          name: bias
          check_null: false
        - dtype: eigen::PairVecT<teq::RankT>
          name: dims
          default: eigen::PairVecT<teq::RankT>{{0, 1}}
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  if (weights.empty())
                  {
                      logs::fatal("cannot create a fully connected layer without weights");
                  }
                  size_t ninputs = inputs.size();
                  if (ninputs != weights.size())
                  {
                      logs::fatalf(
                          "number of inputs (%d) must equal the number of weights (%d)",
                          ninputs, weights.size());
                  }
                  teq::TensSetT ignores = {
                      inputs[0]->get_tensor().get(),
                      weights[0]->get_tensor().get()
                  };
                  auto out = ::tenncor::contract(inputs[0], weights[0], dims);
                  for (size_t i = 1; i < ninputs; ++i)
                  {
                      ignores.emplace(inputs[i]->get_tensor().get());
                      ignores.emplace(weights[i]->get_tensor().get());
                      out = ::tenncor::add(out, ::tenncor::contract(inputs[i], weights[i], dims));
                  }
                  if (nullptr != bias)
                  {
                      out = ::tenncor::add(out, ::tenncor::best_extend(bias, out->shape()));
                      ignores.emplace(bias->get_tensor().get());
                  }
                  tag::recursive_group_tag(out->get_tensor(), "fully_connect", ignores);
                  return out;
      - template: typename T
        name: conv2d
        args:
        - dtype: eteq::NodeptrT<T>
          name: image
        - dtype: eteq::NodeptrT<T>
          name: kernel
        - dtype: std::pair<teq::DimT,teq::DimT>
          name: zero_padding
          default: "std::pair<teq::DimT,teq::DimT>{0,0}"
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  // image must be in form [in, width, height, batch]
                  // kernel must be in form [out, in, width, height]
                  // expect output shape of [
                  //    out,
                  //    image.width-kernel.width+1+2*zero_padding.first,
                  //    image.height-kernel.height+1+2*zero_padding.second,
                  //    batch,
                  // ]
                  // zero_padding apply symmetrical padding for dimensions 1 and 2 to image before convolution
                  // see https://www.tensorflow.org/api_docs/python/tf/nn/conv2d
                  if (zero_padding.first > 0 || zero_padding.second > 0)
                  {
                      image = ::tenncor::pad(image, {{0, 0},
                          {zero_padding.first, zero_padding.first},
                          {zero_padding.second, zero_padding.second}});
                  }

                  teq::DimT img_pad = kernel->shape().at(0) - 1; // out
                  image = ::tenncor::pad(image,
                      std::pair<teq::DimT,teq::DimT>{img_pad, img_pad}, 4);
                  kernel = ::tenncor::reverse(kernel, {0});

                  auto out = ::tenncor::permute(
                      ::tenncor::convolution(image, kernel,
                          {4, 0, 1, 2}), {4, 1, 2, 3});
                  tag::recursive_group_tag(out->get_tensor(), "conv2d", {
                      image->get_tensor().get(),
                      kernel->get_tensor().get()
                  });
                  return out;
      - template: typename T
        name: mean_pool2d
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: std::pair<teq::RankT,teq::RankT>
          name: dims
          default: "std::pair<teq::RankT,teq::RankT>{0, 1}"
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  teq::DimT xextent = arg->shape().at(dims.first) - 1;
                  teq::DimT yextent = arg->shape().at(dims.second) - 1;
                  std::vector<teq::DimT> strider(teq::rank_cap, 1);
                  strider[dims.first] = strider[dims.second] = 2;
                  auto top_left = ::tenncor::stride(arg, strider);
                  auto top_right = ::tenncor::stride(
                      ::tenncor::slice(arg, 1, xextent, dims.first), strider);
                  auto bot_left = ::tenncor::stride(
                      ::tenncor::slice(arg, 1, yextent, dims.second), strider);
                  eigen::PairVecT<teq::DimT> pvec(teq::rank_cap,
                      {0, std::numeric_limits<teq::DimT>::max()});
                  pvec[dims.first] = {1, xextent};
                  pvec[dims.second] = {1, yextent};
                  auto bot_right = ::tenncor::stride(
                      ::tenncor::slice(arg, pvec), strider);

                  // todo: tag this maybe?
                  return ::tenncor::div(::tenncor::sum(eteq::NodesT<T>{
                      top_left, top_right, bot_left, bot_right}), (T) 4);
      - template: typename T
        name: max_pool2d
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: std::pair<teq::RankT,teq::RankT>
          name: dims
          default: "std::pair<teq::RankT,teq::RankT>{0, 1}"
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  teq::DimT xextent = arg->shape().at(dims.first) - 1;
                  teq::DimT yextent = arg->shape().at(dims.second) - 1;
                  std::vector<teq::DimT> strider(teq::rank_cap, 1);
                  strider[dims.first] = strider[dims.second] = 2;
                  auto top_left = ::tenncor::stride(arg, strider);
                  auto top_right = ::tenncor::stride(
                      ::tenncor::slice(arg, 1, xextent, dims.first), strider);
                  auto bot_left = ::tenncor::stride(
                      ::tenncor::slice(arg, 1, yextent, dims.second), strider);
                  eigen::PairVecT<teq::DimT> pvec(teq::rank_cap,
                      {0, std::numeric_limits<teq::DimT>::max()});
                  pvec[dims.first] = {1, xextent};
                  pvec[dims.second] = {1, yextent};
                  auto bot_right = ::tenncor::stride(
                      ::tenncor::slice(arg, pvec), strider);

                  // todo: tag this maybe?
                  return ::tenncor::max(eteq::NodesT<T>{
                      top_left, top_right, bot_left, bot_right});

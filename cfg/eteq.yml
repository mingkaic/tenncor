api:
  pybind_type: float
  includes:
  - '"eteq/make.hpp"'
  namespaces:
    tenncor:
      - template: typename T
        name: abs
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::ABS, {arg});
      - template: typename T
        name: neg
        operator: "-"
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::NEG, {arg});
      - template: typename T
        name: sin
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::SIN, {arg});
      - template: typename T
        name: cos
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::COS, {arg});
      - template: typename T
        name: tan
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::TAN, {arg});
      - template: typename T
        name: exp
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::EXP, {arg});
      - template: typename T
        name: log
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::LOG, {arg});
      - template: typename T
        name: sqrt
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::SQRT, {arg});
      - template: typename T
        name: round
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::ROUND, {arg});
      - template: typename T
        name: sigmoid
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::SIGMOID, {arg});
      - template: typename T
        name: tanh
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::TANH, {arg});
      - template: typename T
        name: square
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::SQUARE, {arg});
      - template: typename T
        name: cube
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::CUBE, {arg});
      - template: typename T
        name: pow
        args:
        - dtype: eteq::LinkptrT<T>
          name: a
        - dtype: eteq::LinkptrT<T>
          name: b
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::POW, {a, b});
      - template: typename T
        name: pow
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::LinkptrT<T>
          val: return ::tenncor::pow(arg1, eteq::make_constant_like<T>(scalar,arg1));
      - template: typename T
        name: pow
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::LinkptrT<T>
          name: arg1
        out:
          type: eteq::LinkptrT<T>
          val: return ::tenncor::pow(eteq::make_constant_like<T>(scalar,arg1),arg1);
      - template: typename T
        name: add
        operator: +
        args:
        - dtype: eteq::LinkptrT<T>
          name: a
        - dtype: eteq::LinkptrT<T>
          name: b
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                  auto out = eteq::make_functor<T>(::egen::ADD, {a, b});
                  out->add_attr(eigen::commutative_attr, std::make_unique<marsh::String>());
                  return out;
      - template: typename T
        name: add
        operator: +
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::LinkptrT<T>
          val: return ::tenncor::add(arg1,eteq::make_constant_like<T>(scalar,arg1));
      - template: typename T
        name: add
        operator: +
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::LinkptrT<T>
          name: arg1
        out:
          type: eteq::LinkptrT<T>
          val: return ::tenncor::add(eteq::make_constant_like<T>(scalar,arg1),arg1);
      - template: typename T
        name: sub
        operator: "-"
        args:
        - dtype: eteq::LinkptrT<T>
          name: a
        - dtype: eteq::LinkptrT<T>
          name: b
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::SUB, {a, b});
      - template: typename T
        name: sub
        operator: "-"
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::LinkptrT<T>
          val: return ::tenncor::sub(arg1,eteq::make_constant_like<T>(scalar,arg1));
      - template: typename T
        name: sub
        operator: "-"
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::LinkptrT<T>
          name: arg1
        out:
          type: eteq::LinkptrT<T>
          val: return ::tenncor::sub(eteq::make_constant_like<T>(scalar,arg1),arg1);
      - template: typename T
        name: mul
        operator: "*"
        args:
        - dtype: eteq::LinkptrT<T>
          name: a
        - dtype: eteq::LinkptrT<T>
          name: b
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                  auto out = eteq::make_functor<T>(::egen::MUL, {a, b});
                  out->add_attr(eigen::commutative_attr, std::make_unique<marsh::String>());
                  return out;
      - template: typename T
        name: mul
        operator: "*"
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::LinkptrT<T>
          val: return ::tenncor::mul(arg1,eteq::make_constant_like<T>(scalar,arg1));
      - template: typename T
        name: mul
        operator: "*"
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::LinkptrT<T>
          name: arg1
        out:
          type: eteq::LinkptrT<T>
          val: return ::tenncor::mul(eteq::make_constant_like<T>(scalar,arg1),arg1);
      - template: typename T
        name: div
        operator: /
        args:
        - dtype: eteq::LinkptrT<T>
          name: a
        - dtype: eteq::LinkptrT<T>
          name: b
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::DIV, {a, b});
      - template: typename T
        name: div
        operator: /
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::LinkptrT<T>
          val: return ::tenncor::div(arg1,eteq::make_constant_like<T>(scalar,arg1));
      - template: typename T
        name: div
        operator: /
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::LinkptrT<T>
          name: arg1
        out:
          type: eteq::LinkptrT<T>
          val: return ::tenncor::div(eteq::make_constant_like<T>(scalar,arg1),arg1);
      - template: typename T
        name: eq
        operator: ==
        args:
        - dtype: eteq::LinkptrT<T>
          name: a
        - dtype: eteq::LinkptrT<T>
          name: b
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                  auto out = eteq::make_functor<T>(::egen::EQ, {a, b});
                  out->add_attr(eigen::commutative_attr, std::make_unique<marsh::String>());
                  return out;
      - template: typename T
        name: eq
        operator: ==
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::LinkptrT<T>
          val: return ::tenncor::eq(arg1,eteq::make_constant_like<T>(scalar,arg1));
      - template: typename T
        name: eq
        operator: ==
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::LinkptrT<T>
          name: arg1
        out:
          type: eteq::LinkptrT<T>
          val: return ::tenncor::eq(eteq::make_constant_like<T>(scalar,arg1),arg1);
      - template: typename T
        name: neq
        operator: "!="
        args:
        - dtype: eteq::LinkptrT<T>
          name: a
        - dtype: eteq::LinkptrT<T>
          name: b
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                  auto out = eteq::make_functor<T>(::egen::NEQ, {a, b});
                  out->add_attr(eigen::commutative_attr, std::make_unique<marsh::String>());
                  return out;
      - template: typename T
        name: neq
        operator: "!="
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::LinkptrT<T>
          val: return ::tenncor::neq(arg1,eteq::make_constant_like<T>(scalar,arg1));
      - template: typename T
        name: neq
        operator: "!="
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::LinkptrT<T>
          name: arg1
        out:
          type: eteq::LinkptrT<T>
          val: return ::tenncor::neq(eteq::make_constant_like<T>(scalar,arg1),arg1);
      - template: typename T
        name: lt
        operator: <
        args:
        - dtype: eteq::LinkptrT<T>
          name: a
        - dtype: eteq::LinkptrT<T>
          name: b
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::LT, {a, b});
      - template: typename T
        name: lt
        operator: <
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::LinkptrT<T>
          val: return ::tenncor::lt(arg1,eteq::make_constant_like<T>(scalar,arg1));
      - template: typename T
        name: lt
        operator: <
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::LinkptrT<T>
          name: arg1
        out:
          type: eteq::LinkptrT<T>
          val: return ::tenncor::lt(eteq::make_constant_like<T>(scalar,arg1),arg1);
      - template: typename T
        name: gt
        operator: ">"
        args:
        - dtype: eteq::LinkptrT<T>
          name: a
        - dtype: eteq::LinkptrT<T>
          name: b
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::GT, {a, b});
      - template: typename T
        name: gt
        operator: ">"
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::LinkptrT<T>
          val: return ::tenncor::gt(arg1,eteq::make_constant_like<T>(scalar,arg1));
      - template: typename T
        name: gt
        operator: ">"
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::LinkptrT<T>
          name: arg1
        out:
          type: eteq::LinkptrT<T>
          val: return ::tenncor::gt(eteq::make_constant_like<T>(scalar,arg1),arg1);
      - template: typename T
        name: min
        args:
        - dtype: eteq::LinkptrT<T>
          name: a
        - dtype: eteq::LinkptrT<T>
          name: b
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                  auto out = eteq::make_functor<T>(::egen::MIN, {a, b});
                  out->add_attr(eigen::commutative_attr, std::make_unique<marsh::String>());
                  return out;
      - template: typename T
        name: min
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::LinkptrT<T>
          val: return ::tenncor::min(arg1,eteq::make_constant_like<T>(scalar,arg1));
      - template: typename T
        name: min
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::LinkptrT<T>
          name: arg1
        out:
          type: eteq::LinkptrT<T>
          val: return ::tenncor::min(eteq::make_constant_like<T>(scalar,arg1),arg1);
      - template: typename T
        name: min
        args:
        - dtype: eteq::LinksT<T>
          name: args
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                  if (args.empty())
                  {
                      logs::fatal("cannot min without arguments");
                  }
                  eteq::LinkptrT<T> out = args[0];
                  for (size_t i = 1, n = args.size(); i < n; ++i)
                  {
                      out = ::tenncor::min(out, args[i]);
                  }
                  return out;
      - template: typename T
        name: max
        args:
        - dtype: eteq::LinkptrT<T>
          name: a
        - dtype: eteq::LinkptrT<T>
          name: b
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                auto out = eteq::make_functor<T>(::egen::MAX, {a, b});
                out->add_attr(eigen::commutative_attr, std::make_unique<marsh::String>());
                return out;
      - template: typename T
        name: max
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::LinkptrT<T>
          val: return ::tenncor::max(arg1,eteq::make_constant_like<T>(scalar,arg1));
      - template: typename T
        name: max
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::LinkptrT<T>
          name: arg1
        out:
          type: eteq::LinkptrT<T>
          val: return ::tenncor::max(eteq::make_constant_like<T>(scalar,arg1),arg1);
      - template: typename T
        name: max
        args:
        - dtype: eteq::LinksT<T>
          name: args
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                  if (args.empty())
                  {
                      logs::fatal("cannot max without arguments");
                  }
                  eteq::LinkptrT<T> out = args[0];
                  for (size_t i = 1, n = args.size(); i < n; ++i)
                  {
                      out = ::tenncor::max(out, args[i]);
                  }
                  return out;
      - template: typename T
        name: if_then_else
        args:
        - dtype: eteq::LinkptrT<T>
          name: condition
        - dtype: eteq::LinkptrT<T>
          name: then
        - dtype: eteq::LinkptrT<T>
          name: otherwise
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                  // if then == otherwise and neither are ambiguous, then treat as identity
                  auto then_tens = then->get_tensor();
                  if (nullptr != then_tens && then_tens == otherwise->get_tensor())
                  {
                      return then;
                  }
                  return eteq::make_functor<T>(::egen::SELECT, {condition,then,otherwise});
      - template: typename T
        name: reverse
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        - dtype: const std::set<teq::RankT>&
          name: dims
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::REVERSE,{arg},dims);
      - template: typename T
        name: permute
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        - dtype: const std::vector<teq::RankT>&
          name: order
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::PERMUTE,{arg},order);
      - template: typename T
        name: extend
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        - dtype: const std::vector<teq::DimT>&
          name: bcast
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::EXTEND,{arg},bcast);
      - template: typename T
        name: extend
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        - dtype: teq::RankT
          name: offset
        - dtype: const std::vector<teq::DimT>&
          name: xlist
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                  std::vector<teq::DimT> bcast(offset, 1);
                  bcast.insert(bcast.end(), xlist.begin(), xlist.end());
                  return eteq::make_functor<T>(::egen::EXTEND,{arg},bcast);
      - template: typename T
        name: concat
        args:
        - dtype: eteq::LinkptrT<T>
          name: left
        - dtype: eteq::LinkptrT<T>
          name: right
        - dtype: teq::RankT
          name: axis
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::CONCAT,{left,right},axis);
      - template: typename T
        name: concat
        args:
        - dtype: eteq::LinksT<T>
          name: args
        - dtype: teq::RankT
          name: axis
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::GROUP_CONCAT,args,axis);
      - description: Return extended arg so that output shape matches slist exactly
        template: typename T
        name: best_extend
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        - dtype: const std::vector<teq::DimT>&
          name: slist
        out:
          type: eteq::LinkptrT<T>
          val: return ::tenncor::best_extend(arg, teq::ShapeSignature(slist));
      - description: Return extended arg so that output shape matches shape exactly
        template: typename T
        name: best_extend
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        - dtype: const teq::ShapeSignature&
          name: target
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                  teq::ShapeSignature source = arg->shape_sign();
                  teq::RankT offset = 0;
                  while (offset < teq::rank_cap && source.at(offset) > 0 &&
                      source.at(offset) == target.at(offset))
                  {
                      ++offset;
                  }
                  if (offset == teq::rank_cap)
                  {
                      // everything is equivalent or ambiguous
                      return arg;
                  }
                  std::vector<teq::DimT> exts;
                  exts.reserve(teq::rank_cap - offset);
                  for (teq::RankT i = offset; i < teq::rank_cap; ++i)
                  {
                      teq::DimT sdim = source.at(i);
                      teq::DimT tdim = target.at(i);
                      if (sdim > 0 && tdim > 0 && sdim != tdim)
                      {
                          if (sdim > 1)
                          {
                              logs::fatalf(
                                  "cannot extend shapes %s and %s at dimension %d to match",
                                  source.to_string().c_str(), target.to_string().c_str(), i);
                          }
                          exts.push_back(tdim);
                      } else {
                          exts.push_back(1);
                      }
                  }
                  return ::tenncor::extend(arg, offset, exts);
      - template: typename T
        name: reshape
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        - dtype: teq::Shape
          name: shape
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::RESHAPE,{arg},shape);
      - description: sum values for dimensions specified
        template: typename T
        name: reduce_sum
        args:
        - dtype: eteq::LinkptrT<T>
          name: tens
        - dtype: std::set<teq::RankT>
          name: dims
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::REDUCE_SUM,{tens},dims);
      - description: multiply values for dimensions specified
        template: typename T
        name: reduce_prod
        args:
        - dtype: eteq::LinkptrT<T>
          name: tens
        - dtype: std::set<teq::RankT>
          name: dims
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::REDUCE_PROD,{tens},dims);
      - description: get min values of dimensions specified
        template: typename T
        name: reduce_min
        args:
        - dtype: eteq::LinkptrT<T>
          name: tens
        - dtype: std::set<teq::RankT>
          name: dims
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::REDUCE_MIN,{tens},dims);
      - description: get max values for dimensions specified
        template: typename T
        name: reduce_max
        args:
        - dtype: eteq::LinkptrT<T>
          name: tens
        - dtype: std::set<teq::RankT>
          name: dims
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::REDUCE_MAX,{tens},dims);
      - description: sum values for ndims dimensions after offset
        template: typename T
        name: reduce_sum
        args:
        - dtype: eteq::LinkptrT<T>
          name: tens
        - dtype: teq::RankT
          name: offset
          default: "0"
        - dtype: teq::RankT
          name: ndims
          default: teq::rank_cap
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                  if (offset >= teq::rank_cap)
                  {
                      logs::fatalf("cannot reduce dimensions [%d:]. Must be less than %d",
                          offset, teq::rank_cap);
                  }
                  std::vector<teq::RankT> dims(std::min(ndims,
                      (teq::RankT) (teq::rank_cap - offset)));
                  std::iota(dims.begin(), dims.end(), offset);
                  return eteq::make_functor<T>(::egen::REDUCE_SUM,{tens},
                      std::set<teq::RankT>(dims.begin(), dims.end()));
      - description: multiply values for ndims dimensions after offset
        template: typename T
        name: reduce_prod
        args:
        - dtype: eteq::LinkptrT<T>
          name: tens
        - dtype: teq::RankT
          name: offset
          default: "0"
        - dtype: teq::RankT
          name: ndims
          default: teq::rank_cap
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                  if (offset >= teq::rank_cap)
                  {
                      logs::fatalf("cannot reduce dimensions [%d:]. Must be less than %d",
                          offset, teq::rank_cap);
                  }
                  std::vector<teq::RankT> dims(std::min(ndims,
                      (teq::RankT) (teq::rank_cap - offset)));
                  std::iota(dims.begin(), dims.end(), offset);
                  return eteq::make_functor<T>(::egen::REDUCE_PROD,{tens},
                      std::set<teq::RankT>(dims.begin(), dims.end()));
      - description: min values for ndims dimensions after offset
        template: typename T
        name: reduce_min
        args:
        - dtype: eteq::LinkptrT<T>
          name: tens
        - dtype: teq::RankT
          name: offset
          default: "0"
        - dtype: teq::RankT
          name: ndims
          default: teq::rank_cap
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                  if (offset >= teq::rank_cap)
                  {
                      logs::fatalf("cannot reduce dimensions [%d:]. Must be less than %d",
                          offset, teq::rank_cap);
                  }
                  std::vector<teq::RankT> dims(std::min(ndims,
                      (teq::RankT) (teq::rank_cap - offset)));
                  std::iota(dims.begin(), dims.end(), offset);
                  return eteq::make_functor<T>(::egen::REDUCE_MIN,{tens},
                      std::set<teq::RankT>(dims.begin(), dims.end()));
      - description: max values for ndims dimensions after offset
        template: typename T
        name: reduce_max
        args:
        - dtype: eteq::LinkptrT<T>
          name: tens
        - dtype: teq::RankT
          name: offset
          default: "0"
        - dtype: teq::RankT
          name: ndims
          default: teq::rank_cap
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                  if (offset >= teq::rank_cap)
                  {
                      logs::fatalf("cannot reduce dimensions [%d:]. Must be less than %d",
                          offset, teq::rank_cap);
                  }
                  std::vector<teq::RankT> dims(std::min(ndims,
                      (teq::RankT) (teq::rank_cap - offset)));
                  std::iota(dims.begin(), dims.end(), offset);
                  return eteq::make_functor<T>(::egen::REDUCE_MAX,{tens},
                      std::set<teq::RankT>(dims.begin(), dims.end()));
      - template: typename T
        name: argmax
        args:
        - dtype: eteq::LinkptrT<T>
          name: tens
        - dtype: teq::RankT
          name: return_dim
          default: "8"
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::ARGMAX,{tens},return_dim);
      - template: typename T
        name: n_elems
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                  auto sign = arg->shape_sign();
                  if (teq::is_ambiguous(sign))
                  {
                      logs::fatalf("cannot n_elems on ambiguous shaped argument (sign=%s)",
                          sign.to_string().c_str());
                  }
                  return eteq::make_constant_scalar<T>(teq::Shape(sign).n_elems(), teq::Shape());
      - template: typename T
        name: n_dims
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        - dtype: teq::RankT
          name: rank
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                  auto sign = arg->shape_sign();
                  if (sign.at(rank) == 0)
                  {
                      logs::fatalf("cannot n_dims with ambiguous dimension %d argument (sign=%s)",
                          (int) rank, sign.to_string().c_str());
                  }
                  return eteq::make_constant_scalar<T>(sign.at(rank), teq::Shape());
      - description: extents vector consists of pairs offset and extent for each dimension
        template: typename T
        name: slice
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        - dtype: eigen::PairVecT<teq::DimT>
          name: extents
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::SLICE,{arg},extents);
      - template: typename T
        name: slice
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        - dtype: teq::DimT
          name: offset
        - dtype: teq::DimT
          name: extent
        - dtype: teq::RankT
          name: dimension
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                  eigen::PairVecT<teq::DimT> extents(
                      std::max(teq::rank_cap, dimension),
                      {0,std::numeric_limits<teq::DimT>::max()});
                  extents[dimension] = {offset, extent};
                  return ::tenncor::slice(arg, extents);
      - template: typename T
        name: pad
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        - dtype: eigen::PairVecT<teq::DimT>
          name: paddings
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::PAD,{arg},paddings);
      - template: typename T
        name: pad
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        - dtype: std::pair<teq::DimT,teq::DimT>
          name: padding
        - dtype: teq::RankT
          name: dimension
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                  eigen::PairVecT<teq::DimT> paddings(
                      std::max(teq::rank_cap, dimension), {0,0});
                  paddings[dimension] = padding;
                  return ::tenncor::pad(arg, paddings);
      - template: typename T
        name: stride
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        - dtype: const std::vector<teq::DimT>&
          name: incrs
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::STRIDE,{arg},incrs);
      - description: populate input values at specific increments along its dimensions to fit specified shape (opposite of stride)
        template: typename T
        name: scatter
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        - dtype: const teq::Shape&
          name: outshape
        - dtype: const std::vector<teq::DimT>&
          name: incrs
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::SCATTER,{arg},outshape,incrs);
      - description: multiple values across specify dimensions pairs before summing all products (generalization of matrix product), defaults to matrix product
        template: typename T
        name: contract
        args:
        - dtype: eteq::LinkptrT<T>
          name: a
        - dtype: eteq::LinkptrT<T>
          name: b
        - dtype: eigen::PairVecT<teq::RankT>
          name: dims
          default: eigen::PairVecT<teq::RankT>{{0, 1}}
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::MATMUL,{a, b}, dims);
      - template: typename T
        name: matmul
        args:
        - dtype: eteq::LinkptrT<T>
          name: a
        - dtype: eteq::LinkptrT<T>
          name: b
        out:
          type: eteq::LinkptrT<T>
          val: return ::tenncor::contract(a, b);
      - template: typename T
        name: convolution
        args:
        - dtype: eteq::LinkptrT<T>
          name: image
        - dtype: eteq::LinkptrT<T>
          name: kernel
        - dtype: const std::vector<teq::RankT>&
          name: dims
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::CONV,{image,kernel},dims);
      - template: typename T
        name: reduce_sum_1d
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        - dtype: teq::RankT
          name: dimension
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                  auto red = ::tenncor::reduce_sum(arg, dimension, 1);

                  std::vector<teq::RankT> indices(teq::rank_cap);
                  auto bt = indices.begin();
                  auto it = bt + dimension;
                  std::iota(bt, it, 0);
                  std::iota(it, indices.end(), dimension + 1);
                  indices[teq::rank_cap - 1] = dimension;
                  return ::tenncor::permute(red, indices);
      - template: typename T
        name: reduce_prod_1d
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        - dtype: teq::RankT
          name: dimension
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                  auto red = ::tenncor::reduce_prod(arg, dimension, 1);

                  std::vector<teq::RankT> indices(teq::rank_cap);
                  auto bt = indices.begin();
                  auto it = bt + dimension;
                  std::iota(bt, it, 0);
                  std::iota(it, indices.end(), dimension + 1);
                  indices[teq::rank_cap - 1] = dimension;
                  return ::tenncor::permute(red, indices);
      - template: typename T
        name: reduce_min_1d
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        - dtype: teq::RankT
          name: dimension
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                  auto red = ::tenncor::reduce_min(arg, dimension, 1);

                  std::vector<teq::RankT> indices(teq::rank_cap);
                  auto bt = indices.begin();
                  auto it = bt + dimension;
                  std::iota(bt, it, 0);
                  std::iota(it, indices.end(), dimension + 1);
                  indices[teq::rank_cap - 1] = dimension;
                  return ::tenncor::permute(red, indices);
      - template: typename T
        name: reduce_max_1d
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        - dtype: teq::RankT
          name: dimension
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                  auto red = ::tenncor::reduce_max(arg, dimension, 1);

                  std::vector<teq::RankT> indices(teq::rank_cap);
                  auto bt = indices.begin();
                  auto it = bt + dimension;
                  std::iota(bt, it, 0);
                  std::iota(it, indices.end(), dimension + 1);
                  indices[teq::rank_cap - 1] = dimension;
                  return ::tenncor::permute(red, indices);
      - template: typename T
        name: transpose
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        out:
          type: eteq::LinkptrT<T>
          val: return ::tenncor::permute(arg, {1, 0});
      - template: typename T
        name: reduce_mean
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        out:
          type: eteq::LinkptrT<T>
          val: return ::tenncor::div(::tenncor::reduce_sum(arg), ::tenncor::n_elems(arg));
      - template: typename T
        name: reduce_mean_1d
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        - dtype: teq::RankT
          name: dimension
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                  auto sign = arg->shape_sign();
                  if (sign.at(dimension) == 0)
                  {
                      logs::fatalf("cannot reduce_mean_1d with ambiguous dimension %d argument (sign=%s)",
                          (int) dimension, sign.to_string().c_str());
                  }
                  auto red = ::tenncor::reduce_sum_1d(arg, dimension);
                  auto dim = eteq::make_constant_like<T>(sign.at(dimension), red);
                  return ::tenncor::div(red, dim);
      - template: typename T
        name: reduce_l2norm
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        - dtype: teq::RankT
          name: offset
          default: "0"
        - dtype: teq::RankT
          name: ndims
          default: teq::rank_cap
        out:
          type: eteq::LinkptrT<T>
          val: return ::tenncor::sqrt(::tenncor::reduce_sum(::tenncor::square(arg), offset, ndims));
      - template: typename T
        name: reduce_l2norm_1d
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        - dtype: teq::RankT
          name: dimension
        out:
          type: eteq::LinkptrT<T>
          val: return ::tenncor::sqrt(::tenncor::reduce_sum_1d(::tenncor::square(arg), dimension));
      - template: typename T
        name: clip_by_range
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        - dtype: T
          name: minval
        - dtype: T
          name: maxval
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                  if (minval > maxval)
                  {
                      logs::fatal("min value is below max");
                  }
                  auto lo = eteq::make_constant_like<T>(minval, arg);
                  auto hi = eteq::make_constant_like<T>(maxval, arg);
                  return ::tenncor::max(::tenncor::min(arg, hi), lo);
      - description: clip by l2norm
        template: typename T
        name: clip_by_l2norm
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        - dtype: T
          name: upper
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                  // todo: allow l2norm offset and ndims to be configurable
                  if (upper == 0)
                  {
                      logs::fatal("cannot clip_by_norm with a upper limit of 0");
                  }
                  auto norm = ::tenncor::best_extend(
                      ::tenncor::reduce_l2norm(arg), arg->shape_sign());
                  auto limit = eteq::make_constant_like<T>(upper, arg);
                  return ::tenncor::if_then_else(::tenncor::lt(norm, limit),
                      arg, ::tenncor::div(::tenncor::mul(arg, limit), norm));
      - template: typename T
        name: sum
        args:
        - dtype: eteq::LinksT<T>
          name: args
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                  size_t nargs = args.size();
                  switch (nargs)
                  {
                      case 0:
                          logs::fatal("cannot sum without arguments");
                      case 1:
                          return args[0];
                      case 2:
                          return ::tenncor::add(args[0], args[1]);
                      default:
                          break;
                  }
                  auto out = eteq::make_functor<T>(::egen::GROUP_SUM, args);
                  out->add_attr(eigen::commutative_attr, std::make_unique<marsh::String>());
                  return out;
      - template: typename T
        name: prod
        args:
        - dtype: eteq::LinksT<T>
          name: args
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                  size_t nargs = args.size();
                  switch (nargs)
                  {
                      case 0:
                          logs::fatal("cannot prod without arguments");
                      case 1:
                          return args[0];
                      case 2:
                          return ::tenncor::mul(args[0], args[1]);
                      default:
                          break;
                  }
                  auto out = eteq::make_functor<T>(::egen::GROUP_PROD, args);
                  out->add_attr(eigen::commutative_attr, std::make_unique<marsh::String>());
                  return out;
      - template: typename T
        name: softmax
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        - dtype: teq::RankT
          name: offset
          default: "0"
        - dtype: teq::RankT
          name: ndims
          default: teq::rank_cap
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                  if (offset + ndims > teq::rank_cap)
                  {
                      logs::fatalf("cannot perform softmax on dimensions beyond %d",
                          teq::rank_cap);
                  }
                  teq::ShapeSignature shape = arg->shape_sign();
                  auto overflow_preventer = ::tenncor::best_extend(
                      ::tenncor::reduce_max(arg), shape);
                  auto exarg = ::tenncor::exp(::tenncor::sub(arg, overflow_preventer));
                  auto it = shape.begin() + offset;
                  std::vector<teq::DimT> xlist(it, it + ndims);
                  return ::tenncor::div(exarg,
                      ::tenncor::extend(::tenncor::add(
                          ::tenncor::reduce_sum(exarg, offset, ndims),
                          std::numeric_limits<T>::epsilon()),
                          offset, xlist));
      - template: typename T
        name: relu
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        out:
          type: eteq::LinkptrT<T>
          val: return ::tenncor::max(arg, (T) 0);
      - template: typename T
        name: softplus
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        out:
          type: eteq::LinkptrT<T>
          val: return ::tenncor::log(::tenncor::add((T) 1, ::tenncor::exp(arg)));
      - template: typename T
        name: sign
        args:
        - dtype: eteq::LinkptrT<T>
          name: x
        out:
          type: eteq::LinkptrT<T>
          val: return ::tenncor::add(::tenncor::mul((T)-2,::tenncor::lt(x,(T)0)),(T)1);
    tenncor::random:
      - template: typename T
        name: rand_unif
        args:
        - dtype: eteq::LinkptrT<T>
          name: a
        - dtype: eteq::LinkptrT<T>
          name: b
        out:
          type: eteq::LinkptrT<T>
          val: return eteq::make_functor<T>(::egen::RAND_UNIF, {a, b});
      - template: typename T
        name: rand_binom_one
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                  auto trial = ::tenncor::random::rand_unif(
                      eteq::to_link<T>(eteq::make_variable_like<T>((T) 0, arg)),
                      eteq::to_link<T>(eteq::make_variable_like<T>((T) 1, arg)));
                  return ::tenncor::lt(trial, arg);
    tenncor::nn:
      - template: typename T
        name: fully_connect
        args:
        - dtype: eteq::LinksT<T>
          name: inputs
        - dtype: eteq::LinksT<T>
          name: weights
        - dtype: eteq::LinkptrT<T>
          name: bias
          check_null: false
        - dtype: eigen::PairVecT<teq::RankT>
          name: dims
          default: eigen::PairVecT<teq::RankT>{{0, 1}}
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                  if (weights.empty())
                  {
                      logs::fatal("cannot create a fully connected layer without weights");
                  }
                  size_t ninputs = inputs.size();
                  if (ninputs != weights.size())
                  {
                      logs::fatalf(
                          "number of inputs (%d) must equal the number of weights (%d)",
                          ninputs, weights.size());
                  }
                  auto out = ::tenncor::contract(inputs[0], weights[0], dims);
                  for (size_t i = 1; i < ninputs; ++i)
                  {
                      out = ::tenncor::add(out, ::tenncor::contract(inputs[i], weights[i], dims));
                  }
                  if (nullptr != bias)
                  {
                      out = ::tenncor::add(out, ::tenncor::best_extend(bias, out->shape_sign()));
                  }
                  return out;
      - template: typename T
        name: conv2d
        args:
        - dtype: eteq::LinkptrT<T>
          name: image
        - dtype: eteq::LinkptrT<T>
          name: kernel
        - dtype: std::pair<teq::DimT,teq::DimT>
          name: zero_padding
          default: "std::pair<teq::DimT,teq::DimT>{0,0}"
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                  // image must be in form [in, iwidth, iheight, batch]
                  // kernel must be in form [out, in, kwidth, kheight]
                  // expect output shape of [
                  //    out,
                  //    image.width-kernel.width+1+2*zero_padding.first,
                  //    image.height-kernel.height+1+2*zero_padding.second,
                  //    batch,
                  // ]
                  // zero_padding apply symmetrical padding for dimensions 1 and 2 to image before convolution
                  // see https://www.tensorflow.org/api_docs/python/tf/nn/conv2d
                  if (zero_padding.first > 0 || zero_padding.second > 0)
                  {
                      image = ::tenncor::pad(image, {{0, 0},
                          {zero_padding.first, zero_padding.first},
                          {zero_padding.second, zero_padding.second}});
                  }
                  teq::DimT outdim = kernel->shape_sign().at(0);
                  if (outdim == 0)
                  {
                      logs::fatalf("cannot conv2d with ambiguous out dimension %d", (int) outdim);
                  }

                  teq::DimT img_pad = outdim - 1; // out
                  image = ::tenncor::pad(image,
                      std::pair<teq::DimT,teq::DimT>{img_pad, img_pad}, 4);
                  kernel = ::tenncor::reverse(kernel, {0});

                 return ::tenncor::permute(
                      ::tenncor::convolution(image, kernel,
                          {4, 0, 1, 2}), {4, 1, 2, 3});
      - template: typename T
        name: mean_pool2d
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        - dtype: std::pair<teq::RankT,teq::RankT>
          name: dims
          default: "std::pair<teq::RankT,teq::RankT>{0, 1}"
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                  teq::ShapeSignature sign = arg->shape_sign();
                  teq::DimT xextent = sign.at(dims.first);
                  teq::DimT yextent = sign.at(dims.second);
                  if (xextent == 0 || yextent == 0)
                  {
                      logs::fatalf("cannot pool on ambiguous dimensions %d and %d (sign=%s)",
                          (int) dims.first, (int) dims.second, sign.to_string().c_str());
                  }
                  --xextent;
                  --yextent;
                  std::vector<teq::DimT> strider(teq::rank_cap, 1);
                  strider[dims.first] = strider[dims.second] = 2;
                  auto top_left = ::tenncor::stride(arg, strider);
                  auto top_right = ::tenncor::stride(
                      ::tenncor::slice(arg, 1, xextent, dims.first), strider);
                  auto bot_left = ::tenncor::stride(
                      ::tenncor::slice(arg, 1, yextent, dims.second), strider);
                  eigen::PairVecT<teq::DimT> pvec(teq::rank_cap,
                      {0, std::numeric_limits<teq::DimT>::max()});
                  pvec[dims.first] = {1, xextent};
                  pvec[dims.second] = {1, yextent};
                  auto bot_right = ::tenncor::stride(
                      ::tenncor::slice(arg, pvec), strider);

                  // todo: tag this maybe?
                  return ::tenncor::div(::tenncor::sum(eteq::LinksT<T>{
                      top_left, top_right, bot_left, bot_right}), (T) 4);
      - template: typename T
        name: max_pool2d
        args:
        - dtype: eteq::LinkptrT<T>
          name: arg
        - dtype: std::pair<teq::RankT,teq::RankT>
          name: dims
          default: "std::pair<teq::RankT,teq::RankT>{0, 1}"
        out:
          type: eteq::LinkptrT<T>
          val: |
              //
                  teq::ShapeSignature sign = arg->shape_sign();
                  teq::DimT xextent = sign.at(dims.first);
                  teq::DimT yextent = sign.at(dims.second);
                  if (xextent == 0 || yextent == 0)
                  {
                      logs::fatalf("cannot pool on ambiguous dimensions %d and %d (sign=%s)",
                          (int) dims.first, (int) dims.second, sign.to_string().c_str());
                  }
                  --xextent;
                  --yextent;
                  std::vector<teq::DimT> strider(teq::rank_cap, 1);
                  strider[dims.first] = strider[dims.second] = 2;
                  auto top_left = ::tenncor::stride(arg, strider);
                  auto top_right = ::tenncor::stride(
                      ::tenncor::slice(arg, 1, xextent, dims.first), strider);
                  auto bot_left = ::tenncor::stride(
                      ::tenncor::slice(arg, 1, yextent, dims.second), strider);
                  eigen::PairVecT<teq::DimT> pvec(teq::rank_cap,
                      {0, std::numeric_limits<teq::DimT>::max()});
                  pvec[dims.first] = {1, xextent};
                  pvec[dims.second] = {1, yextent};
                  auto bot_right = ::tenncor::stride(
                      ::tenncor::slice(arg, pvec), strider);

                  // todo: tag this maybe?
                  return ::tenncor::max(eteq::LinksT<T>{
                      top_left, top_right, bot_left, bot_right});

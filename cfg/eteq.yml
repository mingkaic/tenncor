api:
  pybind_type: float
  includes:
  - '"eteq/constant.hpp"'
  - '"eteq/variable.hpp"'
  - '"eteq/functor.hpp"'
  - '"tag/group.hpp"'
  - '"tag/prop.hpp"'
  namespaces:
    tenncor:
      - template: typename T
        name: abs
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"ABS",::egen::ABS},{eteq::Edge<T>(arg)});
      - template: typename T
        name: neg
        operator: "-"
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"NEG",::egen::NEG},{eteq::Edge<T>(arg)});
      - template: typename T
        name: sin
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"SIN",::egen::SIN},{eteq::Edge<T>(arg)});
      - template: typename T
        name: cos
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"COS",::egen::COS},{eteq::Edge<T>(arg)});
      - template: typename T
        name: tan
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"TAN",::egen::TAN},{eteq::Edge<T>(arg)});
      - template: typename T
        name: exp
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"EXP",::egen::EXP},{eteq::Edge<T>(arg)});
      - template: typename T
        name: log
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"LOG",::egen::LOG},{eteq::Edge<T>(arg)});
      - template: typename T
        name: sqrt
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"SQRT",::egen::SQRT},{eteq::Edge<T>(arg)});
      - template: typename T
        name: round
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"ROUND",::egen::ROUND},{eteq::Edge<T>(arg)});
      - template: typename T
        name: sigmoid
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"SIGMOID",::egen::SIGMOID},{eteq::Edge<T>(arg)});
      - template: typename T
        name: tanh
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"TANH",::egen::TANH},{eteq::Edge<T>(arg)});
      - template: typename T
        name: square
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"SQUARE",::egen::SQUARE},{eteq::Edge<T>(arg)});
      - template: typename T
        name: cube
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"CUBE",::egen::CUBE},{eteq::Edge<T>(arg)});
      - template: typename T
        name: pow
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: eteq::NodeptrT<T>
          name: arg2
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"POW",::egen::POW},{eteq::Edge<T>(arg1),eteq::Edge<T>(arg2)});
      - template: typename T
        name: pow
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::pow(arg1, eteq::make_constant_scalar<T>(scalar,arg1->shape()));
      - template: typename T
        name: pow
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::NodeptrT<T>
          name: arg1
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::pow(eteq::make_constant_scalar<T>(scalar,arg1->shape()),arg1);
      - template: typename T
        name: add
        operator: +
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: eteq::NodeptrT<T>
          name: arg2
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto out = eteq::make_functor<T>(teq::Opcode{"ADD",::egen::ADD}, {
                      eteq::Edge<T>(arg1),
                      eteq::Edge<T>(arg2),
                  });
                  tag::get_property_reg().property_tag(out->get_tensor(), tag::commutative_tag);
                  tag::get_group_reg().group_tag(out->get_tensor(), "sum");
                  return out;
      - template: typename T
        name: add
        operator: +
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::add(arg1,eteq::make_constant_scalar<T>(scalar,arg1->shape()));
      - template: typename T
        name: add
        operator: +
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::NodeptrT<T>
          name: arg1
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::add(eteq::make_constant_scalar<T>(scalar,arg1->shape()),arg1);
      - template: typename T
        name: sub
        operator: "-"
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: eteq::NodeptrT<T>
          name: arg2
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"SUB",::egen::SUB},{eteq::Edge<T>(arg1),eteq::Edge<T>(arg2)});
      - template: typename T
        name: sub
        operator: "-"
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::sub(arg1,eteq::make_constant_scalar<T>(scalar,arg1->shape()));
      - template: typename T
        name: sub
        operator: "-"
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::NodeptrT<T>
          name: arg1
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::sub(eteq::make_constant_scalar<T>(scalar,arg1->shape()),arg1);
      - template: typename T
        name: mul
        operator: "*"
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: eteq::NodeptrT<T>
          name: arg2
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto out = eteq::make_functor<T>(teq::Opcode{"MUL",::egen::MUL}, {
                      eteq::Edge<T>(arg1),
                      eteq::Edge<T>(arg2),
                  });
                  tag::get_property_reg().property_tag(out->get_tensor(), tag::commutative_tag);
                  tag::get_group_reg().group_tag(out->get_tensor(), "prod");
                  return out;
      - template: typename T
        name: mul
        operator: "*"
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::mul(arg1,eteq::make_constant_scalar<T>(scalar,arg1->shape()));
      - template: typename T
        name: mul
        operator: "*"
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::NodeptrT<T>
          name: arg1
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::mul(eteq::make_constant_scalar<T>(scalar,arg1->shape()),arg1);
      - template: typename T
        name: div
        operator: /
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: eteq::NodeptrT<T>
          name: arg2
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"DIV",::egen::DIV},{eteq::Edge<T>(arg1),eteq::Edge<T>(arg2)});
      - template: typename T
        name: div
        operator: /
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::div(arg1,eteq::make_constant_scalar<T>(scalar,arg1->shape()));
      - template: typename T
        name: div
        operator: /
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::NodeptrT<T>
          name: arg1
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::div(eteq::make_constant_scalar<T>(scalar,arg1->shape()),arg1);
      - template: typename T
        name: eq
        operator: ==
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: eteq::NodeptrT<T>
          name: arg2
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto out = eteq::make_functor<T>(teq::Opcode{"EQ",::egen::EQ}, {
                      eteq::Edge<T>(arg1),
                      eteq::Edge<T>(arg2),
                  });
                  tag::get_property_reg().property_tag(out->get_tensor(), tag::commutative_tag);
                  return out;
      - template: typename T
        name: eq
        operator: ==
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::eq(arg1,eteq::make_constant_scalar<T>(scalar,arg1->shape()));
      - template: typename T
        name: eq
        operator: ==
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::NodeptrT<T>
          name: arg1
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::eq(eteq::make_constant_scalar<T>(scalar,arg1->shape()),arg1);
      - template: typename T
        name: neq
        operator: "!="
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: eteq::NodeptrT<T>
          name: arg2
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto out = eteq::make_functor<T>(teq::Opcode{"NEQ",::egen::NEQ}, {
                      eteq::Edge<T>(arg1),
                      eteq::Edge<T>(arg2),
                  });
                  tag::get_property_reg().property_tag(out->get_tensor(), tag::commutative_tag);
                  return out;
      - template: typename T
        name: neq
        operator: "!="
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::neq(arg1,eteq::make_constant_scalar<T>(scalar,arg1->shape()));
      - template: typename T
        name: neq
        operator: "!="
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::NodeptrT<T>
          name: arg1
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::neq(eteq::make_constant_scalar<T>(scalar,arg1->shape()),arg1);
      - template: typename T
        name: lt
        operator: <
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: eteq::NodeptrT<T>
          name: arg2
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"LT",::egen::LT},{eteq::Edge<T>(arg1),eteq::Edge<T>(arg2)});
      - template: typename T
        name: lt
        operator: <
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::lt(arg1,eteq::make_constant_scalar<T>(scalar,arg1->shape()));
      - template: typename T
        name: lt
        operator: <
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::NodeptrT<T>
          name: arg1
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::lt(eteq::make_constant_scalar<T>(scalar,arg1->shape()),arg1);
      - template: typename T
        name: gt
        operator: ">"
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: eteq::NodeptrT<T>
          name: arg2
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"GT",::egen::GT},{eteq::Edge<T>(arg1),eteq::Edge<T>(arg2)});
      - template: typename T
        name: gt
        operator: ">"
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::gt(arg1,eteq::make_constant_scalar<T>(scalar,arg1->shape()));
      - template: typename T
        name: gt
        operator: ">"
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::NodeptrT<T>
          name: arg1
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::gt(eteq::make_constant_scalar<T>(scalar,arg1->shape()),arg1);
      - template: typename T
        name: min
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: eteq::NodeptrT<T>
          name: arg2
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto out = eteq::make_functor<T>(teq::Opcode{"MIN",::egen::MIN}, {
                      eteq::Edge<T>(arg1),
                      eteq::Edge<T>(arg2),
                  });
                  // todo: tag min with a group?
                  tag::get_property_reg().property_tag(out->get_tensor(), tag::commutative_tag);
                  return out;
      - template: typename T
        name: min
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::min(arg1,eteq::make_constant_scalar<T>(scalar,arg1->shape()));
      - template: typename T
        name: min
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::NodeptrT<T>
          name: arg1
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::min(eteq::make_constant_scalar<T>(scalar,arg1->shape()),arg1);
      - template: typename T
        name: min
        args:
        - dtype: eteq::NodesT<T>
          name: args
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  if (args.empty())
                  {
                      logs::fatal("cannot min without arguments");
                  }
                  eteq::NodeptrT<T> out = args[0];
                  for (size_t i = 1, n = args.size(); i < n; ++i)
                  {
                      out = ::tenncor::min(out, args[i]);
                  }
                  return out;
      - template: typename T
        name: max
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: eteq::NodeptrT<T>
          name: arg2
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto out = eteq::make_functor<T>(teq::Opcode{"MAX",::egen::MAX}, {
                      eteq::Edge<T>(arg1),
                      eteq::Edge<T>(arg2),
                  });
                  // todo: tag max with a group?
                  tag::get_property_reg().property_tag(out->get_tensor(), tag::commutative_tag);
                  return out;
      - template: typename T
        name: max
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::max(arg1,eteq::make_constant_scalar<T>(scalar,arg1->shape()));
      - template: typename T
        name: max
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::NodeptrT<T>
          name: arg1
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::max(eteq::make_constant_scalar<T>(scalar,arg1->shape()),arg1);
      - template: typename T
        name: max
        args:
        - dtype: eteq::NodesT<T>
          name: args
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  if (args.empty())
                  {
                      logs::fatal("cannot max without arguments");
                  }
                  eteq::NodeptrT<T> out = args[0];
                  for (size_t i = 1, n = args.size(); i < n; ++i)
                  {
                      out = ::tenncor::max(out, args[i]);
                  }
                  return out;
      - template: typename T
        name: if_then_else
        args:
        - dtype: eteq::NodeptrT<T>
          name: condition
        - dtype: eteq::NodeptrT<T>
          name: then
        - dtype: eteq::NodeptrT<T>
          name: otherwise
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  return eteq::make_functor<T>(teq::Opcode{"SELECT",::egen::SELECT},{
                      eteq::Edge<T>(condition),
                      eteq::Edge<T>(then),
                      eteq::Edge<T>(otherwise)
                  });
      - template: typename T
        name: reverse
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: const std::vector<teq::RankT>&
          name: dims
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  return eteq::make_functor<T>(teq::Opcode{"REVERSE",::egen::REVERSE},{
                      eteq::Edge<T>(arg,arg->shape(),
                          std::vector<double>(dims.begin(), dims.end()))
                  });
      - template: typename T
        name: permute
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: const std::vector<teq::RankT>&
          name: order
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"PERMUTE",::egen::PERMUTE},{eteq::permute_map(arg,order)});
      - template: typename T
        name: extend
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::RankT
          name: offset
        - dtype: const std::vector<teq::DimT>&
          name: xlist
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  if (xlist.empty()){
                      logs::warn("extending with empty vector ... will do nothing");
                      return arg; // identity
                  }
                  return eteq::make_functor<T>(teq::Opcode{"EXTEND",::egen::EXTEND},{
                      eteq::extend_map(arg,offset,xlist)
                  });
      - template: typename T
        name: concat
        args:
        - dtype: eteq::NodeptrT<T>
          name: left
        - dtype: eteq::NodeptrT<T>
          name: right
        - dtype: teq::RankT
          name: axis
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"CONCAT",::egen::CONCAT},eteq::concat_map(left,right,axis));
      - template: typename T
        name: concat
        args:
        - dtype: eteq::NodesT<T>
          name: args
        - dtype: teq::RankT
          name: axis
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  if (args.size() == 1)
                  {
                      return args[0];
                  }
                  return eteq::make_functor<T>(teq::Opcode{"GROUP_CONCAT",::egen::GROUP_CONCAT},
                      eteq::group_concat_map(args,axis));
      - description: Return extended arg so that output shape matches slist exactly
        template: typename T
        name: best_extend
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: const std::vector<teq::DimT>&
          name: slist
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  teq::RankT n = std::min(teq::rank_cap, (teq::RankT) slist.size());
                  teq::Shape source = arg->shape();
                  teq::RankT offset = 0;
                  while (offset < n && source.at(offset) == slist.at(offset)) {
                      ++offset;
                  }
                  if (offset == n) {
                      return arg;
                  }
                  std::vector<teq::DimT> exts;
                  exts.reserve(n - offset);
                  for (teq::RankT i = offset; i < n; ++i) {
                      teq::DimT sdim = source.at(i);
                      teq::DimT tdim = slist.at(i);
                      if (sdim != tdim) {
                          if (sdim != 1) {
                              logs::fatalf(
                                  "cannot extend shapes %s and %s at dimension %d to match",
                                  source.to_string().c_str(),
                                  fmts::to_string(slist.begin(), slist.end()).c_str(), i);
                          }
                          exts.push_back(tdim);
                      } else {
                          exts.push_back(1);
                      }
                  }
                  return ::tenncor::extend(arg, offset, exts);
      - description: Return extended arg so that output shape matches shape exactly
        template: typename T
        name: best_extend
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: const teq::Shape&
          name: shape
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::best_extend(arg, std::vector<teq::DimT>(shape.begin(), shape.end()));
      - template: typename T
        name: reshape
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::Shape
          name: shape
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"RESHAPE",::egen::RESHAPE},{eteq::reshape_map(arg,shape)});
      - description: sum values ignoring coordinate indices between start and end
        template: typename T
        name: reduce_sum
        args:
        - dtype: eteq::NodeptrT<T>
          name: tens
        - dtype: teq::RankT
          name: offset
          default: "0"
        - dtype: teq::RankT
          name: ndims
          default: teq::rank_cap
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"REDUCE_SUM",::egen::REDUCE_SUM},{eteq::reduce_map(tens,offset,ndims)});
      - description: multiply values ignoring coordinate indices between start and end
        template: typename T
        name: reduce_prod
        args:
        - dtype: eteq::NodeptrT<T>
          name: tens
        - dtype: teq::RankT
          name: offset
          default: "0"
        - dtype: teq::RankT
          name: ndims
          default: teq::rank_cap
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"REDUCE_PROD",::egen::REDUCE_PROD},{eteq::reduce_map(tens,offset,ndims)});
      - description: min values ignoring coordinate indices between start and end
        template: typename T
        name: reduce_min
        args:
        - dtype: eteq::NodeptrT<T>
          name: tens
        - dtype: teq::RankT
          name: offset
          default: "0"
        - dtype: teq::RankT
          name: ndims
          default: teq::rank_cap
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"REDUCE_MIN",::egen::REDUCE_MIN},{eteq::reduce_map(tens,offset,ndims)});
      - description: max values ignoring coordinate indices between start and end
        template: typename T
        name: reduce_max
        args:
        - dtype: eteq::NodeptrT<T>
          name: tens
        - dtype: teq::RankT
          name: offset
          default: "0"
        - dtype: teq::RankT
          name: ndims
          default: teq::rank_cap
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"REDUCE_MAX",::egen::REDUCE_MAX},{eteq::reduce_map(tens,offset,ndims)});
      - template: typename T
        name: argmax
        args:
        - dtype: eteq::NodeptrT<T>
          name: tens
        - dtype: teq::RankT
          name: return_dim
          default: "8"
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"ARGMAX",::egen::ARGMAX},{eteq::argreduce_map(tens,return_dim)});
      - template: typename T
        name: n_elems
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_constant_scalar<T>(arg->get_tensor()->shape().n_elems(), teq::Shape());
      - template: typename T
        name: n_dims
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::RankT
          name: rank
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_constant_scalar<T>(arg->get_tensor()->shape().at(rank), teq::Shape());
      - description: extents vector consists of pairs offset and extent for each dimension
        template: typename T
        name: slice
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: eigen::PairVecT<teq::DimT>
          name: extents
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"SLICE",::egen::SLICE}, {eteq::slice_map<T>(arg, extents)});
      - template: typename T
        name: slice
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::DimT
          name: offset
        - dtype: teq::DimT
          name: extent
        - dtype: teq::RankT
          name: dimension
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  eigen::PairVecT<teq::DimT> extents(
                      std::max(teq::rank_cap, dimension),
                      {0,std::numeric_limits<teq::DimT>::max()});
                  extents[dimension] = {offset, extent};
                  return ::tenncor::slice(arg, extents);
      - template: typename T
        name: pad
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: eigen::PairVecT<teq::DimT>
          name: paddings
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"PAD",::egen::PAD}, {eteq::pad_map<T>(arg, paddings)});
      - template: typename T
        name: pad
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: std::pair<teq::DimT,teq::DimT>
          name: padding
        - dtype: teq::RankT
          name: dimension
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  eigen::PairVecT<teq::DimT> paddings(
                      std::max(teq::rank_cap, dimension), {0,0});
                  paddings[dimension] = padding;
                  return ::tenncor::pad(arg, paddings);
      - template: typename T
        name: stride
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: const std::vector<teq::DimT>&
          name: incrs
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"STRIDE",::egen::STRIDE}, {eteq::stride_map(arg, incrs)});
      - description: multiple values across specify dimensions pairs before summing all products (generalization of matrix product), defaults to matrix product
        template: typename T
        name: contract
        args:
        - dtype: eteq::NodeptrT<T>
          name: a
        - dtype: eteq::NodeptrT<T>
          name: b
        - dtype: eigen::PairVecT<teq::RankT>
          name: dims
          default: eigen::PairVecT<teq::RankT>{{0, 1}}
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"MATMUL",::egen::MATMUL}, eteq::contract_map(a, b, dims));
      - template: typename T
        name: matmul
        args:
        - dtype: eteq::NodeptrT<T>
          name: a
        - dtype: eteq::NodeptrT<T>
          name: b
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::contract(a, b);
      - template: typename T
        name: convolution
        args:
        - dtype: eteq::NodeptrT<T>
          name: input
        - dtype: eteq::NodeptrT<T>
          name: kernel
        - dtype: const std::vector<teq::RankT>&
          name: dims
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"CONV",::egen::CONV},eteq::convolve_map(input, kernel, dims));
      - template: typename T
        name: reduce_sum_1d
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::RankT
          name: dimension
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto red = ::tenncor::reduce_sum(arg, dimension, 1);

                  std::vector<teq::RankT> indices(teq::rank_cap);
                  auto bt = indices.begin();
                  auto it = bt + dimension;
                  std::iota(bt, it, 0);
                  std::iota(it, indices.end(), dimension + 1);
                  indices[teq::rank_cap - 1] = dimension;
                  return ::tenncor::permute(red, indices);
      - template: typename T
        name: reduce_prod_1d
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::RankT
          name: dimension
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto red = ::tenncor::reduce_prod(arg, dimension, 1);

                  std::vector<teq::RankT> indices(teq::rank_cap);
                  auto bt = indices.begin();
                  auto it = bt + dimension;
                  std::iota(bt, it, 0);
                  std::iota(it, indices.end(), dimension + 1);
                  indices[teq::rank_cap - 1] = dimension;
                  return ::tenncor::permute(red, indices);
      - template: typename T
        name: reduce_min_1d
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::RankT
          name: dimension
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto red = ::tenncor::reduce_min(arg, dimension, 1);

                  std::vector<teq::RankT> indices(teq::rank_cap);
                  auto bt = indices.begin();
                  auto it = bt + dimension;
                  std::iota(bt, it, 0);
                  std::iota(it, indices.end(), dimension + 1);
                  indices[teq::rank_cap - 1] = dimension;
                  return ::tenncor::permute(red, indices);
      - template: typename T
        name: reduce_max_1d
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::RankT
          name: dimension
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto red = ::tenncor::reduce_max(arg, dimension, 1);

                  std::vector<teq::RankT> indices(teq::rank_cap);
                  auto bt = indices.begin();
                  auto it = bt + dimension;
                  std::iota(bt, it, 0);
                  std::iota(it, indices.end(), dimension + 1);
                  indices[teq::rank_cap - 1] = dimension;
                  return ::tenncor::permute(red, indices);
      - template: typename T
        name: transpose
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::permute(arg, {1, 0});
      - template: typename T
        name: reduce_mean
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::div(::tenncor::reduce_sum(arg), ::tenncor::n_elems(arg));
      - template: typename T
        name: reduce_mean_1d
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::RankT
          name: dimension
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto red = ::tenncor::reduce_sum_1d(arg, dimension);
                  auto dim = eteq::make_constant_scalar<T>(arg->shape().at(dimension), red->shape());
                  return ::tenncor::div(red, dim);
      - template: typename T
        name: reduce_l2norm
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::RankT
          name: offset
          default: "0"
        - dtype: teq::RankT
          name: ndims
          default: teq::rank_cap
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::sqrt(::tenncor::reduce_sum(::tenncor::square(arg), offset, ndims));
      - template: typename T
        name: reduce_l2norm_1d
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::RankT
          name: dimension
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::sqrt(::tenncor::reduce_sum_1d(::tenncor::square(arg), dimension));
      - template: typename T
        name: clip_by_range
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: T
          name: minval
        - dtype: T
          name: maxval
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  if (minval > maxval)
                  {
                      logs::fatal("min value is below max");
                  }
                  teq::Shape shape = arg->shape();
                  auto lo = eteq::make_constant_scalar<T>(minval, shape);
                  auto hi = eteq::make_constant_scalar<T>(maxval, shape);
                  auto out = ::tenncor::max(::tenncor::min(arg, hi), lo);
                  tag::recursive_group_tag(out->get_tensor(), "clip_by_range", {
                      arg->get_tensor().get(),
                      lo->get_tensor().get(),
                      hi->get_tensor().get(),
                  });
                  return out;
      - description: clip by l2norm
        template: typename T
        name: clip_by_l2norm
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: T
          name: upper
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  // todo: allow l2norm offset and ndims to be configurable
                  if (upper == 0)
                  {
                      logs::fatal("cannot clip_by_norm with a upper limit of 0");
                  }
                  teq::Shape shape = arg->shape();
                  auto limit = eteq::make_constant_scalar<T>(upper, shape);
                  auto norm = ::tenncor::extend(::tenncor::reduce_l2norm(arg), 0,
                      std::vector<teq::DimT>(shape.begin(), shape.end()));
                  auto out = ::tenncor::if_then_else(::tenncor::lt(norm, limit),
                      arg, ::tenncor::div(::tenncor::mul(arg, limit), norm));
                  tag::recursive_group_tag(out->get_tensor(), "clip_by_l2norm", {
                      arg->get_tensor().get(),
                      limit->get_tensor().get(),
                  });
                  return out;
      - template: typename T
        name: sum
        args:
        - dtype: eteq::NodesT<T>
          name: args
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  size_t nargs = args.size();
                  switch (nargs)
                  {
                      case 0:
                          logs::fatal("cannot sum without arguments");
                      case 1:
                          return args[0];
                      case 2:
                          return ::tenncor::add(args[0], args[1]);
                      default:
                          break;
                  }
                  eteq::ArgsT<T> inarg;
                  inarg.reserve(nargs);
                  std::transform(args.begin(), args.end(), std::back_inserter(inarg),
                      [](eteq::NodeptrT<T> node) { return eteq::Edge<T>(node); });
                  auto out = eteq::make_functor<T>(teq::Opcode{"GROUP_SUM",::egen::GROUP_SUM}, inarg);
                  tag::get_property_reg().property_tag(out->get_tensor(), tag::commutative_tag);
                  tag::get_group_reg().group_tag(out->get_tensor(), "sum");
                  return out;
      - template: typename T
        name: prod
        args:
        - dtype: eteq::NodesT<T>
          name: args
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  size_t nargs = args.size();
                  switch (nargs)
                  {
                      case 0:
                          logs::fatal("cannot prod without arguments");
                      case 1:
                          return args[0];
                      case 2:
                          return ::tenncor::mul(args[0], args[1]);
                      default:
                          break;
                  }
                  eteq::ArgsT<T> inarg;
                  inarg.reserve(nargs);
                  std::transform(args.begin(), args.end(), std::back_inserter(inarg),
                      [](eteq::NodeptrT<T> node) { return eteq::Edge<T>(node); });
                  auto out = eteq::make_functor<T>(teq::Opcode{"GROUP_PROD",::egen::GROUP_PROD}, inarg);
                  tag::get_property_reg().property_tag(out->get_tensor(), tag::commutative_tag);
                  tag::get_group_reg().group_tag(out->get_tensor(), "prod");
                  return out;
      - template: typename T
        name: softmax
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::RankT
          name: offset
          default: "0"
        - dtype: teq::RankT
          name: ndims
          default: teq::rank_cap
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  if (offset + ndims > teq::rank_cap)
                  {
                      logs::fatalf("cannot perform softmax on dimensions beyond %d",
                          teq::rank_cap);
                  }
                  teq::Shape shape = arg->shape();
                  auto overflow_preventer = ::tenncor::extend(
                      ::tenncor::reduce_max(arg), 0,
                          std::vector<teq::DimT>(shape.begin(), shape.end()));
                  auto exarg = ::tenncor::exp(::tenncor::sub(arg, overflow_preventer));
                  auto it = shape.begin() + offset;
                  std::vector<teq::DimT> xlist(it, it + ndims);
                  auto out = ::tenncor::div(exarg,
                      ::tenncor::extend(::tenncor::add(
                          ::tenncor::reduce_sum(exarg, offset, ndims),
                          std::numeric_limits<T>::epsilon()),
                          offset, xlist));
                  tag::recursive_group_tag(out->get_tensor(), "softmax", {
                      arg->get_tensor().get()});
                  return out;
      - template: typename T
        name: relu
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto out = ::tenncor::max(arg, (T) 0);
                  tag::recursive_group_tag(out->get_tensor(), "relu", {
                      arg->get_tensor().get()});
                  return out;
      - template: typename T
        name: softplus
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto out = ::tenncor::log(::tenncor::add((T) 1, ::tenncor::exp(arg)));
                  tag::recursive_group_tag(out->get_tensor(), "softplus", {
                      arg->get_tensor().get()});
                  return out;
      - template: typename T
        name: sign
        args:
        - dtype: eteq::NodeptrT<T>
          name: x
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::add(::tenncor::mul((T)-2,::tenncor::lt(x,(T)0)),(T)1);
    tenncor::random:
      - template: typename T
        name: rand_unif
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: eteq::NodeptrT<T>
          name: arg2
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  return eteq::make_functor<T>(
                      teq::Opcode{"RAND_UNIF",::egen::RAND_UNIF},{
                          eteq::Edge<T>(arg1),
                          eteq::Edge<T>(arg2)
                      });
      - template: typename T
        name: rand_binom_one
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  const teq::Shape& shape = arg->get_tensor()->shape();
                  auto trial = ::tenncor::random::rand_unif(
                      eteq::convert_to_node(eteq::make_variable_scalar<T>((T) 0, shape)),
                      eteq::convert_to_node(eteq::make_variable_scalar<T>((T) 1, shape)));
                  return ::tenncor::lt(trial, arg);
    tenncor::nn:
      - template: typename T
        name: fully_connect
        args:
        - dtype: eteq::NodesT<T>
          name: inputs
        - dtype: eteq::NodesT<T>
          name: weights
        - dtype: eteq::NodeptrT<T>
          name: bias
          check_null: false
        - dtype: eigen::PairVecT<teq::RankT>
          name: dims
          default: eigen::PairVecT<teq::RankT>{{0, 1}}
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  if (weights.empty())
                  {
                      logs::fatal("cannot create a fully connected layer without weights");
                  }
                  size_t ninputs = inputs.size();
                  if (ninputs != weights.size())
                  {
                      logs::fatalf(
                          "number of inputs (%d) must equal the number of weights (%d)",
                          ninputs, weights.size());
                  }
                  teq::TensSetT ignores = {
                      inputs[0]->get_tensor().get(),
                      weights[0]->get_tensor().get()
                  };
                  auto out = ::tenncor::contract(inputs[0], weights[0], dims);
                  for (size_t i = 1; i < ninputs; ++i)
                  {
                      ignores.emplace(inputs[i]->get_tensor().get());
                      ignores.emplace(weights[i]->get_tensor().get());
                      out = ::tenncor::add(out, ::tenncor::contract(inputs[i], weights[i], dims));
                  }
                  if (nullptr != bias)
                  {
                      out = ::tenncor::add(out, ::tenncor::best_extend(bias, out->shape()));
                      ignores.emplace(bias->get_tensor().get());
                  }
                  tag::recursive_group_tag(out->get_tensor(), "fully_connect", ignores);
                  return out;
      - template: typename T
        name: conv2d
        args:
        - dtype: eteq::NodeptrT<T>
          name: image
        - dtype: eteq::NodeptrT<T>
          name: kernel
        - dtype: std::pair<teq::DimT,teq::DimT>
          name: zero_padding
          default: "std::pair<teq::DimT,teq::DimT>{0,0}"
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  // image must be in form [in, width, height, batch]
                  // kernel must be in form [out, in, width, height]
                  // expect output shape of [
                  //    out,
                  //    image.width-kernel.width+1+2*zero_padding.first,
                  //    image.height-kernel.height+1+2*zero_padding.second,
                  //    batch,
                  // ]
                  // zero_padding apply symmetrical padding for dimensions 1 and 2 to image before convolution
                  // see https://www.tensorflow.org/api_docs/python/tf/nn/conv2d
                  if (zero_padding.first > 0 || zero_padding.second > 0)
                  {
                      image = ::tenncor::pad(image, {{0, 0},
                          {zero_padding.first, zero_padding.first},
                          {zero_padding.second, zero_padding.second}});
                  }

                  teq::DimT img_pad = kernel->shape().at(0) - 1; // out
                  image = ::tenncor::pad(image,
                      std::pair<teq::DimT,teq::DimT>{img_pad, img_pad}, 4);
                  kernel = ::tenncor::reverse(kernel, {0});

                  auto out = ::tenncor::permute(
                      ::tenncor::convolution(image, kernel,
                          {4, 0, 1, 2}), {4, 1, 2, 3});
                  tag::recursive_group_tag(out->get_tensor(), "conv2d", {
                      image->get_tensor().get(),
                      kernel->get_tensor().get()
                  });
                  return out;
      - template: typename T
        name: mean_pool2d
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: std::pair<teq::RankT,teq::RankT>
          name: dims
          default: "std::pair<teq::RankT,teq::RankT>{0, 1}"
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  teq::DimT xextent = arg->shape().at(dims.first) - 1;
                  teq::DimT yextent = arg->shape().at(dims.second) - 1;
                  std::vector<teq::DimT> strider(teq::rank_cap, 1);
                  strider[dims.first] = strider[dims.second] = 2;
                  auto top_left = ::tenncor::stride(arg, strider);
                  auto top_right = ::tenncor::stride(
                      ::tenncor::slice(arg, 1, xextent, dims.first), strider);
                  auto bot_left = ::tenncor::stride(
                      ::tenncor::slice(arg, 1, yextent, dims.second), strider);
                  eigen::PairVecT<teq::DimT> pvec(teq::rank_cap,
                      {0, std::numeric_limits<teq::DimT>::max()});
                  pvec[dims.first] = {1, xextent};
                  pvec[dims.second] = {1, yextent};
                  auto bot_right = ::tenncor::stride(
                      ::tenncor::slice(arg, pvec), strider);

                  // todo: tag this maybe?
                  return ::tenncor::div(::tenncor::sum(eteq::NodesT<T>{
                      top_left, top_right, bot_left, bot_right}), (T) 4);
      - template: typename T
        name: max_pool2d
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: std::pair<teq::RankT,teq::RankT>
          name: dims
          default: "std::pair<teq::RankT,teq::RankT>{0, 1}"
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  teq::DimT xextent = arg->shape().at(dims.first) - 1;
                  teq::DimT yextent = arg->shape().at(dims.second) - 1;
                  std::vector<teq::DimT> strider(teq::rank_cap, 1);
                  strider[dims.first] = strider[dims.second] = 2;
                  auto top_left = ::tenncor::stride(arg, strider);
                  auto top_right = ::tenncor::stride(
                      ::tenncor::slice(arg, 1, xextent, dims.first), strider);
                  auto bot_left = ::tenncor::stride(
                      ::tenncor::slice(arg, 1, yextent, dims.second), strider);
                  eigen::PairVecT<teq::DimT> pvec(teq::rank_cap,
                      {0, std::numeric_limits<teq::DimT>::max()});
                  pvec[dims.first] = {1, xextent};
                  pvec[dims.second] = {1, yextent};
                  auto bot_right = ::tenncor::stride(
                      ::tenncor::slice(arg, pvec), strider);

                  // todo: tag this maybe?
                  return ::tenncor::max(eteq::NodesT<T>{
                      top_left, top_right, bot_left, bot_right});

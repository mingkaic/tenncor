opcode:
  operator_path: eteq/operator.hpp
  params: teq::Shape shape, eteq::EigenptrT<T>& out, std::vector<eteq::OpArg<T>>& in
  opcalls:
    ABS: out = eteq::abs(shape,in[0]);
    NEG: out = eteq::neg(shape,in[0]);
    SIN: out = eteq::sin(shape,in[0]);
    COS: out = eteq::cos(shape,in[0]);
    TAN: out = eteq::tan(shape,in[0]);
    EXP: out = eteq::exp(shape,in[0]);
    LOG: out = eteq::log(shape,in[0]);
    SQRT: out = eteq::sqrt(shape,in[0]);
    ROUND: out = eteq::round(shape,in[0]);
    SIGMOID: out = eteq::sigmoid(shape,in[0]);
    SIGMOID_GRAD: out = eteq::sigmoid_grad(shape,in[0]);
    TANH: out = eteq::tanh(shape,in[0]);
    SQUARE: out = eteq::square(shape,in[0]);
    CUBE: out = eteq::cube(shape,in[0]);
    POW: out = eteq::pow(shape,in[0],in[1]);
    ADD: out = eteq::add(shape,in[0],in[1]);
    SUB: out = eteq::sub(shape,in[0],in[1]);
    MUL: out = eteq::mul(shape,in[0],in[1]);
    DIV: out = eteq::div(shape,in[0],in[1]);
    MIN: out = eteq::min(shape,in[0],in[1]);
    MAX: out = eteq::max(shape,in[0],in[1]);
    EQ: out = eteq::eq(shape,in[0],in[1]);
    NEQ: out = eteq::neq(shape,in[0],in[1]);
    LT: out = eteq::lt(shape,in[0],in[1]);
    GT: out = eteq::gt(shape,in[0],in[1]);
    RAND_UNIF: out = eteq::rand_uniform(shape,in[0],in[1]);
    REDUCE_SUM: out = eteq::reduce_sum(shape,in[0]);
    REDUCE_PROD: out = eteq::reduce_prod(shape,in[0]);
    REDUCE_MIN: out = eteq::reduce_min(shape,in[0]);
    REDUCE_MAX: out = eteq::reduce_max(shape,in[0]);
    PERMUTE: out = eteq::permute(shape,in[0]);
    EXTEND: out = eteq::extend(shape,in[0]);
    RESHAPE: out = eteq::reshape(shape,in[0]);
    MATMUL: out = eteq::matmul(shape,in[0],in[1]);
    CONV: out = eteq::convolution(shape,in[0],in[1]);
    SLICE: out = eteq::slice(shape,in[0]);
    PAD: out = eteq::pad(shape,in[0]);
    STRIDE: out = eteq::stride(shape,in[0]);
    SCATTER: out = eteq::scatter(shape,in[0]);
    CONV_IMG_GRAD: out = eteq::convolution_image_grad(shape,in[0],in[1]);
    CONV_KRN_GRAD: out = eteq::convolution_kernel_grad(shape,in[0],in[1]);
    SELECT: out = eteq::select(shape, in[0], in[1], in[2]);
api:
  pybind_type: float
  includes:
  - '"eteq/constant.hpp"'
  - '"eteq/variable.hpp"'
  - '"eteq/functor.hpp"'
  - '"tag/group.hpp"'
  - '"tag/prop.hpp"'
  namespaces:
    tenncor:
      - template: typename T
        name: abs
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"ABS",::egen::ABS},{eteq::identity_map(arg)});
      - template: typename T
        name: neg
        operator: "-"
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"NEG",::egen::NEG},{eteq::identity_map(arg)});
      - template: typename T
        name: sin
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"SIN",::egen::SIN},{eteq::identity_map(arg)});
      - template: typename T
        name: cos
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"COS",::egen::COS},{eteq::identity_map(arg)});
      - template: typename T
        name: tan
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"TAN",::egen::TAN},{eteq::identity_map(arg)});
      - template: typename T
        name: exp
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"EXP",::egen::EXP},{eteq::identity_map(arg)});
      - template: typename T
        name: log
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"LOG",::egen::LOG},{eteq::identity_map(arg)});
      - template: typename T
        name: sqrt
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"SQRT",::egen::SQRT},{eteq::identity_map(arg)});
      - template: typename T
        name: round
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"ROUND",::egen::ROUND},{eteq::identity_map(arg)});
      - template: typename T
        name: sigmoid
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"SIGMOID",::egen::SIGMOID},{eteq::identity_map(arg)});
      - template: typename T
        name: sigmoid_grad
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"SIGMOID_GRAD",::egen::SIGMOID_GRAD},{eteq::identity_map(arg)});
      - template: typename T
        name: tanh
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"TANH",::egen::TANH},{eteq::identity_map(arg)});
      - template: typename T
        name: square
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"SQUARE",::egen::SQUARE},{eteq::identity_map(arg)});
      - template: typename T
        name: cube
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"CUBE",::egen::CUBE},{eteq::identity_map(arg)});
      - template: typename T
        name: pow
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: eteq::NodeptrT<T>
          name: arg2
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"POW",::egen::POW},{eteq::identity_map(arg1),eteq::identity_map(arg2)});
      - template: typename T
        name: pow
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::pow(arg1, eteq::make_constant_scalar<T>(scalar,arg1->shape()));
      - template: typename T
        name: pow
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::NodeptrT<T>
          name: arg1
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::pow(eteq::make_constant_scalar<T>(scalar,arg1->shape()),arg1);
      - template: typename T
        name: add
        operator: +
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: eteq::NodeptrT<T>
          name: arg2
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto out = eteq::make_functor<T>(teq::Opcode{"ADD",::egen::ADD}, {
                      eteq::identity_map(arg1),
                      eteq::identity_map(arg2),
                  });
                  tag::get_property_reg().property_tag(out->get_tensor(), tag::commutative_tag);
                  tag::get_group_reg().group_tag(out->get_tensor(), "sum");
                  return out;
      - template: typename T
        name: add
        operator: +
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::add(arg1,eteq::make_constant_scalar<T>(scalar,arg1->shape()));
      - template: typename T
        name: add
        operator: +
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::NodeptrT<T>
          name: arg1
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::add(eteq::make_constant_scalar<T>(scalar,arg1->shape()),arg1);
      - template: typename T
        name: sub
        operator: "-"
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: eteq::NodeptrT<T>
          name: arg2
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"SUB",::egen::SUB},{eteq::identity_map(arg1),eteq::identity_map(arg2)});
      - template: typename T
        name: sub
        operator: "-"
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::sub(arg1,eteq::make_constant_scalar<T>(scalar,arg1->shape()));
      - template: typename T
        name: sub
        operator: "-"
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::NodeptrT<T>
          name: arg1
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::sub(eteq::make_constant_scalar<T>(scalar,arg1->shape()),arg1);
      - template: typename T
        name: mul
        operator: "*"
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: eteq::NodeptrT<T>
          name: arg2
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto out = eteq::make_functor<T>(teq::Opcode{"MUL",::egen::MUL}, {
                      eteq::identity_map(arg1),
                      eteq::identity_map(arg2),
                  });
                  tag::get_property_reg().property_tag(out->get_tensor(), tag::commutative_tag);
                  tag::get_group_reg().group_tag(out->get_tensor(), "prod");
                  return out;
      - template: typename T
        name: mul
        operator: "*"
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::mul(arg1,eteq::make_constant_scalar<T>(scalar,arg1->shape()));
      - template: typename T
        name: mul
        operator: "*"
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::NodeptrT<T>
          name: arg1
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::mul(eteq::make_constant_scalar<T>(scalar,arg1->shape()),arg1);
      - template: typename T
        name: div
        operator: /
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: eteq::NodeptrT<T>
          name: arg2
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"DIV",::egen::DIV},{eteq::identity_map(arg1),eteq::identity_map(arg2)});
      - template: typename T
        name: div
        operator: /
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::div(arg1,eteq::make_constant_scalar<T>(scalar,arg1->shape()));
      - template: typename T
        name: div
        operator: /
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::NodeptrT<T>
          name: arg1
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::div(eteq::make_constant_scalar<T>(scalar,arg1->shape()),arg1);
      - template: typename T
        name: eq
        operator: ==
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: eteq::NodeptrT<T>
          name: arg2
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto out = eteq::make_functor<T>(teq::Opcode{"EQ",::egen::EQ}, {
                      eteq::identity_map(arg1),
                      eteq::identity_map(arg2),
                  });
                  tag::get_property_reg().property_tag(out->get_tensor(), tag::commutative_tag);
                  return out;
      - template: typename T
        name: eq
        operator: ==
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::eq(arg1,eteq::make_constant_scalar<T>(scalar,arg1->shape()));
      - template: typename T
        name: eq
        operator: ==
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::NodeptrT<T>
          name: arg1
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::eq(eteq::make_constant_scalar<T>(scalar,arg1->shape()),arg1);
      - template: typename T
        name: neq
        operator: "!="
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: eteq::NodeptrT<T>
          name: arg2
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto out = eteq::make_functor<T>(teq::Opcode{"NEQ",::egen::NEQ}, {
                      eteq::identity_map(arg1),
                      eteq::identity_map(arg2),
                  });
                  tag::get_property_reg().property_tag(out->get_tensor(), tag::commutative_tag);
                  return out;
      - template: typename T
        name: neq
        operator: "!="
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::neq(arg1,eteq::make_constant_scalar<T>(scalar,arg1->shape()));
      - template: typename T
        name: neq
        operator: "!="
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::NodeptrT<T>
          name: arg1
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::neq(eteq::make_constant_scalar<T>(scalar,arg1->shape()),arg1);
      - template: typename T
        name: lt
        operator: <
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: eteq::NodeptrT<T>
          name: arg2
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"LT",::egen::LT},{eteq::identity_map(arg1),eteq::identity_map(arg2)});
      - template: typename T
        name: lt
        operator: <
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::lt(arg1,eteq::make_constant_scalar<T>(scalar,arg1->shape()));
      - template: typename T
        name: lt
        operator: <
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::NodeptrT<T>
          name: arg1
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::lt(eteq::make_constant_scalar<T>(scalar,arg1->shape()),arg1);
      - template: typename T
        name: gt
        operator: ">"
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: eteq::NodeptrT<T>
          name: arg2
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"GT",::egen::GT},{eteq::identity_map(arg1),eteq::identity_map(arg2)});
      - template: typename T
        name: gt
        operator: ">"
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::gt(arg1,eteq::make_constant_scalar<T>(scalar,arg1->shape()));
      - template: typename T
        name: gt
        operator: ">"
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::NodeptrT<T>
          name: arg1
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::gt(eteq::make_constant_scalar<T>(scalar,arg1->shape()),arg1);
      - template: typename T
        name: min
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: eteq::NodeptrT<T>
          name: arg2
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto out = eteq::make_functor<T>(teq::Opcode{"MIN",::egen::MIN}, {
                      eteq::identity_map(arg1),
                      eteq::identity_map(arg2),
                  });
                  // todo: tag min with a group?
                  tag::get_property_reg().property_tag(out->get_tensor(), tag::commutative_tag);
                  return out;
      - template: typename T
        name: min
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::min(arg1,eteq::make_constant_scalar<T>(scalar,arg1->shape()));
      - template: typename T
        name: min
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::NodeptrT<T>
          name: arg1
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::min(eteq::make_constant_scalar<T>(scalar,arg1->shape()),arg1);
      - template: typename T
        name: min
        args:
        - dtype: eteq::NodesT<T>
          name: args
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  if (args.empty())
                  {
                      logs::fatal("cannot min without arguments");
                  }
                  eteq::NodeptrT<T> out = args[0];
                  for (size_t i = 1, n = args.size(); i < n; ++i)
                  {
                      out = ::tenncor::min(out, args[i]);
                  }
                  return out;
      - template: typename T
        name: max
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: eteq::NodeptrT<T>
          name: arg2
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto out = eteq::make_functor<T>(teq::Opcode{"MAX",::egen::MAX}, {
                      eteq::identity_map(arg1),
                      eteq::identity_map(arg2),
                  });
                  // todo: tag max with a group?
                  tag::get_property_reg().property_tag(out->get_tensor(), tag::commutative_tag);
                  return out;
      - template: typename T
        name: max
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: T
          name: scalar
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::max(arg1,eteq::make_constant_scalar<T>(scalar,arg1->shape()));
      - template: typename T
        name: max
        args:
        - dtype: T
          name: scalar
        - dtype: eteq::NodeptrT<T>
          name: arg1
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::max(eteq::make_constant_scalar<T>(scalar,arg1->shape()),arg1);
      - template: typename T
        name: max
        args:
        - dtype: eteq::NodesT<T>
          name: args
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  if (args.empty())
                  {
                      logs::fatal("cannot max without arguments");
                  }
                  eteq::NodeptrT<T> out = args[0];
                  for (size_t i = 1, n = args.size(); i < n; ++i)
                  {
                      out = ::tenncor::max(out, args[i]);
                  }
                  return out;
      - template: typename T
        name: if_then_else
        args:
        - dtype: eteq::NodeptrT<T>
          name: condition
        - dtype: eteq::NodeptrT<T>
          name: then
        - dtype: eteq::NodeptrT<T>
          name: otherwise
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  return eteq::make_functor<T>(teq::Opcode{"SELECT",::egen::SELECT},{
                      eteq::identity_map(condition),
                      eteq::identity_map(then),
                      eteq::identity_map(otherwise)
                  });
      - template: typename T
        name: permute
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: std::vector<teq::RankT>
          name: order
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"PERMUTE",::egen::PERMUTE},{eteq::permute_map(arg,order)});
      - template: typename T
        name: extend
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::RankT
          name: offset
        - dtype: std::vector<teq::DimT>
          name: xlist
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"EXTEND",::egen::EXTEND},{eteq::extend_map(arg,offset,xlist)});
      - template: typename T
        name: reshape
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: std::vector<teq::DimT>
          name: slist
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"RESHAPE",::egen::RESHAPE},{eteq::reshape_map(arg,slist)});
      - description: sum values ignoring coordinate indices between start and end
        template: typename T
        name: reduce_sum
        args:
        - dtype: eteq::NodeptrT<T>
          name: tens
        - dtype: teq::RankT
          name: offset
          default: "0"
        - dtype: teq::RankT
          name: ndims
          default: teq::rank_cap
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"REDUCE_SUM",::egen::REDUCE_SUM},{eteq::reduce_map(tens,offset,ndims)});
      - description: multiply values ignoring coordinate indices between start and end
        template: typename T
        name: reduce_prod
        args:
        - dtype: eteq::NodeptrT<T>
          name: tens
        - dtype: teq::RankT
          name: offset
          default: "0"
        - dtype: teq::RankT
          name: ndims
          default: teq::rank_cap
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"REDUCE_PROD",::egen::REDUCE_PROD},{eteq::reduce_map(tens,offset,ndims)});
      - description: min values ignoring coordinate indices between start and end
        template: typename T
        name: reduce_min
        args:
        - dtype: eteq::NodeptrT<T>
          name: tens
        - dtype: teq::RankT
          name: offset
          default: "0"
        - dtype: teq::RankT
          name: ndims
          default: teq::rank_cap
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"REDUCE_MIN",::egen::REDUCE_MIN},{eteq::reduce_map(tens,offset,ndims)});
      - description: max values ignoring coordinate indices between start and end
        template: typename T
        name: reduce_max
        args:
        - dtype: eteq::NodeptrT<T>
          name: tens
        - dtype: teq::RankT
          name: offset
          default: "0"
        - dtype: teq::RankT
          name: ndims
          default: teq::rank_cap
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"REDUCE_MAX",::egen::REDUCE_MAX},{eteq::reduce_map(tens,offset,ndims)});
      - template: typename T
        name: n_elems
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_constant_scalar<T>(arg->get_tensor()->shape().n_elems(), teq::Shape());
      - template: typename T
        name: n_dims
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::RankT
          name: rank
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_constant_scalar<T>(arg->get_tensor()->shape().at(rank), teq::Shape());
      - description: extents vector consists of pairs offset and extent for each dimension
        template: typename T
        name: slice
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: eteq::PairVecT<teq::DimT>
          name: extents
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"SLICE",::egen::SLICE}, {eteq::slice_map<T>(arg, extents)});
      - template: typename T
        name: slice
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::DimT
          name: offset
        - dtype: teq::DimT
          name: extent
        - dtype: teq::RankT
          name: dimension
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  std::vector<std::pair<teq::DimT,teq::DimT>> extents(
                      std::max(teq::rank_cap, dimension),
                      {0,std::numeric_limits<teq::DimT>::max()});
                  extents[dimension] = {offset, extent};
                  return ::tenncor::slice(arg, extents);
      - template: typename T
        name: pad
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: eteq::PairVecT<teq::DimT>
          name: paddings
        out:
          type: eteq::NodeptrT<T>
          val: return eteq::make_functor<T>(teq::Opcode{"PAD",::egen::PAD}, {eteq::pad_map<T>(arg, paddings)});
      - template: typename T
        name: pad
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: std::pair<teq::DimT,teq::DimT>
          name: padding
        - dtype: teq::RankT
          name: dimension
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  std::vector<std::pair<teq::DimT,teq::DimT>> paddings(
                      std::max(teq::rank_cap, dimension), {0,0});
                  paddings[dimension] = padding;
                  return ::tenncor::pad(arg, paddings);
      - template: typename T
        name: stride
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: std::vector<teq::DimT>
          name: incrs
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  return eteq::make_functor<T>(teq::Opcode{"STRIDE",::egen::STRIDE}, {
                      eteq::stride_map(arg, incrs)});
      - template: typename T
        name: matmul
        args:
        - dtype: eteq::NodeptrT<T>
          name: a
        - dtype: eteq::NodeptrT<T>
          name: b
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  teq::Shape ashape = a->get_tensor()->shape();
                  teq::Shape bshape = b->get_tensor()->shape();
                  teq::DimT ncommon = ashape.at(0);
                  teq::DimT nrow = ashape.at(1);
                  teq::DimT ncol = bshape.at(0);
                  if (ncommon != bshape.at(1))
                  {
                      logs::fatalf("invalid matmul shapes %s and %s",
                          ashape.to_string().c_str(), bshape.to_string().c_str());
                  }

                  teq::CoordptrT left_shaper(new teq::CoordMap(
                      [=](teq::MatrixT fwd)
                      {
                          for (teq::RankT i = 3; i < teq::mat_dim; ++i)
                          {
                              fwd[i][i] = 1;
                          }
                          fwd[2][0] = ncol;
                          fwd[1][1] = 1;
                          fwd[0][2] = 1. / ncommon;
                      }
                  ));

                  teq::CoordptrT right_shaper(new teq::CoordMap(
                      [=](teq::MatrixT fwd)
                      {
                          for (teq::RankT i = 3; i < teq::mat_dim; ++i)
                          {
                              fwd[i][i] = 1;
                          }
                          fwd[0][0] = 1;
                          fwd[2][1] = nrow;
                          fwd[1][2] = 1. / ncommon;
                      }
                  ));
                  return eteq::make_functor<T>(teq::Opcode{"MATMUL",::egen::MATMUL}, {
                      eteq::FuncArg<T>(a, left_shaper, nullptr),
                      eteq::FuncArg<T>(b, right_shaper, nullptr)
                  });
      - template: typename T
        name: convolution
        args:
        - dtype: eteq::NodeptrT<T>
          name: input
        - dtype: eteq::NodeptrT<T>
          name: kernel
        - dtype: std::vector<teq::DimT>
          name: dims
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  teq::Shape inshape = input->get_tensor()->shape();
                  teq::Shape kernelshape = kernel->get_tensor()->shape();
                  teq::CoordptrT input_shaper(new teq::CoordMap(
                      [kernelshape](teq::MatrixT fwd)
                      {
                          for (teq::RankT i = 0; i < teq::rank_cap; ++i)
                          {
                              fwd[i][i] = 1;
                          }
                          for (teq::RankT i = 0; i < teq::rank_cap; ++i)
                          {
                              fwd[teq::rank_cap][i] = -kernelshape.at(i) + 1;
                          }
                      }
                  ));

                  teq::CoordptrT kernel_shaper(new teq::CoordMap(
                      [inshape](teq::MatrixT fwd)
                      {
                          for (teq::RankT i = 0; i < teq::rank_cap; ++i)
                          {
                              fwd[i][i] = -1;
                          }
                          for (teq::RankT i = 0; i < teq::rank_cap; ++i)
                          {
                              fwd[teq::rank_cap][i] = inshape.at(i) + 1;
                          }
                      }
                  ));

                  teq::CoordT kernel_dims;
                  auto it = kernel_dims.begin();
                  std::fill(it, kernel_dims.end(), teq::rank_cap);
                  std::copy(dims.begin(), dims.end(), it);
                  return eteq::make_functor<T>(teq::Opcode{"CONV",::egen::CONV}, {
                      eteq::FuncArg<T>(input, input_shaper, nullptr),
                      eteq::FuncArg<T>(kernel, kernel_shaper,
                          std::make_shared<eteq::CoordMap>(kernel_dims, true)),
                  });
      - template: typename T
        name: reduce_sum_1d
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::RankT
          name: dimension
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto red = ::tenncor::reduce_sum(arg, dimension, 1);

                  std::vector<teq::RankT> indices(teq::rank_cap);
                  auto bt = indices.begin();
                  auto it = bt + dimension;
                  std::iota(bt, it, 0);
                  std::iota(it, indices.end(), dimension + 1);
                  indices[teq::rank_cap - 1] = dimension;
                  return ::tenncor::permute(red, indices);
      - template: typename T
        name: reduce_prod_1d
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::RankT
          name: dimension
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto red = ::tenncor::reduce_prod(arg, dimension, 1);

                  std::vector<teq::RankT> indices(teq::rank_cap);
                  auto bt = indices.begin();
                  auto it = bt + dimension;
                  std::iota(bt, it, 0);
                  std::iota(it, indices.end(), dimension + 1);
                  indices[teq::rank_cap - 1] = dimension;
                  return ::tenncor::permute(red, indices);
      - template: typename T
        name: reduce_min_1d
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::RankT
          name: dimension
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto red = ::tenncor::reduce_min(arg, dimension, 1);

                  std::vector<teq::RankT> indices(teq::rank_cap);
                  auto bt = indices.begin();
                  auto it = bt + dimension;
                  std::iota(bt, it, 0);
                  std::iota(it, indices.end(), dimension + 1);
                  indices[teq::rank_cap - 1] = dimension;
                  return ::tenncor::permute(red, indices);
      - template: typename T
        name: reduce_max_1d
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::RankT
          name: dimension
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto red = ::tenncor::reduce_max(arg, dimension, 1);

                  std::vector<teq::RankT> indices(teq::rank_cap);
                  auto bt = indices.begin();
                  auto it = bt + dimension;
                  std::iota(bt, it, 0);
                  std::iota(it, indices.end(), dimension + 1);
                  indices[teq::rank_cap - 1] = dimension;
                  return ::tenncor::permute(red, indices);
      - template: typename T
        name: transpose
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::permute(arg, {1, 0});
      - template: typename T
        name: reduce_mean
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::div(::tenncor::reduce_sum(arg), ::tenncor::n_elems(arg));
      - template: typename T
        name: reduce_mean_1d
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::RankT
          name: dimension
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto red = ::tenncor::reduce_sum_1d(arg, dimension);
                  auto dim = eteq::make_constant_scalar<T>(arg->shape().at(dimension), red->shape());
                  return ::tenncor::div(red, dim);
      - template: typename T
        name: reduce_l2norm
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::RankT
          name: offset
          default: "0"
        - dtype: teq::RankT
          name: ndims
          default: teq::rank_cap
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::sqrt(::tenncor::reduce_sum(::tenncor::square(arg), offset, ndims));
      - template: typename T
        name: reduce_l2norm_1d
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::RankT
          name: dimension
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::sqrt(::tenncor::reduce_sum_1d(::tenncor::square(arg), dimension));
      - template: typename T
        name: clip_by_range
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: T
          name: minval
        - dtype: T
          name: maxval
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  if (minval > maxval)
                  {
                      logs::fatal("min value is below max");
                  }
                  teq::Shape shape = arg->shape();
                  auto lo = eteq::make_constant_scalar<T>(minval, shape);
                  auto hi = eteq::make_constant_scalar<T>(maxval, shape);
                  auto out = ::tenncor::max(::tenncor::min(arg, hi), lo);
                  tag::recursive_group_tag(out->get_tensor(), "clip_by_range", {
                      arg->get_tensor().get(),
                      lo->get_tensor().get(),
                      hi->get_tensor().get(),
                  });
                  return out;
      - description: clip by l2norm
        template: typename T
        name: clip_by_l2norm
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: T
          name: upper
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  // todo: allow l2norm offset and ndims to be configurable
                  if (upper == 0)
                  {
                      logs::fatal("cannot clip_by_norm with a upper limit of 0");
                  }
                  teq::Shape shape = arg->shape();
                  auto limit = eteq::make_constant_scalar<T>(upper, shape);
                  auto norm = ::tenncor::extend(::tenncor::reduce_l2norm(arg), 0,
                      std::vector<teq::DimT>(shape.begin(), shape.end()));
                  auto out = ::tenncor::if_then_else(::tenncor::lt(norm, limit),
                      arg, ::tenncor::div(::tenncor::mul(arg, limit), norm));
                  tag::recursive_group_tag(out->get_tensor(), "clip_by_l2norm", {
                      arg->get_tensor().get(),
                      limit->get_tensor().get(),
                  });
                  return out;
      - template: typename T
        name: sum
        args:
        - dtype: eteq::NodesT<T>
          name: args
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  if (args.empty())
                  {
                      logs::fatal("cannot sum without arguments");
                  }
                  eteq::NodeptrT<T> out = args[0];
                  for (size_t i = 1, n = args.size(); i < n; ++i)
                  {
                      out = ::tenncor::add(out, args[i]);
                  }
                  return out;
      - template: typename T
        name: prod
        args:
        - dtype: eteq::NodesT<T>
          name: args
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  if (args.empty())
                  {
                      logs::fatal("cannot sum without arguments");
                  }
                  eteq::NodeptrT<T> out = args[0];
                  for (size_t i = 1, n = args.size(); i < n; ++i)
                  {
                      out = ::tenncor::mul(out, args[i]);
                  }
                  return out;
      - template: typename T
        name: softmax
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: teq::RankT
          name: offset
          default: "0"
        - dtype: teq::RankT
          name: ndims
          default: teq::rank_cap
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  if (offset + ndims > teq::rank_cap)
                  {
                      logs::fatalf("cannot perform softmax on dimensions beyond %d",
                          teq::rank_cap);
                  }
                  auto exarg = exp(arg);
                  teq::Shape shape = exarg->shape();
                  auto it = shape.begin() + offset;
                  std::vector<teq::DimT> xlist(it, it + ndims);
                  auto out = ::tenncor::div(exarg,
                      ::tenncor::extend(::tenncor::reduce_sum(exarg, offset, ndims),
                      offset, xlist));
                  tag::recursive_group_tag(out->get_tensor(), "softmax", {
                      arg->get_tensor().get()});
                  return out;
      - template: typename T
        name: relu
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  auto out = ::tenncor::log(::tenncor::add((T) 1, ::tenncor::exp(arg)));
                  tag::recursive_group_tag(out->get_tensor(), "relu", {
                      arg->get_tensor().get()});
                  return out;
      - template: typename T
        name: sign
        args:
        - dtype: eteq::NodeptrT<T>
          name: x
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::pow(x,eteq::make_constant_scalar<T>(0,x->shape()));
    tenncor::random:
      - template: typename T
        name: rand_unif
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg1
        - dtype: eteq::NodeptrT<T>
          name: arg2
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  return eteq::make_functor<T>(
                      teq::Opcode{"RAND_UNIF",::egen::RAND_UNIF},{
                          eteq::identity_map(arg1),
                          eteq::identity_map(arg2)
                      });
      - template: typename T
        name: rand_binom_one
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  const teq::Shape& shape = arg->get_tensor()->shape();
                  auto trial = ::tenncor::random::rand_unif(
                      eteq::convert_to_node(eteq::make_variable_scalar<T>((T) 0, shape)),
                      eteq::convert_to_node(eteq::make_variable_scalar<T>((T) 1, shape)));
                  return ::tenncor::lt(trial, arg);
    tenncor::nn:
      - template: typename T
        name: relu
        args:
        - dtype: eteq::NodeptrT<T>
          name: x
        out:
          type: eteq::NodeptrT<T>
          val: return ::tenncor::max(x,eteq::make_constant_scalar<T>(0,x->shape()));
      - template: typename T
        name: fully_connect
        args:
        - dtype: eteq::NodesT<T>
          name: inputs
        - dtype: eteq::NodesT<T>
          name: weights
        - dtype: eteq::NodeptrT<T>
          name: bias
          check_null: false
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  if (weights.empty())
                  {
                      logs::fatal("cannot create a fully connected layer without weights");
                  }
                  size_t ninputs = inputs.size();
                  if (ninputs != weights.size())
                  {
                      logs::fatalf(
                          "number of inputs (%d) must equal the number of weights (%d)",
                          ninputs, weights.size());
                  }
                  teq::TensSetT ignores = {
                      inputs[0]->get_tensor().get(),
                      weights[0]->get_tensor().get()
                  };
                  auto out = ::tenncor::matmul(inputs[0], weights[0]);
                  for (size_t i = 1; i < ninputs; ++i)
                  {
                      ignores.emplace(inputs[i]->get_tensor().get());
                      ignores.emplace(weights[i]->get_tensor().get());
                      out = ::tenncor::add(out, ::tenncor::matmul(inputs[i], weights[i]));
                  }
                  if (nullptr != bias)
                  {
                      const teq::Shape& shape = out->shape();
                      out = ::tenncor::add(out, ::tenncor::extend(bias, 1, {shape.at(1)}));
                      ignores.emplace(bias->get_tensor().get());
                  }
                  tag::recursive_group_tag(out->get_tensor(), "fully_connect", ignores);
                  return out;
      - template: typename T
        name: conv2d
        args:
        - dtype: eteq::NodeptrT<T>
          name: image
        - dtype: eteq::NodeptrT<T>
          name: kernel
        - dtype: std::pair<teq::DimT,teq::DimT>
          name: zero_padding
          default: "std::pair<teq::DimT,teq::DimT>{0,0}"
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  // image must be in form [in, width, height, batch]
                  // kernel must be in form [out, in, width, height]
                  // expect output shape of [
                  //    out,
                  //    image.width-kernel.width+1+2*zero_padding.first,
                  //    image.height-kernel.height+1+2*zero_padding.second,
                  //    batch,
                  // ]
                  // zero_padding apply symmetrical padding for dimensions 1 and 2 to image before convolution
                  // see https://www.tensorflow.org/api_docs/python/tf/nn/conv2d
                  teq::DimT nfilters = kernel->shape().at(0); // out
                  eteq::NodesT<T> convolveds;
                  convolveds.reserve(nfilters);
                  if (zero_padding.first > 0 || zero_padding.second > 0)
                  {
                      image = ::tenncor::pad(image, {{0, 0},
                          {zero_padding.first, zero_padding.first},
                          {zero_padding.second, zero_padding.second}});
                  }
                  for (teq::DimT i = 0; i < nfilters; ++i)
                  {
                      auto filter = ::tenncor::permute(
                          ::tenncor::slice(kernel, i, 1, 0), // [1, in, width, height]
                          {1, 2, 3, 0}); // [in, width, height, 1]
                      auto conved = ::tenncor::convolution(image, filter,
                          {0, 1, 2}); // [1, image.width-kernel.width+1, image.height-kernel.height+1, batch]
                      auto padded = ::tenncor::pad(conved,
                          {i, nfilters - i - 1}, 0); // outshape
                      convolveds.push_back(padded);
                  }
                  auto out = ::tenncor::sum(convolveds);
                  tag::recursive_group_tag(out->get_tensor(), "conv2d", {
                      image->get_tensor().get(),
                      kernel->get_tensor().get()
                  });
                  return out;
      - template: typename T
        name: mean_pool2d
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: std::pair<teq::RankT,teq::RankT>
          name: dims
          default: "std::pair<teq::RankT,teq::RankT>{0, 1}"
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  teq::DimT xextent = arg->shape().at(dims.first) - 1;
                  teq::DimT yextent = arg->shape().at(dims.second) - 1;
                  std::vector<teq::DimT> strider(teq::rank_cap, 1);
                  strider[dims.first] = strider[dims.second] = 2;
                  auto top_left = ::tenncor::stride(arg, strider);
                  auto top_right = ::tenncor::stride(
                      ::tenncor::slice(arg, 1, xextent, dims.first), strider);
                  auto bot_left = ::tenncor::stride(
                      ::tenncor::slice(arg, 1, yextent, dims.second), strider);
                  eteq::PairVecT<teq::DimT> pvec(teq::rank_cap,
                      {0, std::numeric_limits<teq::DimT>::max()});
                  pvec[dims.first] = {1, xextent};
                  pvec[dims.second] = {1, yextent};
                  auto bot_right = ::tenncor::stride(
                      ::tenncor::slice(arg, pvec), strider);

                  // todo: tag this maybe?
                  return ::tenncor::div(::tenncor::sum(eteq::NodesT<T>{
                      top_left, top_right, bot_left, bot_right}), (T) 4);
      - template: typename T
        name: max_pool2d
        args:
        - dtype: eteq::NodeptrT<T>
          name: arg
        - dtype: std::pair<teq::RankT,teq::RankT>
          name: dims
          default: "std::pair<teq::RankT,teq::RankT>{0, 1}"
        out:
          type: eteq::NodeptrT<T>
          val: |
              //
                  teq::DimT xextent = arg->shape().at(dims.first) - 1;
                  teq::DimT yextent = arg->shape().at(dims.second) - 1;
                  std::vector<teq::DimT> strider(teq::rank_cap, 1);
                  strider[dims.first] = strider[dims.second] = 2;
                  auto top_left = ::tenncor::stride(arg, strider);
                  auto top_right = ::tenncor::stride(
                      ::tenncor::slice(arg, 1, xextent, dims.first), strider);
                  auto bot_left = ::tenncor::stride(
                      ::tenncor::slice(arg, 1, yextent, dims.second), strider);
                  eteq::PairVecT<teq::DimT> pvec(teq::rank_cap,
                      {0, std::numeric_limits<teq::DimT>::max()});
                  pvec[dims.first] = {1, xextent};
                  pvec[dims.second] = {1, yextent};
                  auto bot_right = ::tenncor::stride(
                      ::tenncor::slice(arg, pvec), strider);

                  // todo: tag this maybe?
                  return ::tenncor::max(eteq::NodesT<T>{
                      top_left, top_right, bot_left, bot_right});

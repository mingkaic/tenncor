api:
  pybind_type: float
  includes:
  - '"tenncor/eteq.hpp"'
  - '"tenncor/layr.hpp"'
  nullcheck_type:
    - teq::TensptrT
    - eteq::ETensor
  pyignore_type:
    - float
    - SUPPORTED_TYPE
    - teq::RankT
    - teq::DimT
    - eigen::PairVecT<teq::RankT>
    - eteq::DimPairsT
    - eteq::EVariable<T>
    - eteq::ETensorsT
    - eteq::EVariablesT<T>
    - layr::UnaryF
    - layr::ShapeFactorF
    - layr::InitF<T>
    - std::set<teq::RankT>
    - std::vector<teq::DimT>
    - std::pair<eteq::DimPairsT,eteq::DimPairsT>
  pybind_includes:
  - '"python/tenncor.hpp"'
  pybind_module: tenncor
  pyglobal:
    - name: api
      type: TenncorAPI
      decl: |
          //
              static TenncorAPI global(global::context());
              return global;
  funcs:
    - description: Get global tenncor api instance
      name: tenncor
      out:
        type: TenncorAPI&
        val: |
            //
                static TenncorAPI api;
                return api;
      pyignores: True
    - description: Negation operator with output ETensor using the same context as the input
      operator: "-"
      args:
      - type: const eteq::ETensor&
        name: arg
      out:
        type: eteq::ETensor
        val: return TenncorAPI(arg.get_context()).neg(arg);
    - description: Addition operator with output ETensor using the same context as the left input
      operator: +
      args:
      - type: const eteq::ETensor&
        name: a
      - type: const eteq::ETensor&
        name: b
      out:
        type: eteq::ETensor
        val: return TenncorAPI(a.get_context()).add(a,b);
    - support_type: SUPPORTED_TYPE
      description: Addition operator with output ETensor using the same context as the tensor input
      operator: +
      args:
      - type: const eteq::ETensor&
        name: arg
      - type: SUPPORTED_TYPE
        name: scalar
      out:
        type: eteq::ETensor
        val: return TenncorAPI(arg.get_context()).add(arg,scalar);
    - support_type: SUPPORTED_TYPE
      description: Addition operator with output ETensor using the same context as the tensor input
      operator: +
      args:
      - type: SUPPORTED_TYPE
        name: scalar
      - type: const eteq::ETensor&
        name: arg
      out:
        type: eteq::ETensor
        val: return TenncorAPI(arg.get_context()).add(scalar,arg);
    - description: Subtraction operator with output ETensor using the same context as the left input
      operator: "-"
      args:
      - type: const eteq::ETensor&
        name: a
      - type: const eteq::ETensor&
        name: b
      out:
        type: eteq::ETensor
        val: return TenncorAPI(a.get_context()).sub(a,b);
    - support_type: SUPPORTED_TYPE
      description: Subtraction operator with output ETensor using the same context as the tensor input
      operator: "-"
      args:
      - type: const eteq::ETensor&
        name: arg
      - type: SUPPORTED_TYPE
        name: scalar
      out:
        type: eteq::ETensor
        val: return TenncorAPI(arg.get_context()).sub(arg,scalar);
    - support_type: SUPPORTED_TYPE
      description: Subtraction operator with output ETensor using the same context as the tensor input
      operator: "-"
      args:
      - type: SUPPORTED_TYPE
        name: scalar
      - type: const eteq::ETensor&
        name: arg
      out:
        type: eteq::ETensor
        val: return TenncorAPI(arg.get_context()).sub(scalar,arg);
    - description: Multiplication operator with output ETensor using the same context as the left input
      operator: "*"
      args:
      - type: const eteq::ETensor&
        name: a
      - type: const eteq::ETensor&
        name: b
      out:
        type: eteq::ETensor
        val: return TenncorAPI(a.get_context()).mul(a,b);
    - support_type: SUPPORTED_TYPE
      description: Multiplication operator with output ETensor using the same context as the tensor input
      operator: "*"
      args:
      - type: const eteq::ETensor&
        name: arg
      - type: SUPPORTED_TYPE
        name: scalar
      out:
        type: eteq::ETensor
        val: return TenncorAPI(arg.get_context()).mul(arg,scalar);
    - support_type: SUPPORTED_TYPE
      description: Multiplication operator with output ETensor using the same context as the tensor input
      operator: "*"
      args:
      - type: SUPPORTED_TYPE
        name: scalar
      - type: const eteq::ETensor&
        name: arg
      out:
        type: eteq::ETensor
        val: return TenncorAPI(arg.get_context()).mul(scalar,arg);
    - description: Division operator with output ETensor using the same context as the left input
      operator: /
      args:
      - type: const eteq::ETensor&
        name: a
      - type: const eteq::ETensor&
        name: b
      out:
        type: eteq::ETensor
        val: return TenncorAPI(a.get_context()).div(a,b);
    - support_type: SUPPORTED_TYPE
      description: Division operator with output ETensor using the same context as the tensor input
      operator: /
      args:
      - type: const eteq::ETensor&
        name: arg
      - type: SUPPORTED_TYPE
        name: scalar
      out:
        type: eteq::ETensor
        val: return TenncorAPI(arg.get_context()).div(arg,scalar);
    - support_type: SUPPORTED_TYPE
      description: Division operator with output ETensor using the same context as the tensor input
      operator: /
      args:
      - type: SUPPORTED_TYPE
        name: scalar
      - type: const eteq::ETensor&
        name: arg
      out:
        type: eteq::ETensor
        val: return TenncorAPI(arg.get_context()).div(scalar,arg);
    - description: Equality operator with output ETensor using the same context as the left input
      operator: ==
      args:
      - type: const eteq::ETensor&
        name: a
      - type: const eteq::ETensor&
        name: b
      out:
        type: eteq::ETensor
        val: return TenncorAPI(a.get_context()).eq(a,b);
    - support_type: SUPPORTED_TYPE
      description: Equality operator with output ETensor using the same context as the tensor input
      operator: ==
      args:
      - type: const eteq::ETensor&
        name: arg
      - type: SUPPORTED_TYPE
        name: scalar
      out:
        type: eteq::ETensor
        val: return TenncorAPI(arg.get_context()).eq(arg,scalar);
    - support_type: SUPPORTED_TYPE
      description: Equality operator with output ETensor using the same context as the tensor input
      operator: ==
      args:
      - type: SUPPORTED_TYPE
        name: scalar
      - type: const eteq::ETensor&
        name: arg
      out:
        type: eteq::ETensor
        val: return TenncorAPI(arg.get_context()).eq(scalar,arg);
    - description: Inequality operator with output ETensor using the same context as the left input
      operator: "!="
      args:
      - type: const eteq::ETensor&
        name: a
      - type: const eteq::ETensor&
        name: b
      out:
        type: eteq::ETensor
        val: return TenncorAPI(a.get_context()).neq(a,b);
    - support_type: SUPPORTED_TYPE
      description: Inequality operator with output ETensor using the same context as the tensor input
      operator: "!="
      args:
      - type: const eteq::ETensor&
        name: arg
      - type: SUPPORTED_TYPE
        name: scalar
      out:
        type: eteq::ETensor
        val: return TenncorAPI(arg.get_context()).neq(arg,scalar);
    - support_type: SUPPORTED_TYPE
      description: Inequality operator with output ETensor using the same context as the tensor input
      operator: "!="
      args:
      - type: SUPPORTED_TYPE
        name: scalar
      - type: const eteq::ETensor&
        name: arg
      out:
        type: eteq::ETensor
        val: return TenncorAPI(arg.get_context()).neq(scalar,arg);
    - description: Lesser than operator with output ETensor using the same context as the left input
      operator: <
      args:
      - type: const eteq::ETensor&
        name: a
      - type: const eteq::ETensor&
        name: b
      out:
        type: eteq::ETensor
        val: return TenncorAPI(a.get_context()).lt(a,b);
    - support_type: SUPPORTED_TYPE
      description: Lesser than operator with output ETensor using the same context as the tensor input
      operator: <
      args:
      - type: const eteq::ETensor&
        name: arg
      - type: SUPPORTED_TYPE
        name: scalar
      out:
        type: eteq::ETensor
        val: return TenncorAPI(arg.get_context()).lt(arg,scalar);
    - support_type: SUPPORTED_TYPE
      description: Lesser than operator with output ETensor using the same context as the tensor input
      operator: <
      args:
      - type: SUPPORTED_TYPE
        name: scalar
      - type: const eteq::ETensor&
        name: arg
      out:
        type: eteq::ETensor
        val: return TenncorAPI(arg.get_context()).lt(scalar,arg);
    - description: Greater than operator with output ETensor using the same context as the left input
      operator: ">"
      args:
      - type: const eteq::ETensor&
        name: a
      - type: const eteq::ETensor&
        name: b
      out:
        type: eteq::ETensor
        val: return TenncorAPI(a.get_context()).gt(a,b);
    - support_type: SUPPORTED_TYPE
      description: Greater than operator with output ETensor using the same context as the tensor input
      operator: ">"
      args:
      - type: const eteq::ETensor&
        name: arg
      - type: SUPPORTED_TYPE
        name: scalar
      out:
        type: eteq::ETensor
        val: return TenncorAPI(arg.get_context()).gt(arg,scalar);
    - support_type: SUPPORTED_TYPE
      description: Greater than operator with output ETensor using the same context as the tensor input
      operator: ">"
      args:
      - type: SUPPORTED_TYPE
        name: scalar
      - type: const eteq::ETensor&
        name: arg
      out:
        type: eteq::ETensor
        val: return TenncorAPI(arg.get_context()).gt(scalar,arg);
  classes:
    - requires:
        - ApproxAPI
        - ErrorAPI
        - LayerAPI
        - NnAPI
        - RandomAPI
      name: TenncorAPI
      init:
        args:
          - name: context
            type: global::CfgMapptrT
            default: global::context()
        initlist:
          random: this
          nn: this
          layer: this
          error: this
          approx: this
          ctx: context
      copy:
        other: other
        initlist:
          random: this
          nn: this
          layer: this
          error: this
          approx: this
          ctx: other.ctx
        do: |
          //
              if (&other != this)
              {
                  this->ctx = other.ctx;
                  this->random = RandomAPI(this);
                  this->nn = NnAPI(this);
                  this->layer = LayerAPI(this);
                  this->error = ErrorAPI(this);
                  this->approx = ApproxAPI(this);
              }
      move:
        other: other
        initlist:
          random: this
          nn: this
          layer: this
          error: this
          approx: this
          ctx: other.ctx
        do: |
          //
              if (&other != this)
              {
                  this->ctx = other.ctx;
                  this->random = RandomAPI(this);
                  this->nn = NnAPI(this);
                  this->layer = LayerAPI(this);
                  this->error = ErrorAPI(this);
                  this->approx = ApproxAPI(this);
              }
      members:
        - name: ctx
          type: global::CfgMapptrT
          public: True
        - name: random
          type: RandomAPI
          public: True
        - name: nn
          type: NnAPI
          public: True
        - name: layer
          type: LayerAPI
          public: True
        - name: error
          type: ErrorAPI
          public: True
        - name: approx
          type: ApproxAPI
          public: True
      funcs:
        - python_only: True
          description: Return a node that casts arg to specified dtype
          name: cast
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: egen::_GENERATED_DTYPE
            name: dtype
          out:
            type: eteq::ETensor
            val: |
                //
                    eteq::ETensor out;
                #define _CHOOSE_CAST(REALTYPE)out = self.cast<REALTYPE>(out);
                    TYPE_LOOKUP(_CHOOSE_CAST, dtype);
                #undef _CHOOSE_CAST
                    return out;
        - nopython: True
          template: typename T
          name: cast
          description: Return a node that casts arg to specified template.
          args:
          - type: const eteq::ETensor&
            name: arg
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_tfunctor<T>(::egen::CAST,teq::TensptrsT{arg},egen::get_type<T>()),ctx);
        - template: typename T
          name: assign
          args:
          - type: const eteq::EVariable<T>&
            name: target
          - type: const eteq::ETensor&
            name: source
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::ASSIGN,teq::TensptrsT{target,source}),ctx);
        - template: typename T
          name: assign_add
          args:
          - type: const eteq::EVariable<T>&
            name: target
          - type: const eteq::ETensor&
            name: source
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::ASSIGN_ADD,teq::TensptrsT{target,source}),ctx);
        - template: typename T
          name: assign_sub
          args:
          - type: const eteq::EVariable<T>&
            name: target
          - type: const eteq::ETensor&
            name: source
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::ASSIGN_SUB,teq::TensptrsT{target,source}),ctx);
        - template: typename T
          name: assign_mul
          args:
          - type: const eteq::EVariable<T>&
            name: target
          - type: const eteq::ETensor&
            name: source
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::ASSIGN_MUL,teq::TensptrsT{target,source}),ctx);
        - template: typename T
          name: assign_div
          args:
          - type: const eteq::EVariable<T>&
            name: target
          - type: const eteq::ETensor&
            name: source
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::ASSIGN_DIV,teq::TensptrsT{target,source}),ctx);
        - name: identity
          description: |
                      Return a node that takes on the reference of arg except any additional arguments are just operational dependencies.
                      Operational dependencies are calculated at the same time as arg.
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: const eteq::ETensorsT&
            name: execute_in_parallel
            default: eteq::ETensorsT()
          out:
            type: eteq::ETensor
            val: |
                //
                    teq::TensptrsT args = {arg};
                    args.insert(args.end(), execute_in_parallel.begin(), execute_in_parallel.end());
                    return eteq::ETensor(eteq::make_functor(::egen::IDENTITY,args),ctx);
        - name: abs
          args:
          - type: const eteq::ETensor&
            name: arg
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::ABS,teq::TensptrsT{arg}),ctx);
        - name: neg
          args:
          - type: const eteq::ETensor&
            name: arg
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::NEG,teq::TensptrsT{arg}),ctx);
        - name: sin
          args:
          - type: const eteq::ETensor&
            name: arg
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::SIN,teq::TensptrsT{arg}),ctx);
        - name: cos
          args:
          - type: const eteq::ETensor&
            name: arg
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::COS,teq::TensptrsT{arg}),ctx);
        - name: tan
          args:
          - type: const eteq::ETensor&
            name: arg
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::TAN,teq::TensptrsT{arg}),ctx);
        - name: exp
          args:
          - type: const eteq::ETensor&
            name: arg
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::EXP,teq::TensptrsT{arg}),ctx);
        - name: log
          args:
          - type: const eteq::ETensor&
            name: arg
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::LOG,teq::TensptrsT{arg}),ctx);
        - name: sqrt
          args:
          - type: const eteq::ETensor&
            name: arg
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::SQRT,teq::TensptrsT{arg}),ctx);
        - name: round
          args:
          - type: const eteq::ETensor&
            name: arg
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::ROUND,teq::TensptrsT{arg}),ctx);
        - name: sigmoid
          args:
          - type: const eteq::ETensor&
            name: arg
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::SIGMOID,teq::TensptrsT{arg}),ctx);
        - name: tanh
          args:
          - type: const eteq::ETensor&
            name: arg
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::TANH,teq::TensptrsT{arg}),ctx);
        - name: square
          args:
          - type: const eteq::ETensor&
            name: arg
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::SQUARE,teq::TensptrsT{arg}),ctx);
        - name: cube
          args:
          - type: const eteq::ETensor&
            name: arg
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::CUBE,teq::TensptrsT{arg}),ctx);
        - name: pow
          args:
          - type: const eteq::ETensor&
            name: a
          - type: const eteq::ETensor&
            name: b
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::POW,teq::TensptrsT{a,b}),ctx);
        - support_type: SUPPORTED_TYPE
          name: pow
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: SUPPORTED_TYPE
            name: scalar
          out:
            type: eteq::ETensor
            val: return this->pow(arg,eteq::make_constant_like_uncast<SUPPORTED_TYPE>(scalar,arg,ctx));
        - support_type: SUPPORTED_TYPE
          name: pow
          args:
          - type: SUPPORTED_TYPE
            name: scalar
          - type: const eteq::ETensor&
            name: arg
          out:
            type: eteq::ETensor
            val: return this->pow(eteq::make_constant_like_uncast<SUPPORTED_TYPE>(scalar,arg,ctx),arg);
        - name: add
          args:
          - type: const eteq::ETensor&
            name: a
          - type: const eteq::ETensor&
            name: b
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::ADD,teq::TensptrsT{a,b}),ctx);
        - support_type: SUPPORTED_TYPE
          name: add
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: SUPPORTED_TYPE
            name: scalar
          out:
            type: eteq::ETensor
            val: return this->add(arg,eteq::make_constant_like_uncast<SUPPORTED_TYPE>(scalar,arg,ctx));
        - support_type: SUPPORTED_TYPE
          name: add
          args:
          - type: SUPPORTED_TYPE
            name: scalar
          - type: const eteq::ETensor&
            name: arg
          out:
            type: eteq::ETensor
            val: return this->add(eteq::make_constant_like_uncast<SUPPORTED_TYPE>(scalar,arg,ctx),arg);
        - name: sub
          args:
          - type: const eteq::ETensor&
            name: a
          - type: const eteq::ETensor&
            name: b
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::SUB,teq::TensptrsT{a,b}),ctx);
        - support_type: SUPPORTED_TYPE
          name: sub
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: SUPPORTED_TYPE
            name: scalar
          out:
            type: eteq::ETensor
            val: return this->sub(arg,eteq::make_constant_like_uncast<SUPPORTED_TYPE>(scalar,arg,ctx));
        - support_type: SUPPORTED_TYPE
          name: sub
          args:
          - type: SUPPORTED_TYPE
            name: scalar
          - type: const eteq::ETensor&
            name: arg
          out:
            type: eteq::ETensor
            val: return this->sub(eteq::make_constant_like_uncast<SUPPORTED_TYPE>(scalar,arg,ctx),arg);
        - name: mul
          args:
          - type: const eteq::ETensor&
            name: a
          - type: const eteq::ETensor&
            name: b
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::MUL,teq::TensptrsT{a,b}),ctx);
        - support_type: SUPPORTED_TYPE
          name: mul
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: SUPPORTED_TYPE
            name: scalar
          out:
            type: eteq::ETensor
            val: return this->mul(arg,eteq::make_constant_like_uncast<SUPPORTED_TYPE>(scalar,arg,ctx));
        - support_type: SUPPORTED_TYPE
          name: mul
          args:
          - type: SUPPORTED_TYPE
            name: scalar
          - type: const eteq::ETensor&
            name: arg
          out:
            type: eteq::ETensor
            val: return this->mul(eteq::make_constant_like_uncast<SUPPORTED_TYPE>(scalar,arg,ctx),arg);
        - name: div
          args:
          - type: const eteq::ETensor&
            name: a
          - type: const eteq::ETensor&
            name: b
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::DIV,teq::TensptrsT{a,b}),ctx);
        - support_type: SUPPORTED_TYPE
          name: div
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: SUPPORTED_TYPE
            name: scalar
          out:
            type: eteq::ETensor
            val: return this->div(arg,eteq::make_constant_like_uncast<SUPPORTED_TYPE>(scalar,arg,ctx));
        - support_type: SUPPORTED_TYPE
          name: div
          args:
          - type: SUPPORTED_TYPE
            name: scalar
          - type: const eteq::ETensor&
            name: arg
          out:
            type: eteq::ETensor
            val: return this->div(eteq::make_constant_like_uncast<SUPPORTED_TYPE>(scalar,arg,ctx),arg);
        - name: eq
          args:
          - type: const eteq::ETensor&
            name: a
          - type: const eteq::ETensor&
            name: b
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::EQ,teq::TensptrsT{a,b}),ctx);
        - support_type: SUPPORTED_TYPE
          name: eq
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: SUPPORTED_TYPE
            name: scalar
          out:
            type: eteq::ETensor
            val: return this->eq(arg,eteq::make_constant_like_uncast<SUPPORTED_TYPE>(scalar,arg,ctx));
        - support_type: SUPPORTED_TYPE
          name: eq
          args:
          - type: SUPPORTED_TYPE
            name: scalar
          - type: const eteq::ETensor&
            name: arg
          out:
            type: eteq::ETensor
            val: return this->eq(eteq::make_constant_like_uncast<SUPPORTED_TYPE>(scalar,arg,ctx),arg);
        - name: neq
          args:
          - type: const eteq::ETensor&
            name: a
          - type: const eteq::ETensor&
            name: b
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::NEQ,teq::TensptrsT{a,b}),ctx);
        - support_type: SUPPORTED_TYPE
          name: neq
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: SUPPORTED_TYPE
            name: scalar
          out:
            type: eteq::ETensor
            val: return this->neq(arg,eteq::make_constant_like_uncast<SUPPORTED_TYPE>(scalar,arg,ctx));
        - support_type: SUPPORTED_TYPE
          name: neq
          args:
          - type: SUPPORTED_TYPE
            name: scalar
          - type: const eteq::ETensor&
            name: arg
          out:
            type: eteq::ETensor
            val: return this->neq(eteq::make_constant_like_uncast<SUPPORTED_TYPE>(scalar,arg,ctx),arg);
        - name: lt
          args:
          - type: const eteq::ETensor&
            name: a
          - type: const eteq::ETensor&
            name: b
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::LT,teq::TensptrsT{a,b}),ctx);
        - support_type: SUPPORTED_TYPE
          name: lt
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: SUPPORTED_TYPE
            name: scalar
          out:
            type: eteq::ETensor
            val: return this->lt(arg,eteq::make_constant_like_uncast<SUPPORTED_TYPE>(scalar,arg,ctx));
        - support_type: SUPPORTED_TYPE
          name: lt
          args:
          - type: SUPPORTED_TYPE
            name: scalar
          - type: const eteq::ETensor&
            name: arg
          out:
            type: eteq::ETensor
            val: return this->lt(eteq::make_constant_like_uncast<SUPPORTED_TYPE>(scalar,arg,ctx),arg);
        - name: gt
          args:
          - type: const eteq::ETensor&
            name: a
          - type: const eteq::ETensor&
            name: b
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::GT,teq::TensptrsT{a,b}),ctx);
        - support_type: SUPPORTED_TYPE
          name: gt
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: SUPPORTED_TYPE
            name: scalar
          out:
            type: eteq::ETensor
            val: return this->gt(arg,eteq::make_constant_like_uncast<SUPPORTED_TYPE>(scalar,arg,ctx));
        - support_type: SUPPORTED_TYPE
          name: gt
          args:
          - type: SUPPORTED_TYPE
            name: scalar
          - type: const eteq::ETensor&
            name: arg
          out:
            type: eteq::ETensor
            val: return this->gt(eteq::make_constant_like_uncast<SUPPORTED_TYPE>(scalar,arg,ctx),arg);
        - name: min
          args:
          - type: const eteq::ETensor&
            name: a
          - type: const eteq::ETensor&
            name: b
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::MIN,teq::TensptrsT{a,b}),ctx);
        - support_type: SUPPORTED_TYPE
          name: min
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: SUPPORTED_TYPE
            name: scalar
          out:
            type: eteq::ETensor
            val: return this->min(arg,eteq::make_constant_like_uncast<SUPPORTED_TYPE>(scalar,arg,ctx));
        - support_type: SUPPORTED_TYPE
          name: min
          args:
          - type: SUPPORTED_TYPE
            name: scalar
          - type: const eteq::ETensor&
            name: arg
          out:
            type: eteq::ETensor
            val: return this->min(eteq::make_constant_like_uncast<SUPPORTED_TYPE>(scalar,arg,ctx),arg);
        - name: min
          args:
          - type: const eteq::ETensorsT&
            name: args
          out:
            type: eteq::ETensor
            val: |
                //
                    if (args.empty())
                    {
                        global::fatal("cannot min without arguments");
                    }
                    eteq::ETensor out = args[0];
                    for (size_t i = 1,n = args.size(); i < n; ++i)
                    {
                        out = this->min(out,args[i]);
                    }
                    return out;
        - name: max
          args:
          - type: const eteq::ETensor&
            name: a
          - type: const eteq::ETensor&
            name: b
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::MAX,teq::TensptrsT{a,b}),ctx);
        - support_type: SUPPORTED_TYPE
          name: max
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: SUPPORTED_TYPE
            name: scalar
          out:
            type: eteq::ETensor
            val: return this->max(arg,eteq::make_constant_like_uncast<SUPPORTED_TYPE>(scalar,arg,ctx));
        - support_type: SUPPORTED_TYPE
          name: max
          args:
          - type: SUPPORTED_TYPE
            name: scalar
          - type: const eteq::ETensor&
            name: arg
          out:
            type: eteq::ETensor
            val: return this->max(eteq::make_constant_like_uncast<SUPPORTED_TYPE>(scalar,arg,ctx),arg);
        - name: max
          args:
          - type: const eteq::ETensorsT&
            name: args
          out:
            type: eteq::ETensor
            val: |
                //
                    if (args.empty())
                    {
                        global::fatal("cannot max without arguments");
                    }
                    eteq::ETensor out = args[0];
                    for (size_t i = 1,n = args.size(); i < n; ++i)
                    {
                        out = this->max(out,args[i]);
                    }
                    return out;
        - name: if_then_else
          args:
          - type: const eteq::ETensor&
            name: condition
          - type: const eteq::ETensor&
            name: then
          - type: const eteq::ETensor&
            name: otherwise
          out:
            type: eteq::ETensor
            val: |
                //
                    // if then == otherwise and neither are ambiguous,then treat as identity
                    if (then.get() == otherwise.get())
                    {
                        return then;
                    }
                    return eteq::ETensor(eteq::make_functor(::egen::SELECT,teq::TensptrsT{condition,then,otherwise}),ctx);
        - name: reverse
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: const std::set<teq::RankT>&
            name: dims
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::REVERSE,teq::TensptrsT{arg},dims),ctx);
        - name: permute
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: const std::vector<teq::RankT>&
            name: order
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::PERMUTE,teq::TensptrsT{arg},order),ctx);
        - name: extend
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: const std::vector<teq::DimT>&
            name: bcast
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::EXTEND,teq::TensptrsT{arg},bcast),ctx);
        - name: extend
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: teq::RankT
            name: offset
          - type: const std::vector<teq::DimT>&
            name: xlist
          out:
            type: eteq::ETensor
            val: |
                //
                    std::vector<teq::DimT> bcast(offset,1);
                    bcast.insert(bcast.end(),xlist.begin(),xlist.end());
                    return eteq::ETensor(eteq::make_functor(::egen::EXTEND,teq::TensptrsT{arg},bcast),ctx);
        - name: concat
          args:
          - type: const eteq::ETensor&
            name: left
          - type: const eteq::ETensor&
            name: right
          - type: teq::RankT
            name: axis
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::CONCAT,teq::TensptrsT{left,right},axis),ctx);
        - name: concat
          args:
          - type: const eteq::ETensorsT&
            name: args
          - type: teq::RankT
            name: axis
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::CONCAT,eteq::to_tensors(args),axis),ctx);
        - description: Return extended arg so that output shape matches like tensor exactly
          name: extend_like
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: const eteq::ETensor&
            name: like
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::EXTEND,teq::TensptrsT{arg},(teq::TensptrT) like),ctx);
        - name: reshape
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: teq::Shape
            name: shape
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::RESHAPE,teq::TensptrsT{arg},shape),ctx);
        - description: Return sum of values along dimensions specified
          name: reduce_sum
          args:
          - type: const eteq::ETensor&
            name: tens
          - type: std::set<teq::RankT>
            name: dims
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::REDUCE_SUM,teq::TensptrsT{tens},dims),ctx);
        - description: Return product of values along dimensions specified
          name: reduce_prod
          args:
          - type: const eteq::ETensor&
            name: tens
          - type: std::set<teq::RankT>
            name: dims
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::REDUCE_PROD,teq::TensptrsT{tens},dims),ctx);
        - description: Return min of values along dimensions specified
          name: reduce_min
          args:
          - type: const eteq::ETensor&
            name: tens
          - type: std::set<teq::RankT>
            name: dims
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::REDUCE_MIN,teq::TensptrsT{tens},dims),ctx);
        - description: Return max of values along dimensions specified
          name: reduce_max
          args:
          - type: const eteq::ETensor&
            name: tens
          - type: std::set<teq::RankT>
            name: dims
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::REDUCE_MAX,teq::TensptrsT{tens},dims),ctx);
        - description: Return sum of values for ndims dimensions after offset
          name: reduce_sum
          args:
          - type: const eteq::ETensor&
            name: tens
          - type: teq::RankT
            name: offset
            default: "0"
          - type: teq::RankT
            name: ndims
            default: teq::rank_cap
          out:
            type: eteq::ETensor
            val: |
                //
                    if (offset >= teq::rank_cap)
                    {
                        global::fatalf("cannot reduce dimensions [%d:]. Must be less than %d",
                            offset,teq::rank_cap);
                    }
                    std::vector<teq::RankT> dims(std::min(ndims,
                        (teq::RankT) (teq::rank_cap - offset)));
                    std::iota(dims.begin(),dims.end(),offset);
                    return eteq::ETensor(eteq::make_functor(::egen::REDUCE_SUM,teq::TensptrsT{tens},
                        std::set<teq::RankT>(dims.begin(),dims.end())),ctx);
        - description: Return product of values for ndims dimensions after offset
          name: reduce_prod
          args:
          - type: const eteq::ETensor&
            name: tens
          - type: teq::RankT
            name: offset
            default: "0"
          - type: teq::RankT
            name: ndims
            default: teq::rank_cap
          out:
            type: eteq::ETensor
            val: |
                //
                    if (offset >= teq::rank_cap)
                    {
                        global::fatalf("cannot reduce dimensions [%d:]. Must be less than %d",
                            offset,teq::rank_cap);
                    }
                    std::vector<teq::RankT> dims(std::min(ndims,
                        (teq::RankT) (teq::rank_cap - offset)));
                    std::iota(dims.begin(),dims.end(),offset);
                    return eteq::ETensor(eteq::make_functor(::egen::REDUCE_PROD,teq::TensptrsT{tens},
                        std::set<teq::RankT>(dims.begin(),dims.end())),ctx);
        - description: Return min of values for ndims dimensions after offset
          name: reduce_min
          args:
          - type: const eteq::ETensor&
            name: tens
          - type: teq::RankT
            name: offset
            default: "0"
          - type: teq::RankT
            name: ndims
            default: teq::rank_cap
          out:
            type: eteq::ETensor
            val: |
                //
                    if (offset >= teq::rank_cap)
                    {
                        global::fatalf("cannot reduce dimensions [%d:]. Must be less than %d",
                            offset,teq::rank_cap);
                    }
                    std::vector<teq::RankT> dims(std::min(ndims,
                        (teq::RankT) (teq::rank_cap - offset)));
                    std::iota(dims.begin(),dims.end(),offset);
                    return eteq::ETensor(eteq::make_functor(::egen::REDUCE_MIN,teq::TensptrsT{tens},
                        std::set<teq::RankT>(dims.begin(),dims.end())),ctx);
        - description: Return max of values for ndims dimensions after offset
          name: reduce_max
          args:
          - type: const eteq::ETensor&
            name: tens
          - type: teq::RankT
            name: offset
            default: "0"
          - type: teq::RankT
            name: ndims
            default: teq::rank_cap
          out:
            type: eteq::ETensor
            val: |
                //
                    if (offset >= teq::rank_cap)
                    {
                        global::fatalf("cannot reduce dimensions [%d:]. Must be less than %d",
                            offset,teq::rank_cap);
                    }
                    std::vector<teq::RankT> dims(std::min(ndims,
                        (teq::RankT) (teq::rank_cap - offset)));
                    std::iota(dims.begin(),dims.end(),offset);
                    return eteq::ETensor(eteq::make_functor(::egen::REDUCE_MAX,teq::TensptrsT{tens},
                        std::set<teq::RankT>(dims.begin(),dims.end())),ctx);
        - name: argmax
          args:
          - type: const eteq::ETensor&
            name: tens
          - type: teq::RankT
            name: return_dim
            default: "8"
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::ARGMAX,teq::TensptrsT{tens},return_dim),ctx);
        - name: n_elems
          args:
          - type: const eteq::ETensor&
            name: arg
          out:
            type: eteq::ETensor
            val: return eteq::make_constant_scalar<teq::NElemT>(arg->shape().n_elems(),teq::Shape(),(egen::_GENERATED_DTYPE)arg->get_meta().type_code(),ctx);
        - name: n_dims
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: teq::RankT
            name: rank
          out:
            type: eteq::ETensor
            val: return eteq::make_constant_scalar<teq::DimT>(arg->shape().at(rank),teq::Shape(),(egen::_GENERATED_DTYPE)arg->get_meta().type_code(),ctx);
        - description: extents vector consists of pairs offset and extent for each dimension
          name: slice
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: eigen::PairVecT<teq::DimT>
            name: extents
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::SLICE,teq::TensptrsT{arg},extents),ctx);
        - name: slice
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: teq::DimT
            name: offset
          - type: teq::DimT
            name: extent
          - type: teq::RankT
            name: dimension
          out:
            type: eteq::ETensor
            val: |
                //
                    eigen::PairVecT<teq::DimT> extents(
                        std::max(teq::rank_cap,dimension),
                        {0,std::numeric_limits<teq::DimT>::max()});
                    extents[dimension] = {offset,extent};
                    return this->slice(arg,extents);
        - name: pad
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: eigen::PairVecT<teq::DimT>
            name: paddings
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::PAD,teq::TensptrsT{arg},paddings),ctx);
        - name: pad
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: const eteq::DimPairsT&
            name: padding
          - type: teq::RankT
            name: dimension
          out:
            type: eteq::ETensor
            val: |
                //
                    eigen::PairVecT<teq::DimT> paddings(
                        std::max(teq::rank_cap,dimension),{0,0});
                    paddings[dimension] = padding;
                    return this->pad(arg,paddings);
        - name: stride
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: const std::vector<teq::DimT>&
            name: incrs
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::STRIDE,teq::TensptrsT{arg},incrs),ctx);
        - description: populate input values at specific increments along its dimensions to fit specified shape (opposite of stride)
          name: scatter
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: const teq::Shape&
            name: outshape
          - type: const std::vector<teq::DimT>&
            name: incrs
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::SCATTER,teq::TensptrsT{arg},outshape,incrs),ctx);
        - description: multiple values across specify dimensions pairs before summing all products (generalization of matrix product),defaults to matrix product
          name: contract
          args:
          - type: const eteq::ETensor&
            name: a
          - type: const eteq::ETensor&
            name: b
          - type: eigen::PairVecT<teq::RankT>
            name: dims
            default: eigen::PairVecT<teq::RankT>{{0,1}}
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::MATMUL,teq::TensptrsT{a,b},dims),ctx);
        - name: matmul
          args:
          - type: const eteq::ETensor&
            name: a
          - type: const eteq::ETensor&
            name: b
          out:
            type: eteq::ETensor
            val: return this->contract(a,b);
        - name: convolution
          args:
          - type: const eteq::ETensor&
            name: image
          - type: const eteq::ETensor&
            name: kernel
          - type: const std::vector<teq::RankT>&
            name: dims
          out:
            type: eteq::ETensor
            val: return eteq::ETensor(eteq::make_functor(::egen::CONV,teq::TensptrsT{image,kernel},dims),ctx);
        - name: reduce_sum_1d
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: teq::RankT
            name: dimension
          out:
            type: eteq::ETensor
            val: |
                //
                    auto red = this->reduce_sum(arg,dimension,1);

                    std::vector<teq::RankT> indices(teq::rank_cap);
                    auto bt = indices.begin();
                    auto it = bt + dimension;
                    std::iota(bt,it,0);
                    std::iota(it,indices.end(),dimension + 1);
                    indices[teq::rank_cap - 1] = dimension;
                    return this->permute(red,indices);
        - name: reduce_prod_1d
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: teq::RankT
            name: dimension
          out:
            type: eteq::ETensor
            val: |
                //
                    auto red = this->reduce_prod(arg,dimension,1);

                    std::vector<teq::RankT> indices(teq::rank_cap);
                    auto bt = indices.begin();
                    auto it = bt + dimension;
                    std::iota(bt,it,0);
                    std::iota(it,indices.end(),dimension + 1);
                    indices[teq::rank_cap - 1] = dimension;
                    return this->permute(red,indices);
        - name: reduce_min_1d
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: teq::RankT
            name: dimension
          out:
            type: eteq::ETensor
            val: |
                //
                    auto red = this->reduce_min(arg,dimension,1);

                    std::vector<teq::RankT> indices(teq::rank_cap);
                    auto bt = indices.begin();
                    auto it = bt + dimension;
                    std::iota(bt,it,0);
                    std::iota(it,indices.end(),dimension + 1);
                    indices[teq::rank_cap - 1] = dimension;
                    return this->permute(red,indices);
        - name: reduce_max_1d
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: teq::RankT
            name: dimension
          out:
            type: eteq::ETensor
            val: |
                //
                    auto red = this->reduce_max(arg,dimension,1);

                    std::vector<teq::RankT> indices(teq::rank_cap);
                    auto bt = indices.begin();
                    auto it = bt + dimension;
                    std::iota(bt,it,0);
                    std::iota(it,indices.end(),dimension + 1);
                    indices[teq::rank_cap - 1] = dimension;
                    return this->permute(red,indices);
        - name: transpose
          args:
          - type: const eteq::ETensor&
            name: arg
          out:
            type: eteq::ETensor
            val: return this->permute(arg,{1,0});
        - name: reduce_mean
          args:
          - type: const eteq::ETensor&
            name: arg
          out:
            type: eteq::ETensor
            val: return this->div(this->reduce_sum(arg),this->n_elems(arg));
        - name: reduce_mean_1d
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: teq::RankT
            name: dimension
          out:
            type: eteq::ETensor
            val: |
                //
                    auto red = this->reduce_sum_1d(arg,dimension);
                    auto dim = eteq::make_constant_like<teq::DimT>(arg->shape().at(dimension),red,ctx);
                    return this->div(red,dim);
        - name: reduce_l2norm
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: teq::RankT
            name: offset
            default: "0"
          - type: teq::RankT
            name: ndims
            default: teq::rank_cap
          out:
            type: eteq::ETensor
            val: return this->sqrt(this->reduce_sum(this->square(arg),offset,ndims));
        - name: reduce_l2norm_1d
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: teq::RankT
            name: dimension
          out:
            type: eteq::ETensor
            val: return this->sqrt(this->reduce_sum_1d(this->square(arg),dimension));
        - template: typename T
          name: clip_by_range
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: T
            name: minval
          - type: T
            name: maxval
          out:
            type: eteq::ETensor
            val: |
                //
                    if (minval > maxval)
                    {
                        global::fatal("min value is below max");
                    }
                    auto lo = eteq::make_constant_like<T>(minval,arg,ctx);
                    auto hi = eteq::make_constant_like<T>(maxval,arg,ctx);
                    return this->max(this->min(arg,hi),lo);
        - template: typename T
          description: clip by l2norm
          name: clip_by_l2norm
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: T
            name: upper
          out:
            type: eteq::ETensor
            val: |
                //
                    // todo: parameterize l2norm offset and ndims
                    if (upper == 0)
                    {
                        global::fatal("cannot clip_by_norm with a upper limit of 0");
                    }
                    auto norm = this->extend_like(
                        this->reduce_l2norm(arg),arg);
                    auto limit = eteq::make_constant_like<T>(upper,arg,ctx);
                    return this->if_then_else(this->lt(norm,limit),
                        arg,this->div(this->mul(arg,limit),norm));
        - name: sum
          args:
          - type: const eteq::ETensorsT&
            name: args
          out:
            type: eteq::ETensor
            val: |
                //
                    size_t nargs = args.size();
                    switch (nargs)
                    {
                        case 0:
                            global::fatal("cannot sum without arguments");
                        case 1:
                            return args[0];
                        case 2:
                            return this->add(args[0],args[1]);
                        default:
                            break;
                    }
                    return eteq::ETensor(eteq::make_functor(::egen::ADD,eteq::to_tensors(args)),ctx);
        - name: prod
          args:
          - type: const eteq::ETensorsT&
            name: args
          out:
            type: eteq::ETensor
            val: |
                //
                    size_t nargs = args.size();
                    switch (nargs)
                    {
                        case 0:
                            global::fatal("cannot prod without arguments");
                        case 1:
                            return args[0];
                        default:
                            break;
                    }
                    return eteq::ETensor(eteq::make_functor(::egen::MUL,eteq::to_tensors(args)),ctx);
        - name: softmax
          args:
          - type: const eteq::ETensor&
            name: arg
          - type: teq::RankT
            name: offset
            default: "0"
          - type: teq::RankT
            name: ndims
            default: teq::rank_cap
          out:
            type: eteq::ETensor
            val: |
                //
                    if (offset + ndims > teq::rank_cap)
                    {
                        global::fatalf("cannot perform softmax on dimensions beyond %d",
                            teq::rank_cap);
                    }
                    teq::Shape shape = arg->shape();
                    auto overflow_preventer = this->extend_like(
                        this->reduce_max(arg,offset,ndims),arg);
                    auto exarg = this->exp(this->sub(arg,overflow_preventer));
                    auto it = shape.begin() + offset;
                    std::vector<teq::DimT> xlist(it,it + ndims);
                    return this->div(exarg,
                        this->extend_like(this->add(
                            this->reduce_sum(exarg,offset,ndims),
                            std::numeric_limits<float>::epsilon()),exarg));
        - name: relu
          args:
          - type: const eteq::ETensor&
            name: arg
          out:
            type: eteq::ETensor
            val: return this->max(arg,(float) 0);
        - name: softplus
          args:
          - type: const eteq::ETensor&
            name: arg
          out:
            type: eteq::ETensor
            val: return this->log(this->add((float) 1,this->exp(arg)));
        - name: sign
          args:
          - type: const eteq::ETensor&
            name: x
          out:
            type: eteq::ETensor
            val: return this->add(this->mul((float)-2,this->lt(x,(float)0)),(float)1);
    - approx.yml
    - error.yml
    - layer.yml
    - nn.yml
    - random.yml

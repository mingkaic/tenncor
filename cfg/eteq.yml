api:
  pybind_type: float
  includes:
  - '"eteq/derive.hpp"'
  - '"eteq/make.hpp"'
  - '"eteq/layer.hpp"'
  - '"layr/approx.hpp"'
  - '"layr/init.hpp"'
  - '"layr/layer.hpp"'
  pyignore_type:
    - teq::RankT
    - teq::DimT
    - eigen::PairVecT<teq::RankT>
    - eteq::DimPairsT
    - eteq::EVariable<T>
    - eteq::ETensorsT<T>
    - eteq::EVariablesT<T>
    - layr::UnaryF<T>
    - layr::InitF<T>
    - std::set<teq::RankT>
    - std::vector<teq::DimT>
    - std::pair<eteq::DimPairsT,eteq::DimPairsT>
  pybind_includes:
  - '"python/tenncor.hpp"'
  pybind_module: tenncor
  pyglobal:
    - name: api
      type: TenncorAPI<float>
      decl: |
          //
              static TenncorAPI<float> global(eteq::global_context().registry_);
              return global;
  funcs:
    - template: typename T
      description: Get global tenncor api instance
      name: tenncor
      out:
        type: TenncorAPI<T>&
        val: |
            //
                static TenncorAPI<T> api;
                return api;
      pyignores: True
    - template: typename T
      description: Negation operator with output ETensor using the same registry as the input
      operator: "-"
      args:
      - type: const eteq::ETensor<T>&
        name: arg
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(*arg.get_registry()).neg(arg);
    - template: typename T
      description: Addition operator with output ETensor using the same registry as the left input
      operator: +
      args:
      - type: const eteq::ETensor<T>&
        name: a
      - type: const eteq::ETensor<T>&
        name: b
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(*a.get_registry()).add(a,b);
    - template: typename T
      description: Addition operator with output ETensor using the same registry as the tensor input
      operator: +
      args:
      - type: const eteq::ETensor<T>&
        name: arg
      - type: T
        name: scalar
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(*arg.get_registry()).add(arg,scalar);
    - template: typename T
      description: Addition operator with output ETensor using the same registry as the tensor input
      operator: +
      args:
      - type: T
        name: scalar
      - type: const eteq::ETensor<T>&
        name: arg
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(*arg.get_registry()).add(scalar,arg);
    - template: typename T
      description: Subtraction operator with output ETensor using the same registry as the left input
      operator: "-"
      args:
      - type: const eteq::ETensor<T>&
        name: a
      - type: const eteq::ETensor<T>&
        name: b
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(*a.get_registry()).sub(a,b);
    - template: typename T
      description: Subtraction operator with output ETensor using the same registry as the tensor input
      operator: "-"
      args:
      - type: const eteq::ETensor<T>&
        name: arg
      - type: T
        name: scalar
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(*arg.get_registry()).sub(arg,scalar);
    - template: typename T
      description: Subtraction operator with output ETensor using the same registry as the tensor input
      operator: "-"
      args:
      - type: T
        name: scalar
      - type: const eteq::ETensor<T>&
        name: arg
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(*arg.get_registry()).sub(scalar,arg);
    - template: typename T
      description: Multiplication operator with output ETensor using the same registry as the left input
      operator: "*"
      args:
      - type: const eteq::ETensor<T>&
        name: a
      - type: const eteq::ETensor<T>&
        name: b
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(*a.get_registry()).mul(a,b);
    - template: typename T
      description: Multiplication operator with output ETensor using the same registry as the tensor input
      operator: "*"
      args:
      - type: const eteq::ETensor<T>&
        name: arg
      - type: T
        name: scalar
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(*arg.get_registry()).mul(arg,scalar);
    - template: typename T
      description: Multiplication operator with output ETensor using the same registry as the tensor input
      operator: "*"
      args:
      - type: T
        name: scalar
      - type: const eteq::ETensor<T>&
        name: arg
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(*arg.get_registry()).mul(scalar,arg);
    - template: typename T
      description: Division operator with output ETensor using the same registry as the left input
      operator: /
      args:
      - type: const eteq::ETensor<T>&
        name: a
      - type: const eteq::ETensor<T>&
        name: b
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(*a.get_registry()).div(a,b);
    - template: typename T
      description: Division operator with output ETensor using the same registry as the tensor input
      operator: /
      args:
      - type: const eteq::ETensor<T>&
        name: arg
      - type: T
        name: scalar
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(*arg.get_registry()).div(arg,scalar);
    - template: typename T
      description: Division operator with output ETensor using the same registry as the tensor input
      operator: /
      args:
      - type: T
        name: scalar
      - type: const eteq::ETensor<T>&
        name: arg
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(*arg.get_registry()).div(scalar,arg);
    - template: typename T
      description: Equality operator with output ETensor using the same registry as the left input
      operator: ==
      args:
      - type: const eteq::ETensor<T>&
        name: a
      - type: const eteq::ETensor<T>&
        name: b
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(*a.get_registry()).eq(a,b);
    - template: typename T
      description: Equality operator with output ETensor using the same registry as the tensor input
      operator: ==
      args:
      - type: const eteq::ETensor<T>&
        name: arg
      - type: T
        name: scalar
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(*arg.get_registry()).eq(arg,scalar);
    - template: typename T
      description: Equality operator with output ETensor using the same registry as the tensor input
      operator: ==
      args:
      - type: T
        name: scalar
      - type: const eteq::ETensor<T>&
        name: arg
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(*arg.get_registry()).eq(scalar,arg);
    - template: typename T
      description: Inequality operator with output ETensor using the same registry as the left input
      operator: "!="
      args:
      - type: const eteq::ETensor<T>&
        name: a
      - type: const eteq::ETensor<T>&
        name: b
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(*a.get_registry()).neq(a,b);
    - template: typename T
      description: Inequality operator with output ETensor using the same registry as the tensor input
      operator: "!="
      args:
      - type: const eteq::ETensor<T>&
        name: arg
      - type: T
        name: scalar
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(*arg.get_registry()).neq(arg,scalar);
    - template: typename T
      description: Inequality operator with output ETensor using the same registry as the tensor input
      operator: "!="
      args:
      - type: T
        name: scalar
      - type: const eteq::ETensor<T>&
        name: arg
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(*arg.get_registry()).neq(scalar,arg);
    - template: typename T
      description: Lesser than operator with output ETensor using the same registry as the left input
      operator: <
      args:
      - type: const eteq::ETensor<T>&
        name: a
      - type: const eteq::ETensor<T>&
        name: b
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(*a.get_registry()).lt(a,b);
    - template: typename T
      description: Lesser than operator with output ETensor using the same registry as the tensor input
      operator: <
      args:
      - type: const eteq::ETensor<T>&
        name: arg
      - type: T
        name: scalar
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(*arg.get_registry()).lt(arg,scalar);
    - template: typename T
      description: Lesser than operator with output ETensor using the same registry as the tensor input
      operator: <
      args:
      - type: T
        name: scalar
      - type: const eteq::ETensor<T>&
        name: arg
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(*arg.get_registry()).lt(scalar,arg);
    - template: typename T
      description: Greater than operator with output ETensor using the same registry as the left input
      operator: ">"
      args:
      - type: const eteq::ETensor<T>&
        name: a
      - type: const eteq::ETensor<T>&
        name: b
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(*a.get_registry()).gt(a,b);
    - template: typename T
      description: Greater than operator with output ETensor using the same registry as the tensor input
      operator: ">"
      args:
      - type: const eteq::ETensor<T>&
        name: arg
      - type: T
        name: scalar
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(*arg.get_registry()).gt(arg,scalar);
    - template: typename T
      description: Greater than operator with output ETensor using the same registry as the tensor input
      operator: ">"
      args:
      - type: T
        name: scalar
      - type: const eteq::ETensor<T>&
        name: arg
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(*arg.get_registry()).gt(scalar,arg);
  classes:
    - name: TenncorAPI
      template: typename T
      init:
        args:
          - name: reg
            type: eteq::ETensRegistryT&
            default: eteq::global_context().registry_
        initlist:
          random: this
          nn: this
          layer: this
          error: this
          approx: this
          registry: "&reg"
      members:
        - name: registry
          type: eteq::ETensRegistryT*
          public: True
        - name: random
          type: RandomAPI<T>
          public: True
        - name: nn
          type: NnAPI<T>
          public: True
        - name: layer
          type: LayerAPI<T>
          public: True
        - name: error
          type: ErrorAPI<T>
          public: True
        - name: approx
          type: ApproxAPI<T>
          public: True
      funcs:
        - name: depends
          args:
          - type: const eteq::ETensor<T>&
            name: dependee
          - type: const eteq::ETensorsT<T>&
            name: dependencies
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    if (auto dep = std::dynamic_pointer_cast<eigen::Observable>(
                      (teq::TensptrT) dependee))
                    {
                        return eteq::ETensor<T>(teq::TensptrT(eteq::Depends::get(dep,
                            teq::TensptrsT(dependencies.begin(),dependencies.end()))),*registry);
                    }
                    teq::warnf("cannot link non-observable %s to dependencies",
                        dependee->to_string().c_str());
                    return dependee;
        - name: assign
          args:
          - type: const eteq::EVariable<T>&
            name: target
          - type: const eteq::ETensor<T>&
            name: source
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::ASSIGN,teq::TensptrsT{target,source});
        - name: assign_add
          args:
          - type: const eteq::EVariable<T>&
            name: target
          - type: const eteq::ETensor<T>&
            name: source
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::ASSIGN_ADD,teq::TensptrsT{target,source});
        - name: assign_sub
          args:
          - type: const eteq::EVariable<T>&
            name: target
          - type: const eteq::ETensor<T>&
            name: source
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::ASSIGN_SUB,teq::TensptrsT{target,source});
        - name: assign_mul
          args:
          - type: const eteq::EVariable<T>&
            name: target
          - type: const eteq::ETensor<T>&
            name: source
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::ASSIGN_MUL,teq::TensptrsT{target,source});
        - name: assign_div
          args:
          - type: const eteq::EVariable<T>&
            name: target
          - type: const eteq::ETensor<T>&
            name: source
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::ASSIGN_DIV,teq::TensptrsT{target,source});
        - name: identity
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::IDENTITY,teq::TensptrsT{arg});
        - name: abs
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::ABS,teq::TensptrsT{arg});
        - name: neg
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::NEG,teq::TensptrsT{arg});
        - name: sin
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::SIN,teq::TensptrsT{arg});
        - name: cos
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::COS,teq::TensptrsT{arg});
        - name: tan
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::TAN,teq::TensptrsT{arg});
        - name: exp
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::EXP,teq::TensptrsT{arg});
        - name: log
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::LOG,teq::TensptrsT{arg});
        - name: sqrt
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::SQRT,teq::TensptrsT{arg});
        - name: round
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::ROUND,teq::TensptrsT{arg});
        - name: sigmoid
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::SIGMOID,teq::TensptrsT{arg});
        - name: tanh
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::TANH,teq::TensptrsT{arg});
        - name: square
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::SQUARE,teq::TensptrsT{arg});
        - name: cube
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::CUBE,teq::TensptrsT{arg});
        - name: pow
          args:
          - type: const eteq::ETensor<T>&
            name: a
          - type: const eteq::ETensor<T>&
            name: b
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::POW,teq::TensptrsT{a,b});
        - name: pow
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: T
            name: scalar
          out:
            type: eteq::ETensor<T>
            val: return this->pow(arg,eteq::make_constant_like<T>(scalar,arg));
        - name: pow
          args:
          - type: T
            name: scalar
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return this->pow(eteq::make_constant_like<T>(scalar,arg,*registry),arg);
        - name: add
          args:
          - type: const eteq::ETensor<T>&
            name: a
          - type: const eteq::ETensor<T>&
            name: b
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::ADD,teq::TensptrsT{a,b});
        - name: add
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: T
            name: scalar
          out:
            type: eteq::ETensor<T>
            val: return this->add(arg,eteq::make_constant_like<T>(scalar,arg,*registry));
        - name: add
          args:
          - type: T
            name: scalar
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return this->add(eteq::make_constant_like<T>(scalar,arg,*registry),arg);
        - name: sub
          args:
          - type: const eteq::ETensor<T>&
            name: a
          - type: const eteq::ETensor<T>&
            name: b
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::SUB,teq::TensptrsT{a,b});
        - name: sub
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: T
            name: scalar
          out:
            type: eteq::ETensor<T>
            val: return this->sub(arg,eteq::make_constant_like<T>(scalar,arg,*registry));
        - name: sub
          args:
          - type: T
            name: scalar
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return this->sub(eteq::make_constant_like<T>(scalar,arg,*registry),arg);
        - name: mul
          args:
          - type: const eteq::ETensor<T>&
            name: a
          - type: const eteq::ETensor<T>&
            name: b
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::MUL,teq::TensptrsT{a,b});
        - name: mul
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: T
            name: scalar
          out:
            type: eteq::ETensor<T>
            val: return this->mul(arg,eteq::make_constant_like<T>(scalar,arg,*registry));
        - name: mul
          args:
          - type: T
            name: scalar
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return this->mul(eteq::make_constant_like<T>(scalar,arg,*registry),arg);
        - name: div
          args:
          - type: const eteq::ETensor<T>&
            name: a
          - type: const eteq::ETensor<T>&
            name: b
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::DIV,teq::TensptrsT{a,b});
        - name: div
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: T
            name: scalar
          out:
            type: eteq::ETensor<T>
            val: return this->div(arg,eteq::make_constant_like<T>(scalar,arg,*registry));
        - name: div
          args:
          - type: T
            name: scalar
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return this->div(eteq::make_constant_like<T>(scalar,arg,*registry),arg);
        - name: eq
          args:
          - type: const eteq::ETensor<T>&
            name: a
          - type: const eteq::ETensor<T>&
            name: b
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::EQ,teq::TensptrsT{a,b});
        - name: eq
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: T
            name: scalar
          out:
            type: eteq::ETensor<T>
            val: return this->eq(arg,eteq::make_constant_like<T>(scalar,arg,*registry));
        - name: eq
          args:
          - type: T
            name: scalar
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return this->eq(eteq::make_constant_like<T>(scalar,arg,*registry),arg);
        - name: neq
          args:
          - type: const eteq::ETensor<T>&
            name: a
          - type: const eteq::ETensor<T>&
            name: b
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::NEQ,teq::TensptrsT{a,b});
        - name: neq
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: T
            name: scalar
          out:
            type: eteq::ETensor<T>
            val: return this->neq(arg,eteq::make_constant_like<T>(scalar,arg,*registry));
        - name: neq
          args:
          - type: T
            name: scalar
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return this->neq(eteq::make_constant_like<T>(scalar,arg,*registry),arg);
        - name: lt
          args:
          - type: const eteq::ETensor<T>&
            name: a
          - type: const eteq::ETensor<T>&
            name: b
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::LT,teq::TensptrsT{a,b});
        - name: lt
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: T
            name: scalar
          out:
            type: eteq::ETensor<T>
            val: return this->lt(arg,eteq::make_constant_like<T>(scalar,arg,*registry));
        - name: lt
          args:
          - type: T
            name: scalar
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return this->lt(eteq::make_constant_like<T>(scalar,arg,*registry),arg);
        - name: gt
          args:
          - type: const eteq::ETensor<T>&
            name: a
          - type: const eteq::ETensor<T>&
            name: b
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::GT,teq::TensptrsT{a,b});
        - name: gt
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: T
            name: scalar
          out:
            type: eteq::ETensor<T>
            val: return this->gt(arg,eteq::make_constant_like<T>(scalar,arg,*registry));
        - name: gt
          args:
          - type: T
            name: scalar
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return this->gt(eteq::make_constant_like<T>(scalar,arg,*registry),arg);
        - name: min
          args:
          - type: const eteq::ETensor<T>&
            name: a
          - type: const eteq::ETensor<T>&
            name: b
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::MIN,teq::TensptrsT{a,b});
        - name: min
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: T
            name: scalar
          out:
            type: eteq::ETensor<T>
            val: return this->min(arg,eteq::make_constant_like<T>(scalar,arg,*registry));
        - name: min
          args:
          - type: T
            name: scalar
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return this->min(eteq::make_constant_like<T>(scalar,arg,*registry),arg);
        - name: min
          args:
          - type: const eteq::ETensorsT<T>&
            name: args
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    if (args.empty())
                    {
                        teq::fatal("cannot min without arguments");
                    }
                    eteq::ETensor<T> out = args[0];
                    for (size_t i = 1,n = args.size(); i < n; ++i)
                    {
                        out = this->min(out,args[i]);
                    }
                    return out;
        - name: max
          args:
          - type: const eteq::ETensor<T>&
            name: a
          - type: const eteq::ETensor<T>&
            name: b
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::MAX,teq::TensptrsT{a,b});
        - name: max
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: T
            name: scalar
          out:
            type: eteq::ETensor<T>
            val: return this->max(arg,eteq::make_constant_like<T>(scalar,arg,*registry));
        - name: max
          args:
          - type: T
            name: scalar
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return this->max(eteq::make_constant_like<T>(scalar,arg,*registry),arg);
        - name: max
          args:
          - type: const eteq::ETensorsT<T>&
            name: args
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    if (args.empty())
                    {
                        teq::fatal("cannot max without arguments");
                    }
                    eteq::ETensor<T> out = args[0];
                    for (size_t i = 1,n = args.size(); i < n; ++i)
                    {
                        out = this->max(out,args[i]);
                    }
                    return out;
        - name: if_then_else
          args:
          - type: const eteq::ETensor<T>&
            name: condition
          - type: const eteq::ETensor<T>&
            name: then
          - type: const eteq::ETensor<T>&
            name: otherwise
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    // if then == otherwise and neither are ambiguous,then treat as identity
                    if (then.get() == otherwise.get())
                    {
                        return then;
                    }
                    return eteq::make_functor<T>(*registry,::egen::SELECT,teq::TensptrsT{condition,then,otherwise});
        - name: reverse
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: const std::set<teq::RankT>&
            name: dims
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::REVERSE,teq::TensptrsT{arg},dims);
        - name: permute
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: const std::vector<teq::RankT>&
            name: order
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::PERMUTE,teq::TensptrsT{arg},order);
        - name: extend
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: const std::vector<teq::DimT>&
            name: bcast
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::EXTEND,teq::TensptrsT{arg},bcast);
        - name: extend
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: teq::RankT
            name: offset
          - type: const std::vector<teq::DimT>&
            name: xlist
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    std::vector<teq::DimT> bcast(offset,1);
                    bcast.insert(bcast.end(),xlist.begin(),xlist.end());
                    return eteq::make_functor<T>(*registry,::egen::EXTEND,teq::TensptrsT{arg},bcast);
        - name: concat
          args:
          - type: const eteq::ETensor<T>&
            name: left
          - type: const eteq::ETensor<T>&
            name: right
          - type: teq::RankT
            name: axis
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::CONCAT,teq::TensptrsT{left,right},axis);
        - name: concat
          args:
          - type: const eteq::ETensorsT<T>&
            name: args
          - type: teq::RankT
            name: axis
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::CONCAT,eteq::to_tensors(args),axis);
        - description: Return extended arg so that output shape matches like tensor exactly
          name: extend_like
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: const eteq::ETensor<T>&
            name: like
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::EXTEND,teq::TensptrsT{arg},(teq::TensptrT) like);
        - name: reshape
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: teq::Shape
            name: shape
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::RESHAPE,teq::TensptrsT{arg},shape);
        - description: Return sum of values along dimensions specified
          name: reduce_sum
          args:
          - type: const eteq::ETensor<T>&
            name: tens
          - type: std::set<teq::RankT>
            name: dims
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::REDUCE_SUM,teq::TensptrsT{tens},dims);
        - description: Return product of values along dimensions specified
          name: reduce_prod
          args:
          - type: const eteq::ETensor<T>&
            name: tens
          - type: std::set<teq::RankT>
            name: dims
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::REDUCE_PROD,teq::TensptrsT{tens},dims);
        - description: Return min of values along dimensions specified
          name: reduce_min
          args:
          - type: const eteq::ETensor<T>&
            name: tens
          - type: std::set<teq::RankT>
            name: dims
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::REDUCE_MIN,teq::TensptrsT{tens},dims);
        - description: Return max of values along dimensions specified
          name: reduce_max
          args:
          - type: const eteq::ETensor<T>&
            name: tens
          - type: std::set<teq::RankT>
            name: dims
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::REDUCE_MAX,teq::TensptrsT{tens},dims);
        - description: Return sum of values for ndims dimensions after offset
          name: reduce_sum
          args:
          - type: const eteq::ETensor<T>&
            name: tens
          - type: teq::RankT
            name: offset
            default: "0"
          - type: teq::RankT
            name: ndims
            default: teq::rank_cap
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    if (offset >= teq::rank_cap)
                    {
                        teq::fatalf("cannot reduce dimensions [%d:]. Must be less than %d",
                            offset,teq::rank_cap);
                    }
                    std::vector<teq::RankT> dims(std::min(ndims,
                        (teq::RankT) (teq::rank_cap - offset)));
                    std::iota(dims.begin(),dims.end(),offset);
                    return eteq::make_functor<T>(*registry,::egen::REDUCE_SUM,teq::TensptrsT{tens},
                        std::set<teq::RankT>(dims.begin(),dims.end()));
        - description: Return product of values for ndims dimensions after offset
          name: reduce_prod
          args:
          - type: const eteq::ETensor<T>&
            name: tens
          - type: teq::RankT
            name: offset
            default: "0"
          - type: teq::RankT
            name: ndims
            default: teq::rank_cap
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    if (offset >= teq::rank_cap)
                    {
                        teq::fatalf("cannot reduce dimensions [%d:]. Must be less than %d",
                            offset,teq::rank_cap);
                    }
                    std::vector<teq::RankT> dims(std::min(ndims,
                        (teq::RankT) (teq::rank_cap - offset)));
                    std::iota(dims.begin(),dims.end(),offset);
                    return eteq::make_functor<T>(*registry,::egen::REDUCE_PROD,teq::TensptrsT{tens},
                        std::set<teq::RankT>(dims.begin(),dims.end()));
        - description: Return min of values for ndims dimensions after offset
          name: reduce_min
          args:
          - type: const eteq::ETensor<T>&
            name: tens
          - type: teq::RankT
            name: offset
            default: "0"
          - type: teq::RankT
            name: ndims
            default: teq::rank_cap
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    if (offset >= teq::rank_cap)
                    {
                        teq::fatalf("cannot reduce dimensions [%d:]. Must be less than %d",
                            offset,teq::rank_cap);
                    }
                    std::vector<teq::RankT> dims(std::min(ndims,
                        (teq::RankT) (teq::rank_cap - offset)));
                    std::iota(dims.begin(),dims.end(),offset);
                    return eteq::make_functor<T>(*registry,::egen::REDUCE_MIN,teq::TensptrsT{tens},
                        std::set<teq::RankT>(dims.begin(),dims.end()));
        - description: Return max of values for ndims dimensions after offset
          name: reduce_max
          args:
          - type: const eteq::ETensor<T>&
            name: tens
          - type: teq::RankT
            name: offset
            default: "0"
          - type: teq::RankT
            name: ndims
            default: teq::rank_cap
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    if (offset >= teq::rank_cap)
                    {
                        teq::fatalf("cannot reduce dimensions [%d:]. Must be less than %d",
                            offset,teq::rank_cap);
                    }
                    std::vector<teq::RankT> dims(std::min(ndims,
                        (teq::RankT) (teq::rank_cap - offset)));
                    std::iota(dims.begin(),dims.end(),offset);
                    return eteq::make_functor<T>(*registry,::egen::REDUCE_MAX,teq::TensptrsT{tens},
                        std::set<teq::RankT>(dims.begin(),dims.end()));
        - name: argmax
          args:
          - type: const eteq::ETensor<T>&
            name: tens
          - type: teq::RankT
            name: return_dim
            default: "8"
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::ARGMAX,teq::TensptrsT{tens},return_dim);
        - name: n_elems
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_constant_scalar<T>(arg->shape().n_elems(),teq::Shape(),*registry);
        - name: n_dims
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: teq::RankT
            name: rank
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_constant_scalar<T>(arg->shape().at(rank),teq::Shape(),*registry);
        - description: extents vector consists of pairs offset and extent for each dimension
          name: slice
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: eigen::PairVecT<teq::DimT>
            name: extents
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::SLICE,teq::TensptrsT{arg},extents);
        - name: slice
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: teq::DimT
            name: offset
          - type: teq::DimT
            name: extent
          - type: teq::RankT
            name: dimension
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    eigen::PairVecT<teq::DimT> extents(
                        std::max(teq::rank_cap,dimension),
                        {0,std::numeric_limits<teq::DimT>::max()});
                    extents[dimension] = {offset,extent};
                    return this->slice(arg,extents);
        - name: pad
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: eigen::PairVecT<teq::DimT>
            name: paddings
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::PAD,teq::TensptrsT{arg},paddings);
        - name: pad
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: const eteq::DimPairsT&
            name: padding
          - type: teq::RankT
            name: dimension
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    eigen::PairVecT<teq::DimT> paddings(
                        std::max(teq::rank_cap,dimension),{0,0});
                    paddings[dimension] = padding;
                    return this->pad(arg,paddings);
        - name: stride
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: const std::vector<teq::DimT>&
            name: incrs
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::STRIDE,teq::TensptrsT{arg},incrs);
        - description: populate input values at specific increments along its dimensions to fit specified shape (opposite of stride)
          name: scatter
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: const teq::Shape&
            name: outshape
          - type: const std::vector<teq::DimT>&
            name: incrs
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::SCATTER,teq::TensptrsT{arg},outshape,incrs);
        - description: multiple values across specify dimensions pairs before summing all products (generalization of matrix product),defaults to matrix product
          name: contract
          args:
          - type: const eteq::ETensor<T>&
            name: a
          - type: const eteq::ETensor<T>&
            name: b
          - type: eigen::PairVecT<teq::RankT>
            name: dims
            default: eigen::PairVecT<teq::RankT>{{0,1}}
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::MATMUL,teq::TensptrsT{a,b},dims);
        - name: matmul
          args:
          - type: const eteq::ETensor<T>&
            name: a
          - type: const eteq::ETensor<T>&
            name: b
          out:
            type: eteq::ETensor<T>
            val: return this->contract(a,b);
        - name: convolution
          args:
          - type: const eteq::ETensor<T>&
            name: image
          - type: const eteq::ETensor<T>&
            name: kernel
          - type: const std::vector<teq::RankT>&
            name: dims
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(*registry,::egen::CONV,teq::TensptrsT{image,kernel},dims);
        - name: reduce_sum_1d
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: teq::RankT
            name: dimension
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    auto red = this->reduce_sum(arg,dimension,1);

                    std::vector<teq::RankT> indices(teq::rank_cap);
                    auto bt = indices.begin();
                    auto it = bt + dimension;
                    std::iota(bt,it,0);
                    std::iota(it,indices.end(),dimension + 1);
                    indices[teq::rank_cap - 1] = dimension;
                    return this->permute(red,indices);
        - name: reduce_prod_1d
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: teq::RankT
            name: dimension
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    auto red = this->reduce_prod(arg,dimension,1);

                    std::vector<teq::RankT> indices(teq::rank_cap);
                    auto bt = indices.begin();
                    auto it = bt + dimension;
                    std::iota(bt,it,0);
                    std::iota(it,indices.end(),dimension + 1);
                    indices[teq::rank_cap - 1] = dimension;
                    return this->permute(red,indices);
        - name: reduce_min_1d
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: teq::RankT
            name: dimension
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    auto red = this->reduce_min(arg,dimension,1);

                    std::vector<teq::RankT> indices(teq::rank_cap);
                    auto bt = indices.begin();
                    auto it = bt + dimension;
                    std::iota(bt,it,0);
                    std::iota(it,indices.end(),dimension + 1);
                    indices[teq::rank_cap - 1] = dimension;
                    return this->permute(red,indices);
        - name: reduce_max_1d
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: teq::RankT
            name: dimension
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    auto red = this->reduce_max(arg,dimension,1);

                    std::vector<teq::RankT> indices(teq::rank_cap);
                    auto bt = indices.begin();
                    auto it = bt + dimension;
                    std::iota(bt,it,0);
                    std::iota(it,indices.end(),dimension + 1);
                    indices[teq::rank_cap - 1] = dimension;
                    return this->permute(red,indices);
        - name: transpose
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return this->permute(arg,{1,0});
        - name: reduce_mean
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return this->div(this->reduce_sum(arg),this->n_elems(arg));
        - name: reduce_mean_1d
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: teq::RankT
            name: dimension
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    auto red = this->reduce_sum_1d(arg,dimension);
                    auto dim = eteq::make_constant_like<T>(arg->shape().at(dimension),red,*registry);
                    return this->div(red,dim);
        - name: reduce_l2norm
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: teq::RankT
            name: offset
            default: "0"
          - type: teq::RankT
            name: ndims
            default: teq::rank_cap
          out:
            type: eteq::ETensor<T>
            val: return this->sqrt(this->reduce_sum(this->square(arg),offset,ndims));
        - name: reduce_l2norm_1d
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: teq::RankT
            name: dimension
          out:
            type: eteq::ETensor<T>
            val: return this->sqrt(this->reduce_sum_1d(this->square(arg),dimension));
        - name: clip_by_range
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: T
            name: minval
          - type: T
            name: maxval
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    if (minval > maxval)
                    {
                        teq::fatal("min value is below max");
                    }
                    auto lo = eteq::make_constant_like<T>(minval,arg,*registry);
                    auto hi = eteq::make_constant_like<T>(maxval,arg,*registry);
                    return this->max(this->min(arg,hi),lo);
        - description: clip by l2norm
          name: clip_by_l2norm
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: T
            name: upper
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    // todo: parameterize l2norm offset and ndims
                    if (upper == 0)
                    {
                        teq::fatal("cannot clip_by_norm with a upper limit of 0");
                    }
                    auto norm = this->extend_like(
                        this->reduce_l2norm(arg),arg);
                    auto limit = eteq::make_constant_like<T>(upper,arg,*registry);
                    return this->if_then_else(this->lt(norm,limit),
                        arg,this->div(this->mul(arg,limit),norm));
        - name: sum
          args:
          - type: const eteq::ETensorsT<T>&
            name: args
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    size_t nargs = args.size();
                    switch (nargs)
                    {
                        case 0:
                            teq::fatal("cannot sum without arguments");
                        case 1:
                            return args[0];
                        case 2:
                            return this->add(args[0],args[1]);
                        default:
                            break;
                    }
                    return eteq::make_functor<T>(*registry,::egen::ADD,eteq::to_tensors(args));
        - name: prod
          args:
          - type: const eteq::ETensorsT<T>&
            name: args
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    size_t nargs = args.size();
                    switch (nargs)
                    {
                        case 0:
                            teq::fatal("cannot prod without arguments");
                        case 1:
                            return args[0];
                        default:
                            break;
                    }
                    return eteq::make_functor<T>(*registry,::egen::MUL,eteq::to_tensors(args));
        - name: softmax
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: teq::RankT
            name: offset
            default: "0"
          - type: teq::RankT
            name: ndims
            default: teq::rank_cap
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    if (offset + ndims > teq::rank_cap)
                    {
                        teq::fatalf("cannot perform softmax on dimensions beyond %d",
                            teq::rank_cap);
                    }
                    teq::Shape shape = arg->shape();
                    auto overflow_preventer = this->extend_like(
                        this->reduce_max(arg,offset,ndims),arg);
                    auto exarg = this->exp(this->sub(arg,overflow_preventer));
                    auto it = shape.begin() + offset;
                    std::vector<teq::DimT> xlist(it,it + ndims);
                    return this->div(exarg,
                        this->extend_like(this->add(
                            this->reduce_sum(exarg,offset,ndims),
                            std::numeric_limits<T>::epsilon()),exarg));
        - name: relu
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return this->max(arg,(T) 0);
        - name: softplus
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return this->log(this->add((T) 1,this->exp(arg)));
        - name: sign
          args:
          - type: const eteq::ETensor<T>&
            name: x
          out:
            type: eteq::ETensor<T>
            val: return this->add(this->mul((T)-2,this->lt(x,(T)0)),(T)1);
    - cfg/eteq/approx.yml
    - cfg/eteq/error.yml
    - cfg/eteq/layer.yml
    - cfg/eteq/nn.yml
    - cfg/eteq/random.yml

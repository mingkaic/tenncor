api:
  pybind_type: float
  includes:
  - '"tenncor/derive.hpp"'
  - '"tenncor/layer.hpp"'
  - '"tenncor/eteq/make.hpp"'
  - '"layr/approx.hpp"'
  - '"layr/init.hpp"'
  - '"layr/layer.hpp"'
  pyignore_type:
    - teq::RankT
    - teq::DimT
    - eigen::PairVecT<teq::RankT>
    - eteq::DimPairsT
    - eteq::EVariable<T>
    - eteq::ETensorsT<T>
    - eteq::EVariablesT<T>
    - layr::UnaryF<T>
    - layr::InitF<T>
    - std::set<teq::RankT>
    - std::vector<teq::DimT>
    - std::pair<eteq::DimPairsT,eteq::DimPairsT>
  pybind_includes:
  - '"python/tenncor.hpp"'
  pybind_module: tenncor
  pyglobal:
    - name: api
      type: TenncorAPI<float>
      decl: |
          //
              static TenncorAPI<float> global(global::context());
              return global;
  funcs:
    - template: typename T
      description: Get global tenncor api instance
      name: tenncor
      out:
        type: TenncorAPI<T>&
        val: |
            //
                static TenncorAPI<T> api;
                return api;
      pyignores: True
    - template: typename T
      description: Negation operator with output ETensor using the same context as the input
      operator: "-"
      args:
      - type: const eteq::ETensor<T>&
        name: arg
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(arg.get_context()).neg(arg);
    - template: typename T
      description: Addition operator with output ETensor using the same context as the left input
      operator: +
      args:
      - type: const eteq::ETensor<T>&
        name: a
      - type: const eteq::ETensor<T>&
        name: b
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(a.get_context()).add(a,b);
    - template: typename T
      description: Addition operator with output ETensor using the same context as the tensor input
      operator: +
      args:
      - type: const eteq::ETensor<T>&
        name: arg
      - type: T
        name: scalar
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(arg.get_context()).add(arg,scalar);
    - template: typename T
      description: Addition operator with output ETensor using the same context as the tensor input
      operator: +
      args:
      - type: T
        name: scalar
      - type: const eteq::ETensor<T>&
        name: arg
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(arg.get_context()).add(scalar,arg);
    - template: typename T
      description: Subtraction operator with output ETensor using the same context as the left input
      operator: "-"
      args:
      - type: const eteq::ETensor<T>&
        name: a
      - type: const eteq::ETensor<T>&
        name: b
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(a.get_context()).sub(a,b);
    - template: typename T
      description: Subtraction operator with output ETensor using the same context as the tensor input
      operator: "-"
      args:
      - type: const eteq::ETensor<T>&
        name: arg
      - type: T
        name: scalar
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(arg.get_context()).sub(arg,scalar);
    - template: typename T
      description: Subtraction operator with output ETensor using the same context as the tensor input
      operator: "-"
      args:
      - type: T
        name: scalar
      - type: const eteq::ETensor<T>&
        name: arg
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(arg.get_context()).sub(scalar,arg);
    - template: typename T
      description: Multiplication operator with output ETensor using the same context as the left input
      operator: "*"
      args:
      - type: const eteq::ETensor<T>&
        name: a
      - type: const eteq::ETensor<T>&
        name: b
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(a.get_context()).mul(a,b);
    - template: typename T
      description: Multiplication operator with output ETensor using the same context as the tensor input
      operator: "*"
      args:
      - type: const eteq::ETensor<T>&
        name: arg
      - type: T
        name: scalar
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(arg.get_context()).mul(arg,scalar);
    - template: typename T
      description: Multiplication operator with output ETensor using the same context as the tensor input
      operator: "*"
      args:
      - type: T
        name: scalar
      - type: const eteq::ETensor<T>&
        name: arg
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(arg.get_context()).mul(scalar,arg);
    - template: typename T
      description: Division operator with output ETensor using the same context as the left input
      operator: /
      args:
      - type: const eteq::ETensor<T>&
        name: a
      - type: const eteq::ETensor<T>&
        name: b
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(a.get_context()).div(a,b);
    - template: typename T
      description: Division operator with output ETensor using the same context as the tensor input
      operator: /
      args:
      - type: const eteq::ETensor<T>&
        name: arg
      - type: T
        name: scalar
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(arg.get_context()).div(arg,scalar);
    - template: typename T
      description: Division operator with output ETensor using the same context as the tensor input
      operator: /
      args:
      - type: T
        name: scalar
      - type: const eteq::ETensor<T>&
        name: arg
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(arg.get_context()).div(scalar,arg);
    - template: typename T
      description: Equality operator with output ETensor using the same context as the left input
      operator: ==
      args:
      - type: const eteq::ETensor<T>&
        name: a
      - type: const eteq::ETensor<T>&
        name: b
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(a.get_context()).eq(a,b);
    - template: typename T
      description: Equality operator with output ETensor using the same context as the tensor input
      operator: ==
      args:
      - type: const eteq::ETensor<T>&
        name: arg
      - type: T
        name: scalar
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(arg.get_context()).eq(arg,scalar);
    - template: typename T
      description: Equality operator with output ETensor using the same context as the tensor input
      operator: ==
      args:
      - type: T
        name: scalar
      - type: const eteq::ETensor<T>&
        name: arg
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(arg.get_context()).eq(scalar,arg);
    - template: typename T
      description: Inequality operator with output ETensor using the same context as the left input
      operator: "!="
      args:
      - type: const eteq::ETensor<T>&
        name: a
      - type: const eteq::ETensor<T>&
        name: b
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(a.get_context()).neq(a,b);
    - template: typename T
      description: Inequality operator with output ETensor using the same context as the tensor input
      operator: "!="
      args:
      - type: const eteq::ETensor<T>&
        name: arg
      - type: T
        name: scalar
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(arg.get_context()).neq(arg,scalar);
    - template: typename T
      description: Inequality operator with output ETensor using the same context as the tensor input
      operator: "!="
      args:
      - type: T
        name: scalar
      - type: const eteq::ETensor<T>&
        name: arg
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(arg.get_context()).neq(scalar,arg);
    - template: typename T
      description: Lesser than operator with output ETensor using the same context as the left input
      operator: <
      args:
      - type: const eteq::ETensor<T>&
        name: a
      - type: const eteq::ETensor<T>&
        name: b
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(a.get_context()).lt(a,b);
    - template: typename T
      description: Lesser than operator with output ETensor using the same context as the tensor input
      operator: <
      args:
      - type: const eteq::ETensor<T>&
        name: arg
      - type: T
        name: scalar
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(arg.get_context()).lt(arg,scalar);
    - template: typename T
      description: Lesser than operator with output ETensor using the same context as the tensor input
      operator: <
      args:
      - type: T
        name: scalar
      - type: const eteq::ETensor<T>&
        name: arg
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(arg.get_context()).lt(scalar,arg);
    - template: typename T
      description: Greater than operator with output ETensor using the same context as the left input
      operator: ">"
      args:
      - type: const eteq::ETensor<T>&
        name: a
      - type: const eteq::ETensor<T>&
        name: b
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(a.get_context()).gt(a,b);
    - template: typename T
      description: Greater than operator with output ETensor using the same context as the tensor input
      operator: ">"
      args:
      - type: const eteq::ETensor<T>&
        name: arg
      - type: T
        name: scalar
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(arg.get_context()).gt(arg,scalar);
    - template: typename T
      description: Greater than operator with output ETensor using the same context as the tensor input
      operator: ">"
      args:
      - type: T
        name: scalar
      - type: const eteq::ETensor<T>&
        name: arg
      out:
        type: eteq::ETensor<T>
        val: return TenncorAPI<T>(arg.get_context()).gt(scalar,arg);
  classes:
    - name: TenncorAPI
      template: typename T
      init:
        args:
          - name: context
            type: global::CfgMapptrT
            default: global::context()
        initlist:
          random: this
          nn: this
          layer: this
          error: this
          approx: this
          ctx: context
      copy:
        other: other
        initlist:
          random: this
          nn: this
          layer: this
          error: this
          approx: this
          ctx: other.ctx
        do: |
          //
              if (&other != this)
              {
                  this->ctx = other.ctx;
                  this->random = RandomAPI<T>(this);
                  this->nn = NnAPI<T>(this);
                  this->layer = LayerAPI<T>(this);
                  this->error = ErrorAPI<T>(this);
                  this->approx = ApproxAPI<T>(this);
              }
      move:
        other: other
        initlist:
          random: this
          nn: this
          layer: this
          error: this
          approx: this
          ctx: other.ctx
        do: |
          //
              if (&other != this)
              {
                  this->ctx = other.ctx;
                  this->random = RandomAPI<T>(this);
                  this->nn = NnAPI<T>(this);
                  this->layer = LayerAPI<T>(this);
                  this->error = ErrorAPI<T>(this);
                  this->approx = ApproxAPI<T>(this);
              }
      members:
        - name: ctx
          type: global::CfgMapptrT
          public: True
        - name: random
          type: RandomAPI<T>
          public: True
        - name: nn
          type: NnAPI<T>
          public: True
        - name: layer
          type: LayerAPI<T>
          public: True
        - name: error
          type: ErrorAPI<T>
          public: True
        - name: approx
          type: ApproxAPI<T>
          public: True
      funcs:
        - name: depends
          description: |
                      Return a node that takes on the identity of dependee except dependencies are children of the node.
                      Meaning, in order to calculate the latest value of dependee, dependencies needs to be calculated as well.
          args:
          - type: const eteq::ETensor<T>&
            name: dependee
          - type: const eteq::ETensorsT<T>&
            name: dependencies
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    if (dependencies.empty())
                    {
                        global::fatal("cannot depend on nothing");
                    }
                    if (auto dep = std::dynamic_pointer_cast<eigen::Observable>(
                      (teq::TensptrT) dependee))
                    {
                        eteq::add_dependencies(dependee, teq::TensptrsT(
                            dependencies.begin(), dependencies.end()));
                    }
                    return dependee;
        - name: assign
          args:
          - type: const eteq::EVariable<T>&
            name: target
          - type: const eteq::ETensor<T>&
            name: source
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::ASSIGN,teq::TensptrsT{target,source});
        - name: assign_add
          args:
          - type: const eteq::EVariable<T>&
            name: target
          - type: const eteq::ETensor<T>&
            name: source
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::ASSIGN_ADD,teq::TensptrsT{target,source});
        - name: assign_sub
          args:
          - type: const eteq::EVariable<T>&
            name: target
          - type: const eteq::ETensor<T>&
            name: source
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::ASSIGN_SUB,teq::TensptrsT{target,source});
        - name: assign_mul
          args:
          - type: const eteq::EVariable<T>&
            name: target
          - type: const eteq::ETensor<T>&
            name: source
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::ASSIGN_MUL,teq::TensptrsT{target,source});
        - name: assign_div
          args:
          - type: const eteq::EVariable<T>&
            name: target
          - type: const eteq::ETensor<T>&
            name: source
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::ASSIGN_DIV,teq::TensptrsT{target,source});
        - name: identity
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::IDENTITY,teq::TensptrsT{arg});
        - name: abs
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::ABS,teq::TensptrsT{arg});
        - name: neg
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::NEG,teq::TensptrsT{arg});
        - name: sin
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::SIN,teq::TensptrsT{arg});
        - name: cos
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::COS,teq::TensptrsT{arg});
        - name: tan
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::TAN,teq::TensptrsT{arg});
        - name: exp
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::EXP,teq::TensptrsT{arg});
        - name: log
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::LOG,teq::TensptrsT{arg});
        - name: sqrt
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::SQRT,teq::TensptrsT{arg});
        - name: round
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::ROUND,teq::TensptrsT{arg});
        - name: sigmoid
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::SIGMOID,teq::TensptrsT{arg});
        - name: tanh
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::TANH,teq::TensptrsT{arg});
        - name: square
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::SQUARE,teq::TensptrsT{arg});
        - name: cube
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::CUBE,teq::TensptrsT{arg});
        - name: pow
          args:
          - type: const eteq::ETensor<T>&
            name: a
          - type: const eteq::ETensor<T>&
            name: b
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::POW,teq::TensptrsT{a,b});
        - name: pow
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: T
            name: scalar
          out:
            type: eteq::ETensor<T>
            val: return this->pow(arg,eteq::make_constant_like<T>(scalar,arg));
        - name: pow
          args:
          - type: T
            name: scalar
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return this->pow(eteq::make_constant_like<T>(scalar,arg,ctx),arg);
        - name: add
          args:
          - type: const eteq::ETensor<T>&
            name: a
          - type: const eteq::ETensor<T>&
            name: b
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::ADD,teq::TensptrsT{a,b});
        - name: add
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: T
            name: scalar
          out:
            type: eteq::ETensor<T>
            val: return this->add(arg,eteq::make_constant_like<T>(scalar,arg,ctx));
        - name: add
          args:
          - type: T
            name: scalar
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return this->add(eteq::make_constant_like<T>(scalar,arg,ctx),arg);
        - name: sub
          args:
          - type: const eteq::ETensor<T>&
            name: a
          - type: const eteq::ETensor<T>&
            name: b
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::SUB,teq::TensptrsT{a,b});
        - name: sub
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: T
            name: scalar
          out:
            type: eteq::ETensor<T>
            val: return this->sub(arg,eteq::make_constant_like<T>(scalar,arg,ctx));
        - name: sub
          args:
          - type: T
            name: scalar
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return this->sub(eteq::make_constant_like<T>(scalar,arg,ctx),arg);
        - name: mul
          args:
          - type: const eteq::ETensor<T>&
            name: a
          - type: const eteq::ETensor<T>&
            name: b
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::MUL,teq::TensptrsT{a,b});
        - name: mul
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: T
            name: scalar
          out:
            type: eteq::ETensor<T>
            val: return this->mul(arg,eteq::make_constant_like<T>(scalar,arg,ctx));
        - name: mul
          args:
          - type: T
            name: scalar
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return this->mul(eteq::make_constant_like<T>(scalar,arg,ctx),arg);
        - name: div
          args:
          - type: const eteq::ETensor<T>&
            name: a
          - type: const eteq::ETensor<T>&
            name: b
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::DIV,teq::TensptrsT{a,b});
        - name: div
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: T
            name: scalar
          out:
            type: eteq::ETensor<T>
            val: return this->div(arg,eteq::make_constant_like<T>(scalar,arg,ctx));
        - name: div
          args:
          - type: T
            name: scalar
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return this->div(eteq::make_constant_like<T>(scalar,arg,ctx),arg);
        - name: eq
          args:
          - type: const eteq::ETensor<T>&
            name: a
          - type: const eteq::ETensor<T>&
            name: b
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::EQ,teq::TensptrsT{a,b});
        - name: eq
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: T
            name: scalar
          out:
            type: eteq::ETensor<T>
            val: return this->eq(arg,eteq::make_constant_like<T>(scalar,arg,ctx));
        - name: eq
          args:
          - type: T
            name: scalar
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return this->eq(eteq::make_constant_like<T>(scalar,arg,ctx),arg);
        - name: neq
          args:
          - type: const eteq::ETensor<T>&
            name: a
          - type: const eteq::ETensor<T>&
            name: b
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::NEQ,teq::TensptrsT{a,b});
        - name: neq
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: T
            name: scalar
          out:
            type: eteq::ETensor<T>
            val: return this->neq(arg,eteq::make_constant_like<T>(scalar,arg,ctx));
        - name: neq
          args:
          - type: T
            name: scalar
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return this->neq(eteq::make_constant_like<T>(scalar,arg,ctx),arg);
        - name: lt
          args:
          - type: const eteq::ETensor<T>&
            name: a
          - type: const eteq::ETensor<T>&
            name: b
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::LT,teq::TensptrsT{a,b});
        - name: lt
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: T
            name: scalar
          out:
            type: eteq::ETensor<T>
            val: return this->lt(arg,eteq::make_constant_like<T>(scalar,arg,ctx));
        - name: lt
          args:
          - type: T
            name: scalar
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return this->lt(eteq::make_constant_like<T>(scalar,arg,ctx),arg);
        - name: gt
          args:
          - type: const eteq::ETensor<T>&
            name: a
          - type: const eteq::ETensor<T>&
            name: b
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::GT,teq::TensptrsT{a,b});
        - name: gt
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: T
            name: scalar
          out:
            type: eteq::ETensor<T>
            val: return this->gt(arg,eteq::make_constant_like<T>(scalar,arg,ctx));
        - name: gt
          args:
          - type: T
            name: scalar
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return this->gt(eteq::make_constant_like<T>(scalar,arg,ctx),arg);
        - name: min
          args:
          - type: const eteq::ETensor<T>&
            name: a
          - type: const eteq::ETensor<T>&
            name: b
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::MIN,teq::TensptrsT{a,b});
        - name: min
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: T
            name: scalar
          out:
            type: eteq::ETensor<T>
            val: return this->min(arg,eteq::make_constant_like<T>(scalar,arg,ctx));
        - name: min
          args:
          - type: T
            name: scalar
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return this->min(eteq::make_constant_like<T>(scalar,arg,ctx),arg);
        - name: min
          args:
          - type: const eteq::ETensorsT<T>&
            name: args
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    if (args.empty())
                    {
                        global::fatal("cannot min without arguments");
                    }
                    eteq::ETensor<T> out = args[0];
                    for (size_t i = 1,n = args.size(); i < n; ++i)
                    {
                        out = this->min(out,args[i]);
                    }
                    return out;
        - name: max
          args:
          - type: const eteq::ETensor<T>&
            name: a
          - type: const eteq::ETensor<T>&
            name: b
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::MAX,teq::TensptrsT{a,b});
        - name: max
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: T
            name: scalar
          out:
            type: eteq::ETensor<T>
            val: return this->max(arg,eteq::make_constant_like<T>(scalar,arg,ctx));
        - name: max
          args:
          - type: T
            name: scalar
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return this->max(eteq::make_constant_like<T>(scalar,arg,ctx),arg);
        - name: max
          args:
          - type: const eteq::ETensorsT<T>&
            name: args
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    if (args.empty())
                    {
                        global::fatal("cannot max without arguments");
                    }
                    eteq::ETensor<T> out = args[0];
                    for (size_t i = 1,n = args.size(); i < n; ++i)
                    {
                        out = this->max(out,args[i]);
                    }
                    return out;
        - name: if_then_else
          args:
          - type: const eteq::ETensor<T>&
            name: condition
          - type: const eteq::ETensor<T>&
            name: then
          - type: const eteq::ETensor<T>&
            name: otherwise
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    // if then == otherwise and neither are ambiguous,then treat as identity
                    if (then.get() == otherwise.get())
                    {
                        return then;
                    }
                    return eteq::make_functor<T>(ctx,::egen::SELECT,teq::TensptrsT{condition,then,otherwise});
        - name: reverse
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: const std::set<teq::RankT>&
            name: dims
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::REVERSE,teq::TensptrsT{arg},dims);
        - name: permute
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: const std::vector<teq::RankT>&
            name: order
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::PERMUTE,teq::TensptrsT{arg},order);
        - name: extend
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: const std::vector<teq::DimT>&
            name: bcast
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::EXTEND,teq::TensptrsT{arg},bcast);
        - name: extend
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: teq::RankT
            name: offset
          - type: const std::vector<teq::DimT>&
            name: xlist
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    std::vector<teq::DimT> bcast(offset,1);
                    bcast.insert(bcast.end(),xlist.begin(),xlist.end());
                    return eteq::make_functor<T>(ctx,::egen::EXTEND,teq::TensptrsT{arg},bcast);
        - name: concat
          args:
          - type: const eteq::ETensor<T>&
            name: left
          - type: const eteq::ETensor<T>&
            name: right
          - type: teq::RankT
            name: axis
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::CONCAT,teq::TensptrsT{left,right},axis);
        - name: concat
          args:
          - type: const eteq::ETensorsT<T>&
            name: args
          - type: teq::RankT
            name: axis
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::CONCAT,eteq::to_tensors(args),axis);
        - description: Return extended arg so that output shape matches like tensor exactly
          name: extend_like
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: const eteq::ETensor<T>&
            name: like
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::EXTEND,teq::TensptrsT{arg},(teq::TensptrT) like);
        - name: reshape
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: teq::Shape
            name: shape
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::RESHAPE,teq::TensptrsT{arg},shape);
        - description: Return sum of values along dimensions specified
          name: reduce_sum
          args:
          - type: const eteq::ETensor<T>&
            name: tens
          - type: std::set<teq::RankT>
            name: dims
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::REDUCE_SUM,teq::TensptrsT{tens},dims);
        - description: Return product of values along dimensions specified
          name: reduce_prod
          args:
          - type: const eteq::ETensor<T>&
            name: tens
          - type: std::set<teq::RankT>
            name: dims
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::REDUCE_PROD,teq::TensptrsT{tens},dims);
        - description: Return min of values along dimensions specified
          name: reduce_min
          args:
          - type: const eteq::ETensor<T>&
            name: tens
          - type: std::set<teq::RankT>
            name: dims
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::REDUCE_MIN,teq::TensptrsT{tens},dims);
        - description: Return max of values along dimensions specified
          name: reduce_max
          args:
          - type: const eteq::ETensor<T>&
            name: tens
          - type: std::set<teq::RankT>
            name: dims
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::REDUCE_MAX,teq::TensptrsT{tens},dims);
        - description: Return sum of values for ndims dimensions after offset
          name: reduce_sum
          args:
          - type: const eteq::ETensor<T>&
            name: tens
          - type: teq::RankT
            name: offset
            default: "0"
          - type: teq::RankT
            name: ndims
            default: teq::rank_cap
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    if (offset >= teq::rank_cap)
                    {
                        global::fatalf("cannot reduce dimensions [%d:]. Must be less than %d",
                            offset,teq::rank_cap);
                    }
                    std::vector<teq::RankT> dims(std::min(ndims,
                        (teq::RankT) (teq::rank_cap - offset)));
                    std::iota(dims.begin(),dims.end(),offset);
                    return eteq::make_functor<T>(ctx,::egen::REDUCE_SUM,teq::TensptrsT{tens},
                        std::set<teq::RankT>(dims.begin(),dims.end()));
        - description: Return product of values for ndims dimensions after offset
          name: reduce_prod
          args:
          - type: const eteq::ETensor<T>&
            name: tens
          - type: teq::RankT
            name: offset
            default: "0"
          - type: teq::RankT
            name: ndims
            default: teq::rank_cap
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    if (offset >= teq::rank_cap)
                    {
                        global::fatalf("cannot reduce dimensions [%d:]. Must be less than %d",
                            offset,teq::rank_cap);
                    }
                    std::vector<teq::RankT> dims(std::min(ndims,
                        (teq::RankT) (teq::rank_cap - offset)));
                    std::iota(dims.begin(),dims.end(),offset);
                    return eteq::make_functor<T>(ctx,::egen::REDUCE_PROD,teq::TensptrsT{tens},
                        std::set<teq::RankT>(dims.begin(),dims.end()));
        - description: Return min of values for ndims dimensions after offset
          name: reduce_min
          args:
          - type: const eteq::ETensor<T>&
            name: tens
          - type: teq::RankT
            name: offset
            default: "0"
          - type: teq::RankT
            name: ndims
            default: teq::rank_cap
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    if (offset >= teq::rank_cap)
                    {
                        global::fatalf("cannot reduce dimensions [%d:]. Must be less than %d",
                            offset,teq::rank_cap);
                    }
                    std::vector<teq::RankT> dims(std::min(ndims,
                        (teq::RankT) (teq::rank_cap - offset)));
                    std::iota(dims.begin(),dims.end(),offset);
                    return eteq::make_functor<T>(ctx,::egen::REDUCE_MIN,teq::TensptrsT{tens},
                        std::set<teq::RankT>(dims.begin(),dims.end()));
        - description: Return max of values for ndims dimensions after offset
          name: reduce_max
          args:
          - type: const eteq::ETensor<T>&
            name: tens
          - type: teq::RankT
            name: offset
            default: "0"
          - type: teq::RankT
            name: ndims
            default: teq::rank_cap
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    if (offset >= teq::rank_cap)
                    {
                        global::fatalf("cannot reduce dimensions [%d:]. Must be less than %d",
                            offset,teq::rank_cap);
                    }
                    std::vector<teq::RankT> dims(std::min(ndims,
                        (teq::RankT) (teq::rank_cap - offset)));
                    std::iota(dims.begin(),dims.end(),offset);
                    return eteq::make_functor<T>(ctx,::egen::REDUCE_MAX,teq::TensptrsT{tens},
                        std::set<teq::RankT>(dims.begin(),dims.end()));
        - name: argmax
          args:
          - type: const eteq::ETensor<T>&
            name: tens
          - type: teq::RankT
            name: return_dim
            default: "8"
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::ARGMAX,teq::TensptrsT{tens},return_dim);
        - name: n_elems
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_constant_scalar<T>(arg->shape().n_elems(),teq::Shape(),ctx);
        - name: n_dims
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: teq::RankT
            name: rank
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_constant_scalar<T>(arg->shape().at(rank),teq::Shape(),ctx);
        - description: extents vector consists of pairs offset and extent for each dimension
          name: slice
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: eigen::PairVecT<teq::DimT>
            name: extents
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::SLICE,teq::TensptrsT{arg},extents);
        - name: slice
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: teq::DimT
            name: offset
          - type: teq::DimT
            name: extent
          - type: teq::RankT
            name: dimension
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    eigen::PairVecT<teq::DimT> extents(
                        std::max(teq::rank_cap,dimension),
                        {0,std::numeric_limits<teq::DimT>::max()});
                    extents[dimension] = {offset,extent};
                    return this->slice(arg,extents);
        - name: pad
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: eigen::PairVecT<teq::DimT>
            name: paddings
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::PAD,teq::TensptrsT{arg},paddings);
        - name: pad
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: const eteq::DimPairsT&
            name: padding
          - type: teq::RankT
            name: dimension
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    eigen::PairVecT<teq::DimT> paddings(
                        std::max(teq::rank_cap,dimension),{0,0});
                    paddings[dimension] = padding;
                    return this->pad(arg,paddings);
        - name: stride
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: const std::vector<teq::DimT>&
            name: incrs
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::STRIDE,teq::TensptrsT{arg},incrs);
        - description: populate input values at specific increments along its dimensions to fit specified shape (opposite of stride)
          name: scatter
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: const teq::Shape&
            name: outshape
          - type: const std::vector<teq::DimT>&
            name: incrs
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::SCATTER,teq::TensptrsT{arg},outshape,incrs);
        - description: multiple values across specify dimensions pairs before summing all products (generalization of matrix product),defaults to matrix product
          name: contract
          args:
          - type: const eteq::ETensor<T>&
            name: a
          - type: const eteq::ETensor<T>&
            name: b
          - type: eigen::PairVecT<teq::RankT>
            name: dims
            default: eigen::PairVecT<teq::RankT>{{0,1}}
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::MATMUL,teq::TensptrsT{a,b},dims);
        - name: matmul
          args:
          - type: const eteq::ETensor<T>&
            name: a
          - type: const eteq::ETensor<T>&
            name: b
          out:
            type: eteq::ETensor<T>
            val: return this->contract(a,b);
        - name: convolution
          args:
          - type: const eteq::ETensor<T>&
            name: image
          - type: const eteq::ETensor<T>&
            name: kernel
          - type: const std::vector<teq::RankT>&
            name: dims
          out:
            type: eteq::ETensor<T>
            val: return eteq::make_functor<T>(ctx,::egen::CONV,teq::TensptrsT{image,kernel},dims);
        - name: reduce_sum_1d
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: teq::RankT
            name: dimension
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    auto red = this->reduce_sum(arg,dimension,1);

                    std::vector<teq::RankT> indices(teq::rank_cap);
                    auto bt = indices.begin();
                    auto it = bt + dimension;
                    std::iota(bt,it,0);
                    std::iota(it,indices.end(),dimension + 1);
                    indices[teq::rank_cap - 1] = dimension;
                    return this->permute(red,indices);
        - name: reduce_prod_1d
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: teq::RankT
            name: dimension
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    auto red = this->reduce_prod(arg,dimension,1);

                    std::vector<teq::RankT> indices(teq::rank_cap);
                    auto bt = indices.begin();
                    auto it = bt + dimension;
                    std::iota(bt,it,0);
                    std::iota(it,indices.end(),dimension + 1);
                    indices[teq::rank_cap - 1] = dimension;
                    return this->permute(red,indices);
        - name: reduce_min_1d
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: teq::RankT
            name: dimension
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    auto red = this->reduce_min(arg,dimension,1);

                    std::vector<teq::RankT> indices(teq::rank_cap);
                    auto bt = indices.begin();
                    auto it = bt + dimension;
                    std::iota(bt,it,0);
                    std::iota(it,indices.end(),dimension + 1);
                    indices[teq::rank_cap - 1] = dimension;
                    return this->permute(red,indices);
        - name: reduce_max_1d
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: teq::RankT
            name: dimension
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    auto red = this->reduce_max(arg,dimension,1);

                    std::vector<teq::RankT> indices(teq::rank_cap);
                    auto bt = indices.begin();
                    auto it = bt + dimension;
                    std::iota(bt,it,0);
                    std::iota(it,indices.end(),dimension + 1);
                    indices[teq::rank_cap - 1] = dimension;
                    return this->permute(red,indices);
        - name: transpose
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return this->permute(arg,{1,0});
        - name: reduce_mean
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return this->div(this->reduce_sum(arg),this->n_elems(arg));
        - name: reduce_mean_1d
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: teq::RankT
            name: dimension
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    auto red = this->reduce_sum_1d(arg,dimension);
                    auto dim = eteq::make_constant_like<T>(arg->shape().at(dimension),red,ctx);
                    return this->div(red,dim);
        - name: reduce_l2norm
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: teq::RankT
            name: offset
            default: "0"
          - type: teq::RankT
            name: ndims
            default: teq::rank_cap
          out:
            type: eteq::ETensor<T>
            val: return this->sqrt(this->reduce_sum(this->square(arg),offset,ndims));
        - name: reduce_l2norm_1d
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: teq::RankT
            name: dimension
          out:
            type: eteq::ETensor<T>
            val: return this->sqrt(this->reduce_sum_1d(this->square(arg),dimension));
        - name: clip_by_range
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: T
            name: minval
          - type: T
            name: maxval
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    if (minval > maxval)
                    {
                        global::fatal("min value is below max");
                    }
                    auto lo = eteq::make_constant_like<T>(minval,arg,ctx);
                    auto hi = eteq::make_constant_like<T>(maxval,arg,ctx);
                    return this->max(this->min(arg,hi),lo);
        - description: clip by l2norm
          name: clip_by_l2norm
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: T
            name: upper
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    // todo: parameterize l2norm offset and ndims
                    if (upper == 0)
                    {
                        global::fatal("cannot clip_by_norm with a upper limit of 0");
                    }
                    auto norm = this->extend_like(
                        this->reduce_l2norm(arg),arg);
                    auto limit = eteq::make_constant_like<T>(upper,arg,ctx);
                    return this->if_then_else(this->lt(norm,limit),
                        arg,this->div(this->mul(arg,limit),norm));
        - name: sum
          args:
          - type: const eteq::ETensorsT<T>&
            name: args
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    size_t nargs = args.size();
                    switch (nargs)
                    {
                        case 0:
                            global::fatal("cannot sum without arguments");
                        case 1:
                            return args[0];
                        case 2:
                            return this->add(args[0],args[1]);
                        default:
                            break;
                    }
                    return eteq::make_functor<T>(ctx,::egen::ADD,eteq::to_tensors(args));
        - name: prod
          args:
          - type: const eteq::ETensorsT<T>&
            name: args
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    size_t nargs = args.size();
                    switch (nargs)
                    {
                        case 0:
                            global::fatal("cannot prod without arguments");
                        case 1:
                            return args[0];
                        default:
                            break;
                    }
                    return eteq::make_functor<T>(ctx,::egen::MUL,eteq::to_tensors(args));
        - name: softmax
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          - type: teq::RankT
            name: offset
            default: "0"
          - type: teq::RankT
            name: ndims
            default: teq::rank_cap
          out:
            type: eteq::ETensor<T>
            val: |
                //
                    if (offset + ndims > teq::rank_cap)
                    {
                        global::fatalf("cannot perform softmax on dimensions beyond %d",
                            teq::rank_cap);
                    }
                    teq::Shape shape = arg->shape();
                    auto overflow_preventer = this->extend_like(
                        this->reduce_max(arg,offset,ndims),arg);
                    auto exarg = this->exp(this->sub(arg,overflow_preventer));
                    auto it = shape.begin() + offset;
                    std::vector<teq::DimT> xlist(it,it + ndims);
                    return this->div(exarg,
                        this->extend_like(this->add(
                            this->reduce_sum(exarg,offset,ndims),
                            std::numeric_limits<T>::epsilon()),exarg));
        - name: relu
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return this->max(arg,(T) 0);
        - name: softplus
          args:
          - type: const eteq::ETensor<T>&
            name: arg
          out:
            type: eteq::ETensor<T>
            val: return this->log(this->add((T) 1,this->exp(arg)));
        - name: sign
          args:
          - type: const eteq::ETensor<T>&
            name: x
          out:
            type: eteq::ETensor<T>
            val: return this->add(this->mul((T)-2,this->lt(x,(T)0)),(T)1);
    - approx.yml
    - error.yml
    - layer.yml
    - nn.yml
    - random.yml

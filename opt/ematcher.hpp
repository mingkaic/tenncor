#include <unordered_map>

#include "teq/ileaf.hpp"
#include "teq/ifunctor.hpp"

extern "C" {
#include "opt/parse/def.h"
}

#ifndef OPT_EMATCHER_HPP
#define OPT_EMATCHER_HPP

namespace opt
{

struct Candidate final
{
	Candidate (void) = default;

	Candidate (std::string any, teq::TensptrT tens) :
		anys_({{any, tens}}) {}

	/// Map any symbol to associated Tensor
	std::unordered_map<std::string,teq::TensptrT> anys_;

	/// Map variadic symbol to associated Edges
	std::unordered_map<std::string,teq::CEdgesT> variadic_;
};

/// All candidates generated by a matcher
using CandsT = std::vector<Candidate>;

/// Matches matcher function id (fid) to all candidates
using MatchMapT = std::unordered_map<std::string,CandsT>;

/// Mapping of all visited tensors to their matched candidates
using MatchCtxT = std::unordered_map<teq::iTensor*,MatchMapT>;

struct iEdgeMatcher
{
	iEdgeMatcher (const ::PtrList& attrs)
	{
		if (::KV_PAIR != attrs.type_)
		{
			logs::fatalf("passing attributes by %d typed list", attrs.type_);
		}
		for (auto it = attrs.head_; nullptr != it; it = it->next_)
		{
			auto kv = (::KeyVal*) it->val_;
			std::string key(kv->key_);
			if (estd::has(attrs_, key))
			{
				// todo: warn of duplicate attrs
				continue;
			}
			std::vector<double> values;
			for (auto jt = kv->val_.head_; nullptr != jt; jt = jt->next_)
			{
				values.push_back(jt->val_);
			}
			if (kv->val_scalar_)
			{
				attrs_.emplace(key,
					std::make_unique<marsh::Number<double>>(values[0]));
			}
			else
			{
				attrs_.emplace(key,
					std::make_unique<marsh::NumArray<double>>(values));
			}
		}
	}

	virtual ~iEdgeMatcher (void) = default;

	/// Return no candidates if edge attributes don't match or
	/// matching child doesn't exist or have no candidates,
	/// otherwise return candidates
	CandsT match (const MatchCtxT& ctx, const teq::iEdge& edge)
	{
		if (attrs_.size() > 0)
		{
			marsh::Maps mvalues;
			edge.get_attrs(mvalues);

			for (auto& apairs : attrs_)
			{
				if (false == estd::has(mvalues.contents_, apairs.first))
				{
					return CandsT{};
				}
				if (false == mvalues.contents_.at(apairs.first)->equals(
						*apairs.second))
				{
					return CandsT{};
				}
			}
		}
		return child_match(ctx, edge.get_tensor());
	};

protected:
	virtual CandsT child_match (const MatchCtxT& cands, const teq::TensptrT& child) = 0;

private:
	std::unordered_map<std::string,marsh::ObjptrT> attrs_;
};

using EMatchptrT = std::unique_ptr<iEdgeMatcher>;

using EMatchptrsT = std::vector<EMatchptrT>;

struct ScalarEMatcher final : public iEdgeMatcher
{
	ScalarEMatcher (double scalar, const ::PtrList& attrs) :
		iEdgeMatcher(attrs), scalar_(scalar) {}

private:
	CandsT child_match (const MatchCtxT& ctx, const teq::TensptrT& child) override
	{
		CandsT out;
		auto leaf = dynamic_cast<teq::iLeaf*>(child.get());
		if (nullptr != leaf && leaf->is_const())
		{
			teq::Shape shape = child->shape();
			std::vector<double> d(shape.n_elems(), scalar_);
			if (leaf->to_string() == teq::const_encode(d.data(), shape))
			{
				out.push_back(Candidate());
			}
		}
		return out;
	}

	double scalar_;
};

struct AnyEMatcher final : public iEdgeMatcher
{
	AnyEMatcher (std::string any, const ::PtrList& attrs) :
		iEdgeMatcher(attrs), any_(any) {}

private:
	CandsT child_match (const MatchCtxT& ctx, const teq::TensptrT& child) override
	{
		return CandsT{Candidate(any_, child)};
	}

	std::string any_;
};

struct FuncEMatcher final : public iEdgeMatcher
{
	FuncEMatcher (std::string fid, const ::PtrList& attrs) :
		iEdgeMatcher(attrs), fid_(fid) {}

private:
	CandsT child_match (const MatchCtxT& ctx, const teq::TensptrT& child) override
	{
		if (false == estd::has(ctx, child.get()))
		{
			return CandsT{};
		}
		const MatchMapT& m2cands = ctx.at(child.get());
		CandsT out;
		return estd::try_get(m2cands, fid_, out);
	}

	std::string fid_;
};

}

#endif // OPT_EMATCHER_HPP
